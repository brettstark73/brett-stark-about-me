declare module "Iteration/Iteration" {
    /**
    An entry of **`IterationMap`**
    * `[0]`: Prev (<-)
    * `[1]`: Next (->)
    * `[2]`: Current **`string`**
    * `[3]`: Current **`number`**
    * `[4]`: Current Negative **`string`**
    * `[5]`: Cumulated Previous **`keys`** (for `Min` & `Max`)
    * `[6]`: Sign (- / 0 / +)
    */
    export type Iteration = [
        string,
        string,
        string,
        number,
        string,
        string,
        '-' | '0' | '+'
    ];
}
declare module "Iteration/Map" {
    import { Iteration } from "Iteration/Iteration";
    /**
     * Defines a basic map that will be passed to [[CreateMap]]
     * @hidden
     */
    type RawMap = {
        [K in string]: Iteration;
    };
    /**
     * Serves the purpose of completing a [[RawMap]]'s boundaries
     * @hidden
     */
    type BoundMap = {
        [K in string]: ['__', '__', string, number, string, string, '-' | '0' | '+'];
    };
    /**
     * Defines how to define the keys that make a [[RawMap]]
     * @hidden
     */
    type Keys<M extends RawMap> = {
        '-': keyof M;
        '0': keyof M;
        '+': keyof M;
    };
    /**
    Describes a map of number relationships
    */
    export type Map = [
        Keys<RawMap>,
        RawMap
    ];
    /**
    Creates a [[Map]] of number relationships
    */
    export type CreateMap<K extends Keys<RawMap>, RM extends RawMap> = [
        K,
        RM & BoundMap
    ];
}
declare module "Iteration/Maps/Number" {
    import { CreateMap } from "Iteration/Map";
    /**
     * @hidden
     */
    type RawMap = {
        '-100': ['__', '-99', '-100', -100, '100', '-100', '-'];
        '-99': ['-100', '-98', '-99', -99, '99', RawMap['-100'][5] | '-99', '-'];
        '-98': ['-99', '-97', '-98', -98, '98', RawMap['-99'][5] | '-98', '-'];
        '-97': ['-98', '-96', '-97', -97, '97', RawMap['-98'][5] | '-97', '-'];
        '-96': ['-97', '-95', '-96', -96, '96', RawMap['-97'][5] | '-96', '-'];
        '-95': ['-96', '-94', '-95', -95, '95', RawMap['-96'][5] | '-95', '-'];
        '-94': ['-95', '-93', '-94', -94, '94', RawMap['-95'][5] | '-94', '-'];
        '-93': ['-94', '-92', '-93', -93, '93', RawMap['-94'][5] | '-93', '-'];
        '-92': ['-93', '-91', '-92', -92, '92', RawMap['-93'][5] | '-92', '-'];
        '-91': ['-92', '-90', '-91', -91, '91', RawMap['-92'][5] | '-91', '-'];
        '-90': ['-91', '-89', '-90', -90, '90', RawMap['-91'][5] | '-90', '-'];
        '-89': ['-90', '-88', '-89', -89, '89', RawMap['-90'][5] | '-89', '-'];
        '-88': ['-89', '-87', '-88', -88, '88', RawMap['-89'][5] | '-88', '-'];
        '-87': ['-88', '-86', '-87', -87, '87', RawMap['-88'][5] | '-87', '-'];
        '-86': ['-87', '-85', '-86', -86, '86', RawMap['-87'][5] | '-86', '-'];
        '-85': ['-86', '-84', '-85', -85, '85', RawMap['-86'][5] | '-85', '-'];
        '-84': ['-85', '-83', '-84', -84, '84', RawMap['-85'][5] | '-84', '-'];
        '-83': ['-84', '-82', '-83', -83, '83', RawMap['-84'][5] | '-83', '-'];
        '-82': ['-83', '-81', '-82', -82, '82', RawMap['-83'][5] | '-82', '-'];
        '-81': ['-82', '-80', '-81', -81, '81', RawMap['-82'][5] | '-81', '-'];
        '-80': ['-81', '-79', '-80', -80, '80', RawMap['-81'][5] | '-80', '-'];
        '-79': ['-80', '-78', '-79', -79, '79', RawMap['-80'][5] | '-79', '-'];
        '-78': ['-79', '-77', '-78', -78, '78', RawMap['-79'][5] | '-78', '-'];
        '-77': ['-78', '-76', '-77', -77, '77', RawMap['-78'][5] | '-77', '-'];
        '-76': ['-77', '-75', '-76', -76, '76', RawMap['-77'][5] | '-76', '-'];
        '-75': ['-76', '-74', '-75', -75, '75', RawMap['-76'][5] | '-75', '-'];
        '-74': ['-75', '-73', '-74', -74, '74', RawMap['-75'][5] | '-74', '-'];
        '-73': ['-74', '-72', '-73', -73, '73', RawMap['-74'][5] | '-73', '-'];
        '-72': ['-73', '-71', '-72', -72, '72', RawMap['-73'][5] | '-72', '-'];
        '-71': ['-72', '-70', '-71', -71, '71', RawMap['-72'][5] | '-71', '-'];
        '-70': ['-71', '-69', '-70', -70, '70', RawMap['-71'][5] | '-70', '-'];
        '-69': ['-70', '-68', '-69', -69, '69', RawMap['-70'][5] | '-69', '-'];
        '-68': ['-69', '-67', '-68', -68, '68', RawMap['-69'][5] | '-68', '-'];
        '-67': ['-68', '-66', '-67', -67, '67', RawMap['-68'][5] | '-67', '-'];
        '-66': ['-67', '-65', '-66', -66, '66', RawMap['-67'][5] | '-66', '-'];
        '-65': ['-66', '-64', '-65', -65, '65', RawMap['-66'][5] | '-65', '-'];
        '-64': ['-65', '-63', '-64', -64, '64', RawMap['-65'][5] | '-64', '-'];
        '-63': ['-64', '-62', '-63', -63, '63', RawMap['-64'][5] | '-63', '-'];
        '-62': ['-63', '-61', '-62', -62, '62', RawMap['-63'][5] | '-62', '-'];
        '-61': ['-62', '-60', '-61', -61, '61', RawMap['-62'][5] | '-61', '-'];
        '-60': ['-61', '-59', '-60', -60, '60', RawMap['-61'][5] | '-60', '-'];
        '-59': ['-60', '-58', '-59', -59, '59', RawMap['-60'][5] | '-59', '-'];
        '-58': ['-59', '-57', '-58', -58, '58', RawMap['-59'][5] | '-58', '-'];
        '-57': ['-58', '-56', '-57', -57, '57', RawMap['-58'][5] | '-57', '-'];
        '-56': ['-57', '-55', '-56', -56, '56', RawMap['-57'][5] | '-56', '-'];
        '-55': ['-56', '-54', '-55', -55, '55', RawMap['-56'][5] | '-55', '-'];
        '-54': ['-55', '-53', '-54', -54, '54', RawMap['-55'][5] | '-54', '-'];
        '-53': ['-54', '-52', '-53', -53, '53', RawMap['-54'][5] | '-53', '-'];
        '-52': ['-53', '-51', '-52', -52, '52', RawMap['-53'][5] | '-52', '-'];
        '-51': ['-52', '-50', '-51', -51, '51', RawMap['-52'][5] | '-51', '-'];
        '-50': ['-51', '-49', '-50', -50, '50', RawMap['-51'][5] | '-50', '-'];
        '-49': ['-50', '-48', '-49', -49, '49', RawMap['-50'][5] | '-49', '-'];
        '-48': ['-49', '-47', '-48', -48, '48', RawMap['-49'][5] | '-48', '-'];
        '-47': ['-48', '-46', '-47', -47, '47', RawMap['-48'][5] | '-47', '-'];
        '-46': ['-47', '-45', '-46', -46, '46', RawMap['-47'][5] | '-46', '-'];
        '-45': ['-46', '-44', '-45', -45, '45', RawMap['-46'][5] | '-45', '-'];
        '-44': ['-45', '-43', '-44', -44, '44', RawMap['-45'][5] | '-44', '-'];
        '-43': ['-44', '-42', '-43', -43, '43', RawMap['-44'][5] | '-43', '-'];
        '-42': ['-43', '-41', '-42', -42, '42', RawMap['-43'][5] | '-42', '-'];
        '-41': ['-42', '-40', '-41', -41, '41', RawMap['-42'][5] | '-41', '-'];
        '-40': ['-41', '-39', '-40', -40, '40', RawMap['-41'][5] | '-40', '-'];
        '-39': ['-40', '-38', '-39', -39, '39', RawMap['-40'][5] | '-39', '-'];
        '-38': ['-39', '-37', '-38', -38, '38', RawMap['-39'][5] | '-38', '-'];
        '-37': ['-38', '-36', '-37', -37, '37', RawMap['-38'][5] | '-37', '-'];
        '-36': ['-37', '-35', '-36', -36, '36', RawMap['-37'][5] | '-36', '-'];
        '-35': ['-36', '-34', '-35', -35, '35', RawMap['-36'][5] | '-35', '-'];
        '-34': ['-35', '-33', '-34', -34, '34', RawMap['-35'][5] | '-34', '-'];
        '-33': ['-34', '-32', '-33', -33, '33', RawMap['-34'][5] | '-33', '-'];
        '-32': ['-33', '-31', '-32', -32, '32', RawMap['-33'][5] | '-32', '-'];
        '-31': ['-32', '-30', '-31', -31, '31', RawMap['-32'][5] | '-31', '-'];
        '-30': ['-31', '-29', '-30', -30, '30', RawMap['-31'][5] | '-30', '-'];
        '-29': ['-30', '-28', '-29', -29, '29', RawMap['-30'][5] | '-29', '-'];
        '-28': ['-29', '-27', '-28', -28, '28', RawMap['-29'][5] | '-28', '-'];
        '-27': ['-28', '-26', '-27', -27, '27', RawMap['-28'][5] | '-27', '-'];
        '-26': ['-27', '-25', '-26', -26, '26', RawMap['-27'][5] | '-26', '-'];
        '-25': ['-26', '-24', '-25', -25, '25', RawMap['-26'][5] | '-25', '-'];
        '-24': ['-25', '-23', '-24', -24, '24', RawMap['-25'][5] | '-24', '-'];
        '-23': ['-24', '-22', '-23', -23, '23', RawMap['-24'][5] | '-23', '-'];
        '-22': ['-23', '-21', '-22', -22, '22', RawMap['-23'][5] | '-22', '-'];
        '-21': ['-22', '-20', '-21', -21, '21', RawMap['-22'][5] | '-21', '-'];
        '-20': ['-21', '-19', '-20', -20, '20', RawMap['-21'][5] | '-20', '-'];
        '-19': ['-20', '-18', '-19', -19, '19', RawMap['-20'][5] | '-19', '-'];
        '-18': ['-19', '-17', '-18', -18, '18', RawMap['-19'][5] | '-18', '-'];
        '-17': ['-18', '-16', '-17', -17, '17', RawMap['-18'][5] | '-17', '-'];
        '-16': ['-17', '-15', '-16', -16, '16', RawMap['-17'][5] | '-16', '-'];
        '-15': ['-16', '-14', '-15', -15, '15', RawMap['-16'][5] | '-15', '-'];
        '-14': ['-15', '-13', '-14', -14, '14', RawMap['-15'][5] | '-14', '-'];
        '-13': ['-14', '-12', '-13', -13, '13', RawMap['-14'][5] | '-13', '-'];
        '-12': ['-13', '-11', '-12', -12, '12', RawMap['-13'][5] | '-12', '-'];
        '-11': ['-12', '-10', '-11', -11, '11', RawMap['-12'][5] | '-11', '-'];
        '-10': ['-11', '-9', '-10', -10, '10', RawMap['-11'][5] | '-10', '-'];
        '-9': ['-10', '-8', '-9', -9, '9', RawMap['-10'][5] | '-9', '-'];
        '-8': ['-9', '-7', '-8', -8, '8', RawMap['-9'][5] | '-8', '-'];
        '-7': ['-8', '-6', '-7', -7, '7', RawMap['-8'][5] | '-7', '-'];
        '-6': ['-7', '-5', '-6', -6, '6', RawMap['-7'][5] | '-6', '-'];
        '-5': ['-6', '-4', '-5', -5, '5', RawMap['-6'][5] | '-5', '-'];
        '-4': ['-5', '-3', '-4', -4, '4', RawMap['-5'][5] | '-4', '-'];
        '-3': ['-4', '-2', '-3', -3, '3', RawMap['-4'][5] | '-3', '-'];
        '-2': ['-3', '-1', '-2', -2, '2', RawMap['-3'][5] | '-2', '-'];
        '-1': ['-2', '0', '-1', -1, '1', RawMap['-2'][5] | '-1', '-'];
        '0': ['-1', '1', '0', 0, '0', RawMap['-1'][5] | '0', '0'];
        '1': ['0', '2', '1', 1, '-1', RawMap['0'][5] | '1', '+'];
        '2': ['1', '3', '2', 2, '-2', RawMap['1'][5] | '2', '+'];
        '3': ['2', '4', '3', 3, '-3', RawMap['2'][5] | '3', '+'];
        '4': ['3', '5', '4', 4, '-4', RawMap['3'][5] | '4', '+'];
        '5': ['4', '6', '5', 5, '-5', RawMap['4'][5] | '5', '+'];
        '6': ['5', '7', '6', 6, '-6', RawMap['5'][5] | '6', '+'];
        '7': ['6', '8', '7', 7, '-7', RawMap['6'][5] | '7', '+'];
        '8': ['7', '9', '8', 8, '-8', RawMap['7'][5] | '8', '+'];
        '9': ['8', '10', '9', 9, '-9', RawMap['8'][5] | '9', '+'];
        '10': ['9', '11', '10', 10, '-10', RawMap['9'][5] | '10', '+'];
        '11': ['10', '12', '11', 11, '-11', RawMap['10'][5] | '11', '+'];
        '12': ['11', '13', '12', 12, '-12', RawMap['11'][5] | '12', '+'];
        '13': ['12', '14', '13', 13, '-13', RawMap['12'][5] | '13', '+'];
        '14': ['13', '15', '14', 14, '-14', RawMap['13'][5] | '14', '+'];
        '15': ['14', '16', '15', 15, '-15', RawMap['14'][5] | '15', '+'];
        '16': ['15', '17', '16', 16, '-16', RawMap['15'][5] | '16', '+'];
        '17': ['16', '18', '17', 17, '-17', RawMap['16'][5] | '17', '+'];
        '18': ['17', '19', '18', 18, '-18', RawMap['17'][5] | '18', '+'];
        '19': ['18', '20', '19', 19, '-19', RawMap['18'][5] | '19', '+'];
        '20': ['19', '21', '20', 20, '-20', RawMap['19'][5] | '20', '+'];
        '21': ['20', '22', '21', 21, '-21', RawMap['20'][5] | '21', '+'];
        '22': ['21', '23', '22', 22, '-22', RawMap['21'][5] | '22', '+'];
        '23': ['22', '24', '23', 23, '-23', RawMap['22'][5] | '23', '+'];
        '24': ['23', '25', '24', 24, '-24', RawMap['23'][5] | '24', '+'];
        '25': ['24', '26', '25', 25, '-25', RawMap['24'][5] | '25', '+'];
        '26': ['25', '27', '26', 26, '-26', RawMap['25'][5] | '26', '+'];
        '27': ['26', '28', '27', 27, '-27', RawMap['26'][5] | '27', '+'];
        '28': ['27', '29', '28', 28, '-28', RawMap['27'][5] | '28', '+'];
        '29': ['28', '30', '29', 29, '-29', RawMap['28'][5] | '29', '+'];
        '30': ['29', '31', '30', 30, '-30', RawMap['29'][5] | '30', '+'];
        '31': ['30', '32', '31', 31, '-31', RawMap['30'][5] | '31', '+'];
        '32': ['31', '33', '32', 32, '-32', RawMap['31'][5] | '32', '+'];
        '33': ['32', '34', '33', 33, '-33', RawMap['32'][5] | '33', '+'];
        '34': ['33', '35', '34', 34, '-34', RawMap['33'][5] | '34', '+'];
        '35': ['34', '36', '35', 35, '-35', RawMap['34'][5] | '35', '+'];
        '36': ['35', '37', '36', 36, '-36', RawMap['35'][5] | '36', '+'];
        '37': ['36', '38', '37', 37, '-37', RawMap['36'][5] | '37', '+'];
        '38': ['37', '39', '38', 38, '-38', RawMap['37'][5] | '38', '+'];
        '39': ['38', '40', '39', 39, '-39', RawMap['38'][5] | '39', '+'];
        '40': ['39', '41', '40', 40, '-40', RawMap['39'][5] | '40', '+'];
        '41': ['40', '42', '41', 41, '-41', RawMap['40'][5] | '41', '+'];
        '42': ['41', '43', '42', 42, '-42', RawMap['41'][5] | '42', '+'];
        '43': ['42', '44', '43', 43, '-43', RawMap['42'][5] | '43', '+'];
        '44': ['43', '45', '44', 44, '-44', RawMap['43'][5] | '44', '+'];
        '45': ['44', '46', '45', 45, '-45', RawMap['44'][5] | '45', '+'];
        '46': ['45', '47', '46', 46, '-46', RawMap['45'][5] | '46', '+'];
        '47': ['46', '48', '47', 47, '-47', RawMap['46'][5] | '47', '+'];
        '48': ['47', '49', '48', 48, '-48', RawMap['47'][5] | '48', '+'];
        '49': ['48', '50', '49', 49, '-49', RawMap['48'][5] | '49', '+'];
        '50': ['49', '51', '50', 50, '-50', RawMap['49'][5] | '50', '+'];
        '51': ['50', '52', '51', 51, '-51', RawMap['50'][5] | '51', '+'];
        '52': ['51', '53', '52', 52, '-52', RawMap['51'][5] | '52', '+'];
        '53': ['52', '54', '53', 53, '-53', RawMap['52'][5] | '53', '+'];
        '54': ['53', '55', '54', 54, '-54', RawMap['53'][5] | '54', '+'];
        '55': ['54', '56', '55', 55, '-55', RawMap['54'][5] | '55', '+'];
        '56': ['55', '57', '56', 56, '-56', RawMap['55'][5] | '56', '+'];
        '57': ['56', '58', '57', 57, '-57', RawMap['56'][5] | '57', '+'];
        '58': ['57', '59', '58', 58, '-58', RawMap['57'][5] | '58', '+'];
        '59': ['58', '60', '59', 59, '-59', RawMap['58'][5] | '59', '+'];
        '60': ['59', '61', '60', 60, '-60', RawMap['59'][5] | '60', '+'];
        '61': ['60', '62', '61', 61, '-61', RawMap['60'][5] | '61', '+'];
        '62': ['61', '63', '62', 62, '-62', RawMap['61'][5] | '62', '+'];
        '63': ['62', '64', '63', 63, '-63', RawMap['62'][5] | '63', '+'];
        '64': ['63', '65', '64', 64, '-64', RawMap['63'][5] | '64', '+'];
        '65': ['64', '66', '65', 65, '-65', RawMap['64'][5] | '65', '+'];
        '66': ['65', '67', '66', 66, '-66', RawMap['65'][5] | '66', '+'];
        '67': ['66', '68', '67', 67, '-67', RawMap['66'][5] | '67', '+'];
        '68': ['67', '69', '68', 68, '-68', RawMap['67'][5] | '68', '+'];
        '69': ['68', '70', '69', 69, '-69', RawMap['68'][5] | '69', '+'];
        '70': ['69', '71', '70', 70, '-70', RawMap['69'][5] | '70', '+'];
        '71': ['70', '72', '71', 71, '-71', RawMap['70'][5] | '71', '+'];
        '72': ['71', '73', '72', 72, '-72', RawMap['71'][5] | '72', '+'];
        '73': ['72', '74', '73', 73, '-73', RawMap['72'][5] | '73', '+'];
        '74': ['73', '75', '74', 74, '-74', RawMap['73'][5] | '74', '+'];
        '75': ['74', '76', '75', 75, '-75', RawMap['74'][5] | '75', '+'];
        '76': ['75', '77', '76', 76, '-76', RawMap['75'][5] | '76', '+'];
        '77': ['76', '78', '77', 77, '-77', RawMap['76'][5] | '77', '+'];
        '78': ['77', '79', '78', 78, '-78', RawMap['77'][5] | '78', '+'];
        '79': ['78', '80', '79', 79, '-79', RawMap['78'][5] | '79', '+'];
        '80': ['79', '81', '80', 80, '-80', RawMap['79'][5] | '80', '+'];
        '81': ['80', '82', '81', 81, '-81', RawMap['80'][5] | '81', '+'];
        '82': ['81', '83', '82', 82, '-82', RawMap['81'][5] | '82', '+'];
        '83': ['82', '84', '83', 83, '-83', RawMap['82'][5] | '83', '+'];
        '84': ['83', '85', '84', 84, '-84', RawMap['83'][5] | '84', '+'];
        '85': ['84', '86', '85', 85, '-85', RawMap['84'][5] | '85', '+'];
        '86': ['85', '87', '86', 86, '-86', RawMap['85'][5] | '86', '+'];
        '87': ['86', '88', '87', 87, '-87', RawMap['86'][5] | '87', '+'];
        '88': ['87', '89', '88', 88, '-88', RawMap['87'][5] | '88', '+'];
        '89': ['88', '90', '89', 89, '-89', RawMap['88'][5] | '89', '+'];
        '90': ['89', '91', '90', 90, '-90', RawMap['89'][5] | '90', '+'];
        '91': ['90', '92', '91', 91, '-91', RawMap['90'][5] | '91', '+'];
        '92': ['91', '93', '92', 92, '-92', RawMap['91'][5] | '92', '+'];
        '93': ['92', '94', '93', 93, '-93', RawMap['92'][5] | '93', '+'];
        '94': ['93', '95', '94', 94, '-94', RawMap['93'][5] | '94', '+'];
        '95': ['94', '96', '95', 95, '-95', RawMap['94'][5] | '95', '+'];
        '96': ['95', '97', '96', 96, '-96', RawMap['95'][5] | '96', '+'];
        '97': ['96', '98', '97', 97, '-97', RawMap['96'][5] | '97', '+'];
        '98': ['97', '99', '98', 98, '-98', RawMap['97'][5] | '98', '+'];
        '99': ['98', '100', '99', 99, '-99', RawMap['98'][5] | '99', '+'];
        '100': ['99', '__', '100', 100, '-100', RawMap['99'][5] | '100', '+'];
    };
    /**
     * @hidden
     */
    type MapKeys = {
        '-': '-100' | '-99' | '-98' | '-97' | '-96' | '-95' | '-94' | '-93' | '-92' | '-91' | '-90' | '-89' | '-88' | '-87' | '-86' | '-85' | '-84' | '-83' | '-82' | '-81' | '-80' | '-79' | '-78' | '-77' | '-76' | '-75' | '-74' | '-73' | '-72' | '-71' | '-70' | '-69' | '-68' | '-67' | '-66' | '-65' | '-64' | '-63' | '-62' | '-61' | '-60' | '-59' | '-58' | '-57' | '-56' | '-55' | '-54' | '-53' | '-52' | '-51' | '-50' | '-49' | '-48' | '-47' | '-46' | '-45' | '-44' | '-43' | '-42' | '-41' | '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1';
        '0': '0';
        '+': '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40' | '41' | '42' | '43' | '44' | '45' | '46' | '47' | '48' | '49' | '50' | '51' | '52' | '53' | '54' | '55' | '56' | '57' | '58' | '59' | '60' | '61' | '62' | '63' | '64' | '65' | '66' | '67' | '68' | '69' | '70' | '71' | '72' | '73' | '74' | '75' | '76' | '77' | '78' | '79' | '80' | '81' | '82' | '83' | '84' | '85' | '86' | '87' | '88' | '89' | '90' | '91' | '92' | '93' | '94' | '95' | '96' | '97' | '98' | '99' | '100';
    };
    /**
    Describes a map of number relationships
    */
    export type NumberMap = CreateMap<MapKeys, RawMap>;
}
declare module "Iteration/Next" {
    import { Map } from "Iteration/Map";
    import { Iteration } from "Iteration/Iteration";
    import { NumberMap } from "Iteration/Maps/Number";
    /**
    Move **`I`**'s position forward
    @param I to move
    @param IMap to operate with another set of numbers
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Next<i>> // 21
    ```
    */
    export type Next<I extends Iteration, IMap extends Map = NumberMap> = IMap[1][I[1]];
}
declare module "List/List" {
    /**
    A [[List]]
    @param A its type
    @returns [[List]]
    @example
    ```ts
    type list0 = [1, 2, 3]
    type list1 = number[]
    ```
    */
    export type List<A = any> = ReadonlyArray<A>;
}
declare module "List/Prepend" {
    import { List } from "List/List";
    /**
    Add an element **`A`** at the beginning of **`L`**
    @param L to append to
    @param A to be added to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Prepend<L extends List, A extends any> = ((head: A, ...args: L) => any) extends ((...args: infer U) => any) ? U : L;
}
declare module "Number/Number" {
    /**
    A [[Number]]
    @example
    ```ts
    type number0 = '-42`
    type number1 = '420'
    ```
    */
    export type Number = string;
}
declare module "Iteration/IterationOf" {
    import { Number } from "Number/Number";
    import { NumberMap } from "Iteration/Maps/Number";
    import { Map } from "Iteration/Map";
    /**
    Transform a number into an [[Iteration]]
    (to use [[Prev]], [[Next]], & [[Pos]])
    @param N to transform
    @param IMap to operate with another set of numbers
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'0'> // ["-1", "1", "0", 0, "0"]
    
    type next = I.Next<i>       // ["0", "2", "1", 1, "+"]
    type prev = I.Prev<i>       // ["-2", "0", "-1", -1, "-"]
    
    type nnext = I.Pos<next>    // +1
    type nprev = I.Pos<prev>    // -1
    ```
    */
    export type IterationOf<N extends Number, IMap extends Map = NumberMap> = N extends keyof IMap[1] ? IMap[1][N] : IMap[1]['__'];
}
declare module "Any/Cast" {
    /**
     * Ask TS to re-check that **`A1`** extends **`A2`**.
     * And if it fails, **`A2`** will be enforced anyway.
     * Can also be used to add constraints on parameters.
     * @param A1 to check against
     * @param A2 to cast **`A1`** to
     * @returns **`A1`** or **`A2`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Cast<'42', string> // '42'
     * type test1 = A.Cast<'42', number> // number
     * ```
     */
    export type Cast<A1 extends any, A2 extends any> = A1 extends A2 ? A1 : A2;
}
declare module "Iteration/_Internal" {
    /**
    Describes compatible type formats
    * `s`: **`string`**
    * `n`: **`number`**
    */
    export type Formats = 'n' | 's';
    /**
    Describes how to perform iterations
    */
    export type Way = '->' | '<-';
}
declare module "Iteration/Format" {
    import { Iteration } from "Iteration/Iteration";
    import { Formats } from "Iteration/_Internal";
    /**
    Is [[Key]] and [[Pos]] in a single type
    @param I to query
    @param fmt output format
    @returns **`string | number`**
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    /// Let's make '20' an iteration
    type i = I.IterationOf<'20'> // [...]
    
    type fmtS = I.Fmt<i, 's'> // '20'
    type fmtN = I.Fmt<i, 'n'> //  20
    ```
    */
    export type Format<I extends Iteration, fmt extends Formats> = {
        's': I[2];
        'n': I[3];
    }[fmt];
}
declare module "Iteration/Key" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /**
    Get the position of **`I`** (**string**)
    @param I to query
    @returns [[String]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Key<i>         // '20'
    type test1 = I.Key<I.Next<i>> // '21'
    ```
    */
    export type Key<I extends Iteration> = Format<I, 's'>;
}
declare module "Any/Extends" {
    /**
     * Check whether **`A1`** is part of **`A2`** or not. The difference with
     * `extends` is that it forces a [[Boolean]] return.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Extends<'a' | 'b', 'b'> // Boolean
     * type test1 = A.Extends<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Extends<{a: string}, {a: any}>      // True
     * type test3 = A.Extends<{a: any}, {a: any, b: any}> // False
     *
     * type test4 = A.Extends<never, never> // False
     * /// Nothing cannot extend nothing, use `A.Equals`
     * ```
     */
    export type Extends<A1 extends any, A2 extends any> = [
        A1
    ] extends [never] ? 0 : A1 extends A2 ? 1 : 0;
}
declare module "List/Repeat" {
    import { Next } from "Iteration/Next";
    import { Prepend } from "List/Prepend";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Repeat<N extends Number, A, L extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: __Repeat<N, A, Prepend<L, A>, Next<I>>;
        1: L;
    }[Extends<Key<I>, N>];
    /**
    @hidden
    */
    export type _Repeat<A extends any, N extends Number, L extends List = []> = __Repeat<N, A, L> extends infer X ? Cast<X, List> : never;
    /**
    Fill a [[List]] with **`N`** times **`A`**
    @param A to fill with
    @param N to repeat it
    @param L (?=`[]`) to be filled
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Repeat<A extends any, N extends Number, L extends List = []> = N extends unknown ? L extends unknown ? _Repeat<A, N, L> : never : never;
}
declare module "Any/Equals" {
    /**
     * Check whether **`A1`** is equal to **`A2`** or not.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Equals<42 | 0, 42 | 0>                    // true
     * type test1 = A.Equals<{a: string}, {b: string}>          // false
     * type test3 = A.Equals<{a: string}, {readonly a: string}> // false
     * ```
     */
    export type Equals<A1 extends any, A2 extends any> = (<A>() => A extends A2 ? 1 : 0) extends (<A>() => A extends A1 ? 1 : 0) ? 1 : 0;
}
declare module "Object/_Internal" {
    /**
    Describes the permissions/modifiers fields can have
    * `R`: readonly
    * `W`: writable
    * `!`: required
    * `?`: optional
    */
    export type Modx = ['?' | '!', 'W' | 'R'];
    /**
    Describes the depth strategy when modifying types
    */
    export type Depth = 'flat' | 'deep';
    /**
     * Describes the merging strategy
     * `0`: lodash style. Preserves lists, and completes when undefined types
     * `1`: ramda style. Destroys lists, does not complete if undefined types
     * `2`: lodash style. Lists are narrowed down, tuples are not preserved
     * `3`: ramda style. Assumes that we are only working with lists
     */
    export type MergeStyle = 0 | 1 | 2;
    /**
    Make an object properties (all) `never`. We use this to intersect `object`s and
    preserve the combine modifiers like `+readonly` and `?optional`.
     */
    export type Anyfy<O extends object> = {
        [K in keyof O]: any;
    } & {};
}
declare module "Misc/BuiltInObject" {
    /**
     * @hidden
     */
    type Errors = Error;
    /**
     * @hidden
     */
    type Numeric = Date;
    /**
     * @hidden
     */
    type Textual = RegExp;
    /**
     * @hidden
     */
    type Arrays = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
    /**
     * @hidden
     */
    type Maps = ReadonlyMap<unknown, unknown> | ReadonlySet<unknown> | WeakMap<object, unknown> | WeakSet<object>;
    /**
     * @hidden
     */
    type Structures = ArrayBuffer | DataView;
    /**
     * @hidden
     */
    type Abstractions = Function | Promise<unknown> | Generator;
    /**
     * @hidden
     */
    type WebAssembly = never;
    /**
     * Built-in standard library objects
     */
    export type BuiltInObject = Errors | Numeric | Textual | Arrays | Maps | Structures | Abstractions | WebAssembly;
}
declare module "Any/Compute" {
    import { Depth } from "Object/_Internal";
    import { BuiltInObject } from "Misc/BuiltInObject";
    /**
     * @hidden
     */
    export type ComputeRaw<A extends any> = A extends Function ? A : {
        [K in keyof A]: A[K];
    } & {};
    /**
     * @hidden
     */
    export type ComputeFlat<A extends any> = A extends BuiltInObject ? A : {
        [K in keyof A]: A[K];
    } & {};
    /**
     * @hidden
     */
    export type ComputeDeep<A extends any, Seen extends any = A> = A extends BuiltInObject ? A : {
        [K in keyof A]: A[K] extends Seen ? A[K] : ComputeDeep<A[K], A[K] | Seen>;
    } & {};
    /**
     * Force TS to load a type that has not been computed (to resolve composed
     * types that TS haven't fully resolved, for display purposes mostly).
     * @param A to compute
     * @returns **`A`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Compute<{x: 'x'} & {y: 'y'}> // {x: 'x', y: 'y'}
     * ```
     */
    export type Compute<A extends any, depth extends Depth = 'deep'> = {
        'flat': ComputeFlat<A>;
        'deep': ComputeDeep<A>;
    }[depth];
}
declare module "Boolean/Boolean" {
    /**
    A [[Boolean]]
    */
    export type Boolean = True | False;
    /**
    1
    */
    export type True = 1;
    /**
    0
    */
    export type False = 0;
}
declare module "Test" {
    import { Repeat } from "List/Repeat";
    import { Equals } from "Any/Equals";
    import { ComputeRaw } from "Any/Compute";
    import { True, False, Boolean } from "Boolean/Boolean";
    /**
    Test should pass
    */
    export type Pass = True;
    /**
    Test should fail
    */
    export type Fail = False;
    /**
    Check or test the validity of a type
    @param debug to debug with parameter hints (`ctrl+p`, `ctrl+shift+space`)
    @example
    ```ts
    // see in `tst` folder
    ```
    */
    export function check<Type, Expect, Outcome extends Boolean>(debug?: ComputeRaw<Type>): Equals<Equals<Type, Expect>, Outcome>;
    /**
    Validates a batch of [[check]]
    @param checks a batch of [[check]]
    @example
    ```ts
    // see in `tst` folder
    ```
    */
    export function checks(checks: Partial<Repeat<Pass, '30'>>): void;
}
declare module "Any/Key" {
    /**
     * Describes index keys for any type
     */
    export type Key = string | number | symbol;
}
declare module "Object/Pick" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    type __Pick<O extends object, K extends keyof O> = {
        [P in K]: O[P];
    } & {};
    /**
    @hidden
    */
    export type _Pick<O extends object, K extends Key> = __Pick<O, keyof O & K>;
    /**
    Extract out of **`O`** the fields of key **`K`**
    @param O to extract from
    @param K to chose fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Pick<O extends object, K extends Key> = O extends unknown ? _Pick<O, K> : never;
}
declare module "Union/Union" {
    /**
    A [[Union]]
    @example
    ```ts
    type union0 = 1 | 2 | 3
    type union1 = 'a' | 420
    ```
    */
    export type Union = any;
}
declare module "Union/Exclude" {
    import { Union } from "Union/Union";
    /**
    Remove **`M`** out of **`U`**
    @param U to remove from
    @param M to remove out
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Exclude<U extends Union, M extends Union> = U extends M ? never : U;
}
declare module "Object/Omit" {
    import { _Pick } from "Object/Pick";
    import { Exclude } from "Union/Exclude";
    import { Key } from "Any/Key";
    /**
     * @hidden
     */
    export type _Omit<O extends object, K extends Key> = _Pick<O, Exclude<keyof O, K>>;
    /**
    Remove out of **`O`** the fields of key **`K`**
    @param O to remove from
    @param K to chose fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Omit<O extends object, K extends Key> = O extends unknown ? _Omit<O, K> : never;
}
declare module "Object/At" {
    import { Key } from "Any/Key";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    export type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
    /**
    @hidden
    */
    export type AtStrict<O extends object, K extends Key> = O[K & keyof O];
    /**
    @hidden
    */
    export type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
    /**
    Get in **`O`** the type of a field of key **`K`**
    @param O to extract from
    @param K to extract at
    @param strict (?=`1`) `0` to work with unions
    @returns **`any`**
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    type User = {
        info: {
            name: string
            age: number
            payment: {}
        }
        id: number
    }
    
    type test0 = O.At<User, 'id'> // number
    ```
    */
    export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
        1: AtStrict<O, K>;
        0: AtLoose<O, K>;
    }[strict];
}
declare module "Number/_Internal" {
    import { Format } from "Iteration/Format";
    import { Map } from "Iteration/Map";
    import { NumberMap } from "Iteration/Maps/Number";
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `n`: **`number`**
    * `s`: **`string`**
    */
    export type Formats = 'b' | 'n' | 's';
    /**
     * @hidden
     */
    export type KnownIterationMapKeys<IMap extends Map> = IMap[0]['-' | '0' | '+'];
    /**
     * @hidden
     */
    export type NegativeIterationKeys<IMap extends Map> = IMap[0]['-'];
    /**
     * @hidden
     */
    export type PositiveIterationKeys<IMap extends Map> = IMap[0]['+'];
    /**
     * @hidden
     */
    export type NeutralIterationKeys<IMap extends Map> = IMap[0]['0'];
    /**
    Describes known values of a **number**
    @hidden
    */
    export type Numbers<IMap extends Map = NumberMap> = {
        'string': {
            'all': Format<IMap[1][KnownIterationMapKeys<IMap>], 's'>;
            '+': Format<IMap[1][PositiveIterationKeys<IMap>], 's'>;
            '-': Format<IMap[1][NegativeIterationKeys<IMap>], 's'>;
            '0': Format<IMap[1][NeutralIterationKeys<IMap>], 's'>;
        };
        'number': {
            'all': Format<IMap[1][KnownIterationMapKeys<IMap>], 'n'>;
            '+': Format<IMap[1][PositiveIterationKeys<IMap>], 'n'>;
            '-': Format<IMap[1][NegativeIterationKeys<IMap>], 'n'>;
            '0': Format<IMap[1][NeutralIterationKeys<IMap>], 'n'>;
        };
    };
}
declare module "Iteration/Pos" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /**
    Get the position of **`I`** (**number**)
    @param I to query
    @param IMap to operate with another set of numbers
    @returns **`number`**
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Next<i>> // 21
    ```
    */
    export type Pos<I extends Iteration> = Format<I, 'n'>;
}
declare module "Number/NumberOf" {
    import { Key } from "Iteration/Key";
    import { Pos } from "Iteration/Pos";
    import { Numbers, KnownIterationMapKeys } from "Number/_Internal";
    import { NumberMap } from "Iteration/Maps/Number";
    import { Map } from "Iteration/Map";
    /**
    @hidden
    */
    export type _NumberOf<N extends number, IMap extends Map> = {
        [K in keyof IMap[1]]: Pos<IMap[1][K]> extends N ? Key<IMap[1][K]> : never;
    }[KnownIterationMapKeys<IMap>];
    /**
    Transform a **`number`** into a [[Number]]
    @param N to stringify
    @param IMap to operate with another set of numbers
    @returns [[String]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.StringOf<5>  //  '5'
    type test1 = N.StringOf<-5> // '-5'
    ```
    */
    export type NumberOf<N extends number, IMap extends Map = NumberMap> = N extends Numbers<IMap>['number']['all'] ? _NumberOf<N, IMap> : string;
}
declare module "List/Length" {
    import { NumberOf } from "Number/NumberOf";
    import { Formats } from "Iteration/_Internal";
    import { List } from "List/List";
    /**
    Get the length of **`L`**
    @param L to get length
    @param fmt (?=`'n'`) output format
    @returns [[String]] or **`number`**
    @example
    ```ts
    ```
    */
    export type Length<L extends List, fmt extends Formats = 'n'> = {
        's': NumberOf<L['length']>;
        'n': L['length'];
    }[fmt];
}
declare module "Object/Overwrite" {
    /**
    Update the fields of **`O`** with the ones of **`O1`**
    (only the existing fields will be updated)
    @param O to update
    @param O1 to update with
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Overwrite<O extends object, O1 extends object> = {
        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
    } & {};
}
declare module "List/_Internal" {
    /** @ignore */ /** */
    import { Overwrite } from "Object/Overwrite";
    import { List } from "List/List";
    /**
    Remove `?` & `readonly` from a [[List]]
     */
    export type Naked<L extends List> = Overwrite<Required<L>, L>;
}
declare module "List/Reverse" {
    import { Prepend } from "List/Prepend";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Reverse<L extends List, LO extends List, I extends Iteration = IterationOf<'0'>> = {
        0: __Reverse<L, Prepend<LO, L[Pos<I>]>, Next<I>>;
        1: LO;
    }[Extends<Pos<I>, Length<L>>];
    /**
    @hidden
    */
    export type _Reverse<L extends List, LO extends List = []> = __Reverse<Naked<L>, LO> extends infer X ? Cast<X, List> : never;
    /**
    Turn a [[List]] the other way around
    @param L to reverse
    @param LO (?=`[]`) to prepend to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Reverse<L extends List, LO extends List = []> = L extends unknown ? LO extends unknown ? _Reverse<L, LO> : never : never;
}
declare module "List/Concat" {
    import { _Reverse } from "List/Reverse";
    import { List } from "List/List";
    /**
    @hidden
    */
    export type _Concat<L extends List, L1 extends List> = _Reverse<_Reverse<L>, L1>;
    /**
    Attach **`L1`** at the end of **`L`**
    @param L to concat with
    @param L1 to be attached
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Concat<L extends List, L1 extends List> = L extends unknown ? L1 extends unknown ? _Concat<L, L1> : never : never;
}
declare module "List/Append" {
    import { _Concat } from "List/Concat";
    import { List } from "List/List";
    /**
    @hidden
    */
    export type _Append<L extends List, A extends any> = _Concat<L, [A]>;
    /**
    Add an element **`A`** at the end of **`L`**
    @param L to append to
    @param A to be added to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Append<L extends List, A extends any> = L extends unknown ? A extends unknown ? _Append<L, A> : never : never;
}
declare module "Object/ListOf" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Key } from "Iteration/Key";
    import { Next } from "Iteration/Next";
    import { _Append } from "List/Append";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    import { At } from "Object/At";
    /**
    @hidden
    */
    type PickIfEntry<O extends object, LN extends List, I extends Iteration> = Key<I> extends keyof O ? _Append<LN, O[Key<I> & keyof O]> : LN;
    /**
    @hidden
    */
    type ___ListOf<O extends object, K, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: ___ListOf<O, Exclude<K, Key<I>>, PickIfEntry<O, LN, I>, Next<I>>;
        1: LN;
    }[Extends<[K], [never]>];
    /**
    @hidden
    */
    type __ListOf<O extends object> = number extends keyof O ? At<O, number>[] : string extends keyof O ? At<O, string>[] : symbol extends keyof O ? At<O, symbol>[] : ___ListOf<O, keyof O>;
    /**
    @hidden
    */
    export type _ListOf<O extends object> = __ListOf<O>;
    /**
    Transform an [[Object]] into a [[List]]
    (It will only pick numeric literal indexes)
    @param O to transform
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type ListOf<O extends object> = O extends unknown ? _ListOf<O> : never;
}
declare module "Boolean/Not" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`!`** operator (behaves like the JS one)
    @param B to negate
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Not<B.True>  // False
    type test1 = B.Not<B.False> // True
    ```
    */
    export type Not<B extends Boolean> = {
        0: 1;
        1: 0;
    }[B];
}
declare module "Union/Has" {
    import { Union } from "Union/Union";
    import { Not } from "Boolean/Not";
    import { Extends } from "Any/Extends";
    /**
    Check whether **`U`** contains **`U1`**
    @param U to be inspected
    @param U1 to check within
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;
}
declare module "Any/Clean" {
    import { _Omit } from "Object/Omit";
    import { _Pick } from "Object/Pick";
    import { At } from "Object/At";
    import { Exclude } from "Union/Exclude";
    import { Numbers } from "Number/_Internal";
    import { _ListOf } from "Object/ListOf";
    import { Has } from "Union/Has";
    /**
     * @hidden
     */
    type ArrayEntry = Numbers['string']['0' | '+'];
    /**
     * @hidden
     */
    type ArrayProps = keyof any[] | ArrayEntry;
    /**
     * Sometimes, we can end up with mixed up **`objects`** that do not make sense
     * visually (or that could at least be simplified for the end user). This will
     * turn anything that is passed to it into a cleaned up [[Object]].
     *
     * @param O
     * @returns [[Object]]
     * @example
     * ```ts
     * ```
     */
    export type Clean<A extends any> = A extends object ? Has<keyof A, keyof any[]> extends 1 ? [Exclude<keyof A, ArrayProps>] extends [never] ? number extends At<A, 'length'> ? At<A, number>[] : A : number extends At<A, 'length'> ? _Omit<A, ArrayProps> & At<A, number>[] : At<A, 'length'> extends number ? _Omit<A, ArrayProps> & _ListOf<_Pick<A, ArrayEntry>> : A : A : A;
}
declare module "Any/Contains" {
    import { Extends } from "Any/Extends";
    /**
     * Check whether **`A1`** is part of **`A2`** or not. It works like
     * [[Extends]] but [[Boolean]] results are narrowed to [[False]].
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * type test0 = A.Contains<'a' | 'b', 'b'> // False
     * type test1 = A.Contains<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Contains<{a: string}, {a: string, b: number}> // False
     * type test3 = A.Contains<{a: string, b: number}, {a: string}> // True
     *
     * type test4 = A.Contains<never, never> // False
     * /// Nothing cannot contain nothing, use `A.Equals`
     * ```
     */
    export type Contains<A1 extends any, A2 extends any> = Extends<A1, A2> extends 1 ? 1 : 0;
}
declare module "Any/_Internal" {
    import { _NumberOf } from "Number/NumberOf";
    import { NumberMap } from "Iteration/Maps/Number";
    /**
     * Describes the match strategy when matching types
     * * `default`     : `extends->`
     * * `contains->`  : X contains   Y ([[Contains]]<X, Y>)
     * * `extends->`   : X extends    Y ([[Extends]]<X, Y>)
     * * `implements->`: X implements Y ([[Implements]]<X, Y>)
     * * `<-contains`  : Y contains   X ([[Contains]]<Y, X>)
     * * `<-extends`   : Y extends    X ([[Extends]]<Y, X>)
     * * `<-implements`: Y implements X ([[Implements]]<Y, X>)
     * * `equals`      : X equals     Y (([[Equals]]<X, Y>))
     */
    export type Match = 'default' | 'contains->' | 'extends->' | 'implements->' | '<-contains' | '<-extends' | '<-implements' | 'equals';
    /**
     * @hidden
     */
    export type NumberOf<N extends any> = N extends number ? _NumberOf<N, NumberMap> : N;
    /**
     * @hidden
     */
    export type _Promise<A extends any> = Promise<A>;
}
declare module "Any/Is" {
    import { Match } from "Any/_Internal";
    import { Extends } from "Any/Extends";
    import { Equals } from "Any/Equals";
    import { Contains } from "Any/Contains";
    /**
     * Check whether **`A`** is similar to **`A1`** or not. In other words, it is a
     * compact type that bundles [[Equals]], [[Extends]], [[Contains]], and
     * [[Implements]] comparison types.
     * @param A to be compared
     * @param A1 to compare to
     * @param match (?=`'default'`) to change precision
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Is<'a', 'a' | 'b', 'extends->'> // True
     * type test1 = A.Is<'a' | 'b', 'a', 'extends->'> // Boolean
     *
     * type test2 = A.Is<'a', 'a' | 'b', '<-extends'> // Boolean
     * type test3 = A.Is<'a' | 'b', 'a', '<-extends'> // True
     *
     * type test4 = A.Is<'a', 'a' | 'b', 'implements->'> // True
     * type test5 = A.Is<'a' | 'b', 'a', 'implements->'> // False
     *
     * type test6 = A.Is<'a', 'a' | 'b', '<-implements'> // False
     * type test7 = A.Is<'a' | 'b', 'a', '<-implements'> // True
     *
     * type test8 = A.Is<'a', 'a' | 'b', 'equals'>      // False
     * type test9 = A.Is<'b' |'a', 'a' | 'b', 'equals'> // True
     * ```
     */
    export type Is<A extends any, A1 extends any, match extends Match = 'default'> = {
        'default': Extends<A, A1>;
        'contains->': Contains<A, A1>;
        'extends->': Extends<A, A1>;
        'implements->': Contains<A, A1>;
        '<-contains': Contains<A1, A>;
        '<-extends': Extends<A1, A>;
        '<-implements': Contains<A1, A>;
        'equals': Equals<A1, A>;
    }[match];
}
declare module "Boolean/And" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`&&`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.And<B.True, B.False>          // False
    type test1 = B.And<B.True, B.True>           // True
    type test2 = B.And<B.True | B.False, B.True> // Boolean
    ```
    */
    export type And<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 0;
        };
        1: {
            0: 0;
            1: 1;
        };
    }[B1][B2];
}
declare module "Boolean/Or" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`||`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Or<B.True, B.False>    // True
    type test1 = B.Or<B.True, B.True>     // True
    type test2 = B.Or<B.Boolean, B.False> // Boolean
    ```
    */
    export type Or<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 1;
        };
        1: {
            0: 1;
            1: 1;
        };
    }[B1][B2];
}
declare module "Any/IsLiteral" {
    import { And } from "Boolean/And";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    /**
     * @hidden
     */
    export type IsStringLiteral<A extends any> = A extends string ? string extends A ? 0 : 1 : 0;
    /**
     * @hidden
     */
    export type IsNumberLiteral<A extends any> = A extends number ? number extends A ? 0 : 1 : 0;
    /**
     * Literal to restrict against
     */
    export type Kind = string | number;
    /**
     * Determine whether **`A`** is literal or not
     * @param A to be checked
     * @param kind (?=`'string' | 'number'`) to restrict
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.IsLiteral<1 | 2> // 1
     * type test1 = A.IsLiteral<1 | 2, string> // 0
     * type test2 = A.IsLiteral<1 | '2', string> // 0 | 1
     * type test3 = A.IsLiteral<number> // 0
     * ```
     */
    export type IsLiteral<A extends any, kind extends Kind = Kind> = And<Or<IsStringLiteral<A>, IsNumberLiteral<A>>, Extends<A, kind>>;
}
declare module "Any/Kind" {
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Kind<A extends any> = Extends<A, Function> extends 1 ? 'function' : Extends<A, List> extends 1 ? 'array' : Extends<A, object> extends 1 ? 'object' : Extends<A, string> extends 1 ? 'string' : Extends<A, number> extends 1 ? 'number' : Extends<A, boolean> extends 1 ? 'boolean' : 'unknown';
    /**
     * Get the literal kind of a type
     * @param A
     * @returns **`'string' | 'number' | 'function' | 'array' | 'object' | 'boolean' | 'unknown'`**
     * @example
     * ```ts
     * ```
     */
    export type Kind<A extends any> = A extends unknown ? _Kind<A> : never;
}
declare module "Any/Promise" {
    /**
     * Create an asynchronous operation like the original `Promise` type but this
     * one prevents promises to be wrapped within more promises (not possible).
     * @param A
     */
    export type Promise<A extends any> = globalThis.Promise<A extends globalThis.Promise<infer X> ? X : A>;
}
declare module "Any/Promisable" {
    import { Promise } from "Any/Promise";
    /**
     * A way to say that you can handle **`Promises`** and non-**`Promises`**. This
     * is often the case if you're a heavy user of `await` and `async`.
     * @param A **`A`** A type
     * @returns **`A | Promise<A>`**
     * @example
     */
    export type Promisable<A extends any> = A | Promise<A>;
}
declare module "Any/PromiseOf" {
    /**
    Get the instance type wrapped within a **`Promise`**
    @param P **`Promise`**
    @returns **`any`**
    @example
    ```ts
    import {C} from 'ts-toolbelt'
    
    const promise = new Promise<string>((res, rej) => res('x'))
    
    type test0 = C.PromiseOf<typeof promise>  // string
    type test1 = C.PromiseOf<Promise<number>> // number
    ```
    */
    export type PromiseOf<P extends any> = P extends Promise<infer A> ? A : P;
}
declare module "Any/Try" {
    /**
     * Similar to [[Cast]] but with a custom fallback **`Catch`**. If it fails,
     * it will enforce **`Catch`** instead of **`A2`**.
     * @param A1 to check against
     * @param A2 to try **`A1`** with
     * @param Catch to fallback (fail)
     * @returns **`A1`** or **`Catch`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Try<'42', string>          // '42'
     * type test1 = A.Try<'42', number>          // never
     * type test1 = A.Try<'42', number, 'tried'> // 'tried'
     * ```
     */
    export type Try<A1 extends any, A2 extends any, Catch = never> = A1 extends A2 ? A1 : Catch;
}
declare module "Any/Type" {
    import { Key } from "Any/Key";
    /**
     * Create your own opaque sub-type from a type **`A`**
     * @param A to be personalized
     * @param Id to name the sub-type
     * @returns A new type **`Type<A, Id>`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type EUR = Type<number, 'eur'>
     * type USD = Type<number, 'usd'>
     *
     * let eurWallet = 10 as EUR
     * let usdWallet = 15 as USD
     *
     * eurWallet = usdWallet // error
     * ```
     */
    export type Type<A extends any, Id extends Key> = A & {
        __type__: Id;
    };
}
declare module "Any/x" {
    import { Type } from "Any/Type";
    /**
     * A placeholder that is used in various ways
     */
    export type x = Type<{}, 'x'>;
}
declare module "List/ObjectOf" {
    import { _Omit } from "Object/Omit";
    import { _Pick } from "Object/Pick";
    import { List } from "List/List";
    /**
    Transform a [[List]] into an [[Object]] equivalent
    @param L to transform
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type ObjectOf<O extends object> = O extends List ? number extends O['length'] ? _Pick<O, number> : _Omit<O, keyof any[]> : O;
}
declare module "List/Omit" {
    import { _Omit as _OOmit } from "Object/Omit";
    import { _ListOf } from "Object/ListOf";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { NumberOf } from "Any/_Internal";
    /**
    @hidden
    */
    export type _Omit<L extends List, K extends Key> = _ListOf<_OOmit<ObjectOf<L>, NumberOf<K>>>;
    /**
    Remove out of **`L`** the entries of key **`K`**
    @param L to remove from
    @param K to chose entries
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Omit<L extends List, K extends Key> = L extends unknown ? _Omit<L, K> : never;
}
declare module "Any/Omit" {
    import { _Omit as _OOmit } from "Object/Omit";
    import { _Omit as _LOmit } from "List/Omit";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Union } from "Union/Union";
    /**
     * Remove out from each member of union **`U`** the fields of key **`K`**
     * @param U to remove from
     * @param K to chose fields
     * @returns [[Union]]
     * @example
     * ```ts
     * import {U} from 'ts-toolbelt'
     *
     * type O = {type: 'foo'; other: number} | {type: 'bar'; other: string} | [0, 1]
     * type test0 = U.Omit<O, 'other' | '0'> // {type: 'foo'} | {type: 'bar'} | [1]
     * ```
     */
    export type Omit<U extends Union, K extends Key> = U extends object ? U extends List ? _LOmit<U, K> : _OOmit<U, K> : U;
}
declare module "List/Pick" {
    import { _Pick as _OPick } from "Object/Pick";
    import { _ListOf } from "Object/ListOf";
    import { Key } from "Any/Key";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    import { NumberOf } from "Any/_Internal";
    /**
    @hidden
    */
    export type _Pick<L extends List, K extends Key> = _ListOf<_OPick<ObjectOf<L>, NumberOf<K>>>;
    /**
    Extract out of **`L`** the entries of key **`K`**
    @param L to extract from
    @param K to chose entries
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Pick<L extends List, K extends Key> = L extends unknown ? _Pick<L, K> : never;
}
declare module "Any/Pick" {
    import { _Pick as _OPick } from "Object/Pick";
    import { _Pick as _LPick } from "List/Pick";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Union } from "Union/Union";
    /**
     * Extract out from each member of union **`U`** the fields of key **`K`**
     * @param U to remove from
     * @param K to chose fields
     * @returns [[Union]]
     * @example
     * ```ts
     * import {U} from 'ts-toolbelt'
     *
     * type O = {type: 'foo'; other: number} | {type: 'bar'; other: string} | [0, 1]
     * type test0 = U.Pick<O, 'type' | '1'> // {type: 'foo'} | {type: 'bar'} | [1]
     * ```
     */
    export type Pick<U extends Union, K extends Key> = U extends object ? U extends List ? _LPick<U, K> : _OPick<U, K> : U;
}
declare module "Any/_api" {
    /** @ignore */ /** */
    export { Cast } from "Any/Cast";
    export { Clean } from "Any/Clean";
    export { Compute } from "Any/Compute";
    export { Contains } from "Any/Contains";
    export { Equals } from "Any/Equals";
    export { Extends } from "Any/Extends";
    export { Key } from "Any/Key";
    export { Is } from "Any/Is";
    export { IsLiteral } from "Any/IsLiteral";
    export { Kind } from "Any/Kind";
    export { Promisable } from "Any/Promisable";
    export { Promise } from "Any/Promise";
    export { PromiseOf } from "Any/PromiseOf";
    export { Try } from "Any/Try";
    export { Type } from "Any/Type";
    export { x } from "Any/x";
    export { Omit } from "Any/Omit";
    export { Pick } from "Any/Pick";
    export { Contains as Implements } from "Any/Contains";
}
declare module "Boolean/BooleanOf" {
    /**
    Transform a **`boolean`** into a [[Boolean]]
    @param B to transform
    @returns [[Boolean]]
    @example
    ```ts
    type test0 = B.BooleanOf<true>  // 1
    type test1 = B.BooleanOf<false> // 0
    ```
    */
    export type BooleanOf<B extends boolean> = B extends true ? 1 : 0;
}
declare module "Boolean/_Internal" {
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `n`: **`number`**
    * `s`: **`string`**
    */
    export type Formats = 'b' | 'n' | 's';
}
declare module "Boolean/Format" {
    import { Boolean } from "Boolean/Boolean";
    import { Formats } from "Boolean/_Internal";
    /**
    Change the format of a [[Boolean]]
    @param B to transform
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Format<B.True, 's'> // 'true'
    type test1 = B.Format<B.True, 'b'> //  true
    ```
    */
    export type Format<B extends Boolean, fmt extends Formats> = {
        'b': [false, true][B];
        'n': B;
        's': ['false', 'true'][B];
    }[fmt];
}
declare module "Boolean/Xor" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`^`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Xor<B.True, B.True>    // False
    type test1 = B.Xor<B.False, B.True>   // True
    type test2 = B.Xor<B.Boolean, B.True> // Boolean
    ```
    */
    export type Xor<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 1;
        };
        1: {
            0: 1;
            1: 0;
        };
    }[B1][B2];
}
declare module "Boolean/_api" {
    /** @ignore */ /** */
    export { And } from "Boolean/And";
    export { True, False, Boolean } from "Boolean/Boolean";
    export { BooleanOf } from "Boolean/BooleanOf";
    export { Format } from "Boolean/Format";
    export { Not } from "Boolean/Not";
    export { Or } from "Boolean/Or";
    export { Xor } from "Boolean/Xor";
}
declare module "Class/Class" {
    import { List } from "List/List";
    /**
    Alias to create/describe a [[Class]]
    @param P its constructor parameters
    @param R the object it constructs
    */
    export type Class<P extends List = any[], R extends object = object> = {
        new (...args: P): R;
    };
}
declare module "Class/InstanceOf" {
    import { Class } from "Class/Class";
    /**
    Get the instance type of a **`class`** from a class object
    @param C **typeof** **`class`**
    @returns **`class`**
    @example
    ```ts
    import {C} from 'ts-toolbelt'
    
    /// `create` takes an instance constructor and creates an instance of it
    declare function create<C extends (new (...args: any[]) => any)>(c: C): C.InstanceOf<C>
    
    class A {}
    class B {}
    
    let a = create(A) // A
    let b = create(B) // B
    ```
    */
    export type InstanceOf<C extends Class> = C extends Class<any[], infer R> ? R : any;
}
declare module "Class/Parameters" {
    import { Class } from "Class/Class";
    /**
    Get the parameters of a class constructor
    @param C **typeof** **`class`**
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Parameters<C> = C extends Class<infer P, any> ? P : never;
}
declare module "Class/_api" {
    /** @ignore */ /** */
    export { Class } from "Class/Class";
    export { InstanceOf } from "Class/InstanceOf";
    export { Parameters } from "Class/Parameters";
    export { PromiseOf } from "Any/PromiseOf";
}
declare module "Object/UnionOf" {
    import { At } from "Object/At";
    /**
     * @hidden
     */
    export type _UnionOf<O extends object> = At<O, keyof O>;
    /**
    Transform an [[Object]] into an [[Union]]
    @param O to transform
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type UnionOf<O extends object> = O extends unknown ? _UnionOf<O> : never;
}
declare module "Iteration/Prev" {
    import { Map } from "Iteration/Map";
    import { Iteration } from "Iteration/Iteration";
    import { NumberMap } from "Iteration/Maps/Number";
    /**
    Move **`I`**'s position backwards
    @param I to move
    @param IMap to operate with another set of numbers
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Prev<i>> // 19
    ```
    */
    export type Prev<I extends Iteration, IMap extends Map = NumberMap> = IMap[1][I[0]];
}
declare module "Community/IncludesDeep" {
    import { Match } from "Any/_Internal";
    import { Number } from "Number/Number";
    import { UnionOf } from "Object/UnionOf";
    import { Next } from "Iteration/Next";
    import { Key } from "Iteration/Key";
    import { Prev } from "Iteration/Prev";
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Is } from "Any/Is";
    import { Boolean } from "Boolean/Boolean";
    import { Cast } from "Any/Cast";
    /**
     * @hidden
     */
    type _IncludesDeep<O, M extends any, match extends Match, limit extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _IncludesDeep<O extends object ? UnionOf<O> : O, M, match, limit, Next<I>>;
        1: 1;
        2: 0;
    }[Key<Prev<I>> extends limit ? 2 : Is<O, M, match>];
    /**
     * Check whether **`O`**, or its sub-objects have fields that match **`M`**
     * where the maximum allowed depth is set with **`limit`**.
     *
     * @param O to be inspected
     * @param M to check field type
     * @param match (?=`'default'`) to change precision
     * @param limit (?=`'10'`) to change the check depth
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     * @author millsp, ctrlplusb
     */
    export type IncludesDeep<O extends object, M extends any, match extends Match = 'default', limit extends Number = '10'> = _IncludesDeep<O, M, match, limit> extends infer X ? Cast<X, Boolean> : never;
}
declare module "Community/_api" {
    /** @ignore */ /** */
    export { IncludesDeep } from "Community/IncludesDeep";
}
declare module "Function/_Internal" {
    /**
    Describes function modes
    * `sync` : Normal function
    * `async`: Promised result
    */
    export type Mode = 'sync' | 'async';
    /**
    Describes function parameter input
    * `multi`: ( a, b, c ... n ) => X
    * `list` : ([a, b, c ... n]) => X
    */
    export type Input = 'multi' | 'list';
}
declare module "Function/Function" {
    import { List } from "List/List";
    /**
    Alias to create a [[Function]]
    @param P parameters
    @param R return type
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    type test0 = F.Function<[string, number], boolean>
    /// (args_0: string, args_1: number) => boolean
    ```
    */
    export interface Function<P extends List = any, R extends any = any> {
        (...args: P): R;
    }
}
declare module "Function/Compose/Multi/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    /**
    @hidden
     */
    export type ComposeMultiSync = {
        <R0, P extends any[]>(...fns: [
            Function<P, R0>
        ]): Function<P, R0>;
        <R0, R1, P extends any[]>(...fns: [
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(...fns: [
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [
            Function<[R7], R8>,
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [
            Function<[R8], R9>,
            Function<[R7], R8>,
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R9>;
    };
}
declare module "Function/Compose/Multi/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Any/PromiseOf";
    /**
    @hidden
     */
    export type ComposeMultiAsync = {
        <R0, P extends any[]>(...fns: [
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(...fns: [
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(...fns: [
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [
            Function<[PromiseOf<R7>], R8>,
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [
            Function<[PromiseOf<R8>], R9>,
            Function<[PromiseOf<R7>], R8>,
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R9>>>;
    };
}
declare module "Function/Compose/List/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    /**
    @hidden
     */
    export type ComposeListSync = {
        <R0, P extends any[]>(fns: [
            Function<P, R0>
        ]): Function<P, R0>;
        <R0, R1, P extends any[]>(fns: [
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(fns: [
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(fns: [
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [
            Function<[R7], R8>,
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [
            Function<[R8], R9>,
            Function<[R7], R8>,
            Function<[R6], R7>,
            Function<[R5], R6>,
            Function<[R4], R5>,
            Function<[R3], R4>,
            Function<[R2], R3>,
            Function<[R1], R2>,
            Function<[R0], R1>,
            Function<P, R0>
        ]): Function<P, R9>;
    };
}
declare module "Function/Compose/List/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Any/PromiseOf";
    /**
    @hidden
     */
    export type ComposeListAsync = {
        <R0, P extends any[]>(fns: [
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(fns: [
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(fns: [
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(fns: [
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [
            Function<[PromiseOf<R7>], R8>,
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [
            Function<[PromiseOf<R8>], R9>,
            Function<[PromiseOf<R7>], R8>,
            Function<[PromiseOf<R6>], R7>,
            Function<[PromiseOf<R5>], R6>,
            Function<[PromiseOf<R4>], R5>,
            Function<[PromiseOf<R3>], R4>,
            Function<[PromiseOf<R2>], R3>,
            Function<[PromiseOf<R1>], R2>,
            Function<[PromiseOf<R0>], R1>,
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R9>>>;
    };
}
declare module "List/Tail" {
    import { List } from "List/List";
    /**
    Remove the first item out of a [[List]]
    @param L
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Tail<L extends List> = ((...t: L) => any) extends ((head: any, ...tail: infer LTail) => any) ? LTail : never;
}
declare module "List/Last" {
    import { Tail } from "List/Tail";
    import { Length } from "List/Length";
    import { List } from "List/List";
    /**
    Get the last entry of **`L`**
    @param L to extract from
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Last<L extends List> = L[Length<Tail<L>>];
}
declare module "String/_Internal" {
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `s`: **`string`**
    * `n`: **`number`**
    */
    export type Formats = 'b' | 'n' | 's';
}
declare module "String/Format" {
    import { Formats } from "String/_Internal";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Extends } from "Any/Extends";
    /**
    Change the format of a **`string`**
    @param S to transform
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {S} from 'ts-toolbelt'
    
    type test0 = S.Format<'30', 'b'> // True
    type test1 = S.Format<'30', 'n'> // 30
    ```
    */
    export type Format<S extends string, fmt extends Formats> = {
        'b': {
            1: Boolean;
            0: S extends 'false' ? 0 : 1;
        }[Extends<string, S>];
        'n': Pos<IterationOf<S>>;
        's': S;
    }[fmt];
}
declare module "List/Head" {
    import { Length } from "List/Length";
    import { List } from "List/List";
    /**
    Get the first entry of **`L`**
    @param L to extract from
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Head<L extends List> = Length<L> extends 0 ? never : L[0];
}
declare module "Function/Return" {
    import { Function } from "Function/Function";
    import { List } from "List/List";
    /**
    Extract the return type of a [[Function]]
    @param F to extract from
    @returns **`any`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = () => true
    
    type test0 = F.ReturnOf<typeof fn>  // boolean
    
    type test1 = F.ReturnOf<() => true> // true
    ```
    */
    export type Return<F extends Function> = F extends ((...args: List) => infer R) ? R : never;
}
declare module "Function/Parameters" {
    import { Function } from "Function/Function";
    /**
    Extract parameters from a [[Function]]
    @param F to extract from
    @returns [[List]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = (name: string, age: number) => {}
    
    type test0 = F.ParamsOf<typeof fn>                         // [string, number]
    
    type test1 = F.ParamsOf<(name: string, age: number) => {}> // [string, number]
    ```
    */
    export type Parameters<F extends Function> = F extends ((...args: infer L) => any) ? L : never;
}
declare module "Union/IntersectOf" {
    import { Union } from "Union/Union";
    /**
    Transform a [[Union]] to an **intersection**
    @param U to transform
    @returns **intersection**
    @example
    ```ts
    ```
    */
    export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
}
declare module "Function/Compose" {
    import { Mode, Input } from "Function/_Internal";
    import { ComposeMultiSync } from "Function/Compose/Multi/Sync";
    import { ComposeMultiAsync } from "Function/Compose/Multi/Async";
    import { ComposeListSync } from "Function/Compose/List/Sync";
    import { ComposeListAsync } from "Function/Compose/List/Async";
    import { Function } from "Function/Function";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Last } from "List/Last";
    import { Format } from "String/Format";
    import { Length } from "List/Length";
    import { Tail } from "List/Tail";
    import { Next } from "Iteration/Next";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Parameters } from "Function/Parameters";
    import { PromiseOf } from "Any/PromiseOf";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    import { IntersectOf } from "Union/IntersectOf";
    /**
    @hidden
    */
    type ComposeFnSync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? Fns[K] : Function<[
        Return<Fns[Pos<Next<IterationOf<K & string>>>]> extends infer X ? {
            1: any;
            0: X;
        }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never
    ], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    @hidden
    */
    type ComposeFnAsync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? PromiseOf<Fns[K]> : Function<[
        PromiseOf<Return<Fns[Pos<Next<IterationOf<K & string>>>]>> extends infer X ? {
            1: any;
            0: X;
        }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never
    ], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    Compute what the input of [[Compose]] should be
    @param Fns to compose
    @param mode (?=`'sync'`) sync/async
    @example
    ```ts
    ```
    */
    export type Composer<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': {
            [K in keyof Fns]: ComposeFnSync<Fns, K>;
        };
        'async': {
            [K in keyof Fns]: ComposeFnAsync<Fns, K>;
        };
    }[mode];
    /**
    Compose [[Function]]s together
    @param Fns to compose
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `compose`
    /// `Composer` will check for input & `Composed` the output
    declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns>): F.Composed<Fns>
    
    const a = (a1: number) => `${a1}`
    const c = (c1: string[]) => [c1]
    const b = (b1: string) => [b1]
    
    compose(c, b, a)(42)
    
    /// And if you are looking for an async `compose` type
    declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns, 'async'>): F.Composed<Fns, 'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await compose(c, b, a)(42)
    */
    export type Composed<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': (...args: Parameters<Last<Fns>>) => Return<Head<Fns>>;
        'async': (...args: Parameters<Last<Fns>>) => Promise<PromiseOf<Return<Head<Fns>>>>;
    }[mode];
    /**
    Compose [[Function]]s together
    @param mode  (?=`'sync'`)    sync/async (this depends on your implementation)
    @param input (?=`'multi'`)   whether you want it to take a list or parameters
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `compose`
    /// `Composer` will check for input & `Compose` the output
    declare const compose: F.Compose
    
    const a = (a1: number) => `${a1}`
    const c = (c1: string[]) => [c1]
    const b = (b1: string) => [b1]
    
    compose(c, b, a)(42)
    
    /// And if you are looking for an async `compose` type
    declare const compose: F.Compose<'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await compose(c, b, a)(42)
    */
    export type Compose<mode extends Mode = 'sync', input extends Input = 'multi'> = IntersectOf<{
        'sync': {
            'multi': ComposeMultiSync;
            'list': ComposeListSync;
        };
        'async': {
            'multi': ComposeMultiAsync;
            'list': ComposeListAsync;
        };
    }[mode][input]>;
}
declare module "Union/NonNullable" {
    import { Exclude } from "Union/Exclude";
    import { Union } from "Union/Union";
    /**
    Remove **`undefined`** & **`null`** out of **`U`**
    @param U to make non-nullable
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type NonNullable<U extends Union> = Exclude<U, undefined | null>;
}
declare module "Object/Patch" {
    import { AtBasic } from "Object/At";
    import { Key } from "Any/Key";
    import { _ListOf } from "Object/ListOf";
    import { List } from "List/List";
    import { Depth, MergeStyle } from "Object/_Internal";
    import { BuiltInObject } from "Misc/BuiltInObject";
    import { _Omit } from "Object/Omit";
    import { ObjectOf } from "List/ObjectOf";
    /**
    @hidden
    */
    type LibStyle<Merged, O, O1, style extends MergeStyle> = {
        0: [O] extends [List] ? [O1] extends [List] ? _ListOf<Merged & {}> : O : Merged;
        1: Merged;
        2: [O] extends [List] ? [O1] extends [List] ? Merged[keyof Merged][] : O : Merged;
    }[style];
    /**
    @hidden
    */
    type PatchProp<OK, O1K, K extends Key, OOK extends Key> = K extends OOK ? OK : O1K;
    /**
    @hidden
    */
    type __PatchFlat<O extends object, O1 extends object, OOK extends Key = keyof O> = {
        [K in keyof (O & _Omit<O1, OOK>)]: PatchProp<AtBasic<O, K>, AtBasic<O1, K>, K, OOK>;
    } & {};
    /**
    @hidden
    */
    export type _PatchFlat<O extends object, O1 extends object, style extends MergeStyle> = LibStyle<__PatchFlat<ObjectOf<O>, ObjectOf<O1>>, O, O1, style>;
    /**
    @hidden
    */
    export type PatchFlat<O extends object, O1 extends object, style extends MergeStyle = 2, noMerge = BuiltInObject> = O extends noMerge ? O : O1 extends noMerge ? O : _PatchFlat<O, O1, style>;
    /**
    @hidden
    */
    type __PatchDeep<O extends object, O1 extends object, style extends MergeStyle, noMerge, OOK extends Key = keyof O> = {
        [K in keyof (O & _Omit<O1, OOK>)]: _PatchDeep<AtBasic<O, K>, AtBasic<O1, K>, K, OOK, style, noMerge>;
    };
    /**
    @hidden
    */
    type ChoosePatchDeep<OK, O1K, K extends Key, OOK extends Key, style extends MergeStyle, noMerge> = OK extends BuiltInObject ? PatchProp<OK, O1K, K, OOK> : O1K extends BuiltInObject ? PatchProp<OK, O1K, K, OOK> : OK extends object ? O1K extends object ? __PatchDeep<ObjectOf<OK>, ObjectOf<O1K>, style, noMerge> : PatchProp<OK, O1K, K, OOK> : PatchProp<OK, O1K, K, OOK>;
    /**
    @hidden
    */
    export type _PatchDeep<O, O1, K extends Key, OOK extends Key, style extends MergeStyle, noMerge> = [
        O
    ] extends [never] ? PatchProp<O, O1, K, OOK> : [O1] extends [never] ? PatchProp<O, O1, K, OOK> : LibStyle<ChoosePatchDeep<O, O1, K, OOK, style, noMerge>, O, O1, style>;
    /**
    @hidden
    */
    export type PatchDeep<O, O1, style extends MergeStyle, noMerge> = O extends unknown ? O1 extends unknown ? _PatchDeep<O, O1, 'x', 'y', style, noMerge> : never : never;
    /**
    Complete the fields of **`O`** with the ones of **`O1`**. This is a version of
    [[Merge]] that does NOT handle optional fields, it only completes fields of `O`
    with the ones of `O1`.
    @param O to complete
    @param O1 to copy from
    @param depth (?=`'flat'`) to do it deeply
    @param style (?=`1`) 0 = lodash, 1 = ramda
    @param noMerge (?=`BuiltinObject`) types not to merge
    @returns [[Object]]
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    type O = {
        name?: string
        age? : number
        zip? : string
        pay  : {
            cvv?: number
        }
    }
    
    type O1 = {
        age : number
        zip?: number
        city: string
        pay : {
            cvv : number
            ccn?: string
        }
    }
    
    type test = O.Patch<O, O1, 'deep'>
    // {
    //     name?: string;
    //     age?: number;
    //     zip?: string | number;
    //     pay: {
    //         cvv?: number;
    //         ccn?: string;
    //     };
    //     city: string;
    // }
    ```
    */
    export type Patch<O extends object, O1 extends object, depth extends Depth = 'flat', style extends MergeStyle = 2, noMerge = BuiltInObject> = {
        'flat': PatchFlat<O, O1, style, noMerge>;
        'deep': PatchDeep<O, O1, style, noMerge>;
    }[depth];
}
declare module "Object/NonNullable" {
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Depth } from "Object/_Internal";
    import { _Pick } from "Object/Pick";
    import { Key } from "Any/Key";
    import { _PatchFlat } from "Object/Patch";
    import { BuiltInObject } from "Misc/BuiltInObject";
    /**
    @hidden
    */
    export type NonNullableFlat<O> = {
        [K in keyof O]: UNonNullable<O[K]>;
    } & {};
    /**
    @hidden
    */
    export type NonNullableDeep<O> = {
        [K in keyof O]: O[K] extends BuiltInObject ? O[K] : NonNullableDeep<UNonNullable<O[K]>>;
    };
    /**
    @hidden
    */
    export type NonNullablePart<O extends object, depth extends Depth> = {
        'flat': NonNullableFlat<O>;
        'deep': NonNullableDeep<O>;
    }[depth];
    /**
     * @hidden
     */
    export type _NonNullable<O extends object, K extends Key, depth extends Depth> = _PatchFlat<NonNullablePart<_Pick<O, K>, depth>, O, 2>;
    /**
    Make some fields of **`O`** not nullable (deeply or not)
    (Optional fields will be left untouched & **`undefined`**)
    @param O to make non nullable
    @param K (?=`Key`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type NonNullable<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = O extends unknown ? _NonNullable<O, K, depth> : never;
}
declare module "Function/Curry" {
    import { Pos } from "Iteration/Pos";
    import { _Append } from "List/Append";
    import { _Concat } from "List/Concat";
    import { Length } from "List/Length";
    import { Next } from "Iteration/Next";
    import { Cast } from "Any/Cast";
    import { Parameters } from "Function/Parameters";
    import { Return } from "Function/Return";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { NonNullableFlat } from "Object/NonNullable";
    import { x } from "Any/x";
    import { List } from "List/List";
    import { Function } from "Function/Function";
    import { Extends } from "Any/Extends";
    import { Tail } from "List/Tail";
    /**
    @hidden
    */
    type GapOf<L1 extends List, L2 extends List, LN extends List, I extends Iteration> = L1[Pos<I>] extends x ? _Append<LN, L2[Pos<I>]> : LN;
    /**
    @hidden
    */
    type _GapsOf<L1 extends List, L2 extends List, LN extends List = [], L2D extends List = L2, I extends Iteration = IterationOf<'0'>> = {
        0: _GapsOf<L1, L2, GapOf<L1, L2, LN, I>, Tail<L2D>, Next<I>>;
        1: _Concat<LN, L2D>;
    }[Extends<Pos<I>, Length<L1>>];
    /**
    @hidden
    */
    type GapsOf<L1 extends List, L2 extends List> = _GapsOf<L1, L2> extends infer X ? Cast<X, List> : never;
    /**
    @hidden
    */
    type Gaps<L extends List> = Cast<NonNullableFlat<{
        [K in keyof L]?: L[K] | x;
    }>, List>;
    /**
    Curry a [[Function]]
    @param F to curry
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `curry`
    /// It handles placeholders and variable arguments
    declare function curry<Fn extends F.Function>(fn: Fn): F.Curry<Fn>
    ```
    */
    export type Curry<F extends Function> = <L extends List, G extends List = GapsOf<L, Parameters<F>>, R extends any = Return<F>>(...args: Cast<L, Gaps<Parameters<F>>>) => Length<G> extends 0 ? R : Length<G> extends 1 ? Curry<(...args: G) => R> & ((...args: G) => R) : Curry<(...args: G) => R>;
}
declare module "Function/Length" {
    import { Function } from "Function/Function";
    import { Parameters } from "Function/Parameters";
    import { Formats } from "Iteration/_Internal";
    import { Length as LLength } from "List/Length";
    /**
    Extract arguments' length from a [[Function]]
    @param F to extract from
    @param fmt (?=`'n'`) output
    @returns [[String]] or **`number`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = (a1: any, a2: any) => {}
    
    type test0 = F.LengthOf<typeof fn>               // 2
    
    type test1 = F.LengthOf<(a1?: any) => any>       // 0 | 1
    
    type test2 = F.LengthOf<(...a: any[]) => any>    // number
    ```
    */
    export type Length<Fn extends Function, fmt extends Formats = 'n'> = LLength<Parameters<Fn>, fmt>;
}
declare module "Function/NoInfer" {
    /**
    Explain to TS which function parameter has priority for generic inference
    @param A to de-prioritize
    @returns **`A`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn0 = <A extends any>(a0: A, a1: F.NoInfer<A>): A => {
        return {} as unknown as A // just for the example
    }
    
    const fn1 = <A extends any>(a0: F.NoInfer<A>, a1: A): A => {
        return {} as unknown as A // just for the example
    }
    
    const fn2 = <A extends any>(a0: F.NoInfer<A>, a1: F.NoInfer<A>): A => {
        return {} as unknown as A // just for the example
    }
    
    const test0 = fn0('b', 'a') // error: infer priority is `a0`
    const test1 = fn1('b', 'a') // error: infer priority is `a1`
    const test2 = fn2('b', 'a') // works: infer priority is `a0` | `a1`
    ```
    @see https://stackoverflow.com/questions/56687668
    */
    export type NoInfer<A extends any> = [
        A
    ][A extends any ? 0 : never];
}
declare module "Function/Pipe/Multi/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    /**
    @hidden
     */
    export type PipeMultiSync = {
        <R0, P extends any[]>(...fns: [
            Function<P, R0>
        ]): Function<P, R0>;
        <R0, R1, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>
        ]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>
        ]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>
        ]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>
        ]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>,
            Function<[R4], R5>
        ]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>,
            Function<[R4], R5>,
            Function<[R5], R6>
        ]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>,
            Function<[R4], R5>,
            Function<[R5], R6>,
            Function<[R6], R7>
        ]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>,
            Function<[R4], R5>,
            Function<[R5], R6>,
            Function<[R6], R7>,
            Function<[R7], R8>
        ]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [
            Function<P, R0>,
            Function<[R0], R1>,
            Function<[R1], R2>,
            Function<[R2], R3>,
            Function<[R3], R4>,
            Function<[R4], R5>,
            Function<[R5], R6>,
            Function<[R6], R7>,
            Function<[R7], R8>,
            Function<[R8], R9>
        ]): Function<P, R9>;
    };
}
declare module "Function/Pipe/Multi/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Any/PromiseOf";
    /**
    @hidden
     */
    export type PipeMultiAsync = {
        <R0, P extends any[]>(...fns: [
            Function<P, R0>
        ]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(...fns: [
            Function<P, R0>,
     
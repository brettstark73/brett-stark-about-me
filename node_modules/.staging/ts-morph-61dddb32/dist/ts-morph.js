'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var common = require('@ts-morph/common');
var CodeBlockWriter = require('code-block-writer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var CodeBlockWriter__default = /*#__PURE__*/_interopDefaultLegacy(CodeBlockWriter);

class AdvancedIterator {
    constructor(iterator) {
        this.iterator = iterator;
        this.buffer = [undefined, undefined, undefined];
        this.bufferIndex = 0;
        this.isDone = false;
        this.nextCount = 0;
        this.advance();
    }
    get done() {
        return this.isDone;
    }
    get current() {
        if (this.nextCount === 0)
            throw new common.errors.InvalidOperationError("Cannot get the current when the iterator has not been advanced.");
        return this.buffer[this.bufferIndex];
    }
    get previous() {
        if (this.nextCount <= 1)
            throw new common.errors.InvalidOperationError("Cannot get the previous when the iterator has not advanced enough.");
        return this.buffer[(this.bufferIndex + this.buffer.length - 1) % this.buffer.length];
    }
    get peek() {
        if (this.isDone)
            throw new common.errors.InvalidOperationError("Cannot peek at the end of the iterator.");
        return this.buffer[(this.bufferIndex + 1) % this.buffer.length];
    }
    next() {
        if (this.done)
            throw new common.errors.InvalidOperationError("Cannot get the next when at the end of the iterator.");
        const next = this.buffer[this.getNextBufferIndex()];
        this.advance();
        this.nextCount++;
        return next;
    }
    *rest() {
        while (!this.done)
            yield this.next();
    }
    advance() {
        const next = this.iterator.next();
        this.bufferIndex = this.getNextBufferIndex();
        if (next.done) {
            this.isDone = true;
            return;
        }
        this.buffer[this.getNextBufferIndex()] = next.value;
    }
    getNextBufferIndex() {
        return (this.bufferIndex + 1) % this.buffer.length;
    }
}

const CharCodes = {
    ASTERISK: "*".charCodeAt(0),
    NEWLINE: "\n".charCodeAt(0),
    CARRIAGE_RETURN: "\r".charCodeAt(0),
    SPACE: " ".charCodeAt(0),
    TAB: "\t".charCodeAt(0),
    CLOSE_BRACE: "}".charCodeAt(0),
};

function getNodeByNameOrFindFunction(items, nameOrFindFunc) {
    let findFunc;
    if (typeof nameOrFindFunc === "string")
        findFunc = dec => nodeHasName(dec, nameOrFindFunc);
    else
        findFunc = nameOrFindFunc;
    return items.find(findFunc);
}
function nodeHasName(node, name) {
    if (node.getNameNode == null)
        return false;
    const nameNode = node.getNameNode();
    if (nameNode == null)
        return false;
    if (Node.isArrayBindingPattern(nameNode) || Node.isObjectBindingPattern(nameNode))
        return nameNode.getElements().some(element => nodeHasName(element, name));
    const nodeName = node.getName != null ? node.getName() : nameNode.getText();
    return nodeName === name;
}
function getNotFoundErrorMessageForNameOrFindFunction(findName, nameOrFindFunction) {
    if (typeof nameOrFindFunction === "string")
        return `Expected to find ${findName} named '${nameOrFindFunction}'.`;
    return `Expected to find ${findName} that matched the provided condition.`;
}

function getParentSyntaxList(node, sourceFile) {
    if (node.kind === common.SyntaxKind.EndOfFileToken)
        return undefined;
    const parent = node.parent;
    if (parent == null)
        return undefined;
    const { pos, end } = node;
    for (const child of parent.getChildren(sourceFile)) {
        if (child.pos > end || child === node)
            return undefined;
        if (child.kind === common.SyntaxKind.SyntaxList && child.pos <= pos && child.end >= end)
            return child;
    }
    return undefined;
}

function getSymbolByNameOrFindFunction(items, nameOrFindFunc) {
    let findFunc;
    if (typeof nameOrFindFunc === "string")
        findFunc = dec => dec.getName() === nameOrFindFunc;
    else
        findFunc = nameOrFindFunc;
    return items.find(findFunc);
}

function isNodeAmbientOrInAmbientContext(node) {
    if (checkNodeIsAmbient(node) || node._sourceFile.isDeclarationFile())
        return true;
    for (const ancestor of node._getAncestorsIterator(false)) {
        if (checkNodeIsAmbient(ancestor))
            return true;
    }
    return false;
}
function checkNodeIsAmbient(node) {
    const isThisAmbient = (node.getCombinedModifierFlags() & common.ts.ModifierFlags.Ambient) === common.ts.ModifierFlags.Ambient;
    return isThisAmbient || Node.isInterfaceDeclaration(node) || Node.isTypeAliasDeclaration(node);
}

function isStringKind(kind) {
    switch (kind) {
        case common.SyntaxKind.StringLiteral:
        case common.SyntaxKind.NoSubstitutionTemplateLiteral:
        case common.SyntaxKind.TemplateHead:
        case common.SyntaxKind.TemplateMiddle:
        case common.SyntaxKind.TemplateTail:
            return true;
        default:
            return false;
    }
}

class ModuleUtils {
    constructor() {
    }
    static isModuleSpecifierRelative(text) {
        return text.startsWith("./")
            || text.startsWith("../");
    }
    static getReferencedSourceFileFromSymbol(symbol) {
        const declarations = symbol.getDeclarations();
        if (declarations.length === 0 || declarations[0].getKind() !== common.SyntaxKind.SourceFile)
            return undefined;
        return declarations[0];
    }
}

function printNode(node, sourceFileOrOptions, secondOverloadOptions) {
    var _a, _b;
    const isFirstOverload = sourceFileOrOptions == null || sourceFileOrOptions.kind !== common.SyntaxKind.SourceFile;
    const options = getOptions();
    const sourceFile = getSourceFile();
    const printer = common.ts.createPrinter({
        newLine: (_a = options.newLineKind) !== null && _a !== void 0 ? _a : common.NewLineKind.LineFeed,
        removeComments: options.removeComments || false,
    });
    if (sourceFile == null)
        return printer.printFile(node);
    else
        return printer.printNode((_b = options.emitHint) !== null && _b !== void 0 ? _b : common.EmitHint.Unspecified, node, sourceFile);
    function getSourceFile() {
        if (isFirstOverload) {
            if (node.kind === common.SyntaxKind.SourceFile)
                return undefined;
            const topParent = getNodeSourceFile();
            if (topParent == null) {
                const scriptKind = getScriptKind();
                return common.ts.createSourceFile(`print.${getFileExt(scriptKind)}`, "", common.ScriptTarget.Latest, false, scriptKind);
            }
            return topParent;
        }
        return sourceFileOrOptions;
        function getScriptKind() {
            var _a;
            return (_a = options.scriptKind) !== null && _a !== void 0 ? _a : common.ScriptKind.TSX;
        }
        function getFileExt(scriptKind) {
            if (scriptKind === common.ScriptKind.JSX || scriptKind === common.ScriptKind.TSX)
                return "tsx";
            return "ts";
        }
    }
    function getNodeSourceFile() {
        let topNode = node.parent;
        while (topNode != null && topNode.parent != null)
            topNode = topNode.parent;
        return topNode;
    }
    function getOptions() {
        return (isFirstOverload ? sourceFileOrOptions : secondOverloadOptions) || {};
    }
}

exports.IndentationText = void 0;
(function (IndentationText) {
    IndentationText["TwoSpaces"] = "  ";
    IndentationText["FourSpaces"] = "    ";
    IndentationText["EightSpaces"] = "        ";
    IndentationText["Tab"] = "\t";
})(exports.IndentationText || (exports.IndentationText = {}));
class ManipulationSettingsContainer extends common.SettingsContainer {
    constructor() {
        super({
            indentationText: exports.IndentationText.FourSpaces,
            newLineKind: common.NewLineKind.LineFeed,
            quoteKind: exports.QuoteKind.Double,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            usePrefixAndSuffixTextForRename: false,
            useTrailingCommas: false,
        });
    }
    getEditorSettings() {
        if (this._editorSettings == null) {
            this._editorSettings = {};
            fillDefaultEditorSettings(this._editorSettings, this);
        }
        return Object.assign({}, this._editorSettings);
    }
    getFormatCodeSettings() {
        if (this._formatCodeSettings == null) {
            this._formatCodeSettings = Object.assign(Object.assign({}, this.getEditorSettings()), { insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: this._settings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces });
        }
        return Object.assign({}, this._formatCodeSettings);
    }
    getUserPreferences() {
        if (this._userPreferences == null) {
            this._userPreferences = {
                quotePreference: this.getQuoteKind() === exports.QuoteKind.Double ? "double" : "single",
                providePrefixAndSuffixTextForRename: this.getUsePrefixAndSuffixTextForRename(),
            };
        }
        return Object.assign({}, this._userPreferences);
    }
    getQuoteKind() {
        return this._settings.quoteKind;
    }
    getNewLineKind() {
        return this._settings.newLineKind;
    }
    getNewLineKindAsString() {
        return newLineKindToString(this.getNewLineKind());
    }
    getIndentationText() {
        return this._settings.indentationText;
    }
    getUsePrefixAndSuffixTextForRename() {
        return this._settings.usePrefixAndSuffixTextForRename;
    }
    getUseTrailingCommas() {
        return this._settings.useTrailingCommas;
    }
    set(settings) {
        super.set(settings);
        this._editorSettings = undefined;
        this._formatCodeSettings = undefined;
        this._userPreferences = undefined;
    }
    _getIndentSizeInSpaces() {
        const indentationText = this.getIndentationText();
        switch (indentationText) {
            case exports.IndentationText.EightSpaces:
                return 8;
            case exports.IndentationText.FourSpaces:
                return 4;
            case exports.IndentationText.TwoSpaces:
                return 2;
            case exports.IndentationText.Tab:
                return 4;
            default:
                return common.errors.throwNotImplementedForNeverValueError(indentationText);
        }
    }
}

function setValueIfUndefined(obj, propertyName, defaultValue) {
    if (typeof obj[propertyName] === "undefined")
        obj[propertyName] = defaultValue;
}

function fillDefaultEditorSettings(settings, manipulationSettings) {
    setValueIfUndefined(settings, "convertTabsToSpaces", manipulationSettings.getIndentationText() !== exports.IndentationText.Tab);
    setValueIfUndefined(settings, "newLineCharacter", manipulationSettings.getNewLineKindAsString());
    setValueIfUndefined(settings, "indentStyle", common.ts.IndentStyle.Smart);
    setValueIfUndefined(settings, "indentSize", manipulationSettings.getIndentationText().length);
    setValueIfUndefined(settings, "tabSize", manipulationSettings.getIndentationText().length);
}

function fillDefaultFormatCodeSettings(settings, manipulationSettings) {
    fillDefaultEditorSettings(settings, manipulationSettings);
    setValueIfUndefined(settings, "insertSpaceAfterCommaDelimiter", true);
    setValueIfUndefined(settings, "insertSpaceAfterConstructor", false);
    setValueIfUndefined(settings, "insertSpaceAfterSemicolonInForStatements", true);
    setValueIfUndefined(settings, "insertSpaceAfterKeywordsInControlFlowStatements", true);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces", true);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets", false);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces", false);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces", false);
    setValueIfUndefined(settings, "insertSpaceBeforeFunctionParenthesis", false);
    setValueIfUndefined(settings, "insertSpaceBeforeAndAfterBinaryOperators", true);
    setValueIfUndefined(settings, "placeOpenBraceOnNewLineForFunctions", false);
    setValueIfUndefined(settings, "placeOpenBraceOnNewLineForControlBlocks", false);
    setValueIfUndefined(settings, "ensureNewLineAtEndOfFile", true);
}

function getTextFromStringOrWriter(writer, textOrWriterFunction) {
    printTextFromStringOrWriter(writer, textOrWriterFunction);
    return writer.toString();
}
function printTextFromStringOrWriter(writer, textOrWriterFunction) {
    if (typeof textOrWriterFunction === "string")
        writer.write(textOrWriterFunction);
    else if (textOrWriterFunction instanceof Function)
        textOrWriterFunction(writer);
    else {
        for (let i = 0; i < textOrWriterFunction.length; i++) {
            if (i > 0)
                writer.newLineIfLastNot();
            printTextFromStringOrWriter(writer, textOrWriterFunction[i]);
        }
    }
}

class EnableableLogger {
    constructor() {
        this.enabled = false;
    }
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    log(text) {
        if (this.enabled)
            this.logInternal(text);
    }
    warn(text) {
        if (this.enabled)
            this.warnInternal(text);
    }
}

class ConsoleLogger extends EnableableLogger {
    logInternal(text) {
        console.log(text);
    }
    warnInternal(text) {
        console.warn(text);
    }
}

const reg = /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/;
function isValidVariableName(variableName) {
    return reg.test(variableName);
}

function newLineKindToString(kind) {
    switch (kind) {
        case common.NewLineKind.CarriageReturnLineFeed:
            return "\r\n";
        case common.NewLineKind.LineFeed:
            return "\n";
        default:
            throw new common.errors.NotImplementedError(`Not implemented newline kind: ${kind}`);
    }
}

class LazyReferenceCoordinator {
    constructor(factory) {
        this.dirtySourceFiles = new Set();
        const onSourceFileModified = (sourceFile) => {
            if (!sourceFile.wasForgotten())
                this.dirtySourceFiles.add(sourceFile);
        };
        factory.onSourceFileAdded(sourceFile => {
            this.dirtySourceFiles.add(sourceFile);
            sourceFile.onModified(onSourceFileModified);
        });
        factory.onSourceFileRemoved(sourceFile => {
            sourceFile._referenceContainer.clear();
            this.dirtySourceFiles.delete(sourceFile);
            sourceFile.onModified(onSourceFileModified, false);
        });
    }
    refreshDirtySourceFiles() {
        for (const sourceFile of this.dirtySourceFiles.values())
            sourceFile._referenceContainer.refresh();
        this.clearDirtySourceFiles();
    }
    refreshSourceFileIfDirty(sourceFile) {
        if (!this.dirtySourceFiles.has(sourceFile))
            return;
        sourceFile._referenceContainer.refresh();
        this.clearDityForSourceFile(sourceFile);
    }
    addDirtySourceFile(sourceFile) {
        this.dirtySourceFiles.add(sourceFile);
    }
    clearDirtySourceFiles() {
        this.dirtySourceFiles.clear();
    }
    clearDityForSourceFile(sourceFile) {
        this.dirtySourceFiles.delete(sourceFile);
    }
}

class SourceFileReferenceContainer {
    constructor(sourceFile) {
        this.sourceFile = sourceFile;
        this.nodesInThis = new common.KeyValueCache();
        this.nodesInOther = new common.KeyValueCache();
        this.unresolvedLiterals = [];
        this.resolveUnresolved = () => {
            for (let i = this.unresolvedLiterals.length - 1; i >= 0; i--) {
                const literal = this.unresolvedLiterals[i];
                const sourceFile = this.getSourceFileForLiteral(literal);
                if (sourceFile != null) {
                    this.unresolvedLiterals.splice(i, 1);
                    this.addNodeInThis(literal, sourceFile);
                }
            }
            if (this.unresolvedLiterals.length === 0)
                this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        };
    }
    getDependentSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        const hashSet = new Set();
        for (const nodeInOther of this.nodesInOther.getKeys())
            hashSet.add(nodeInOther._sourceFile);
        return hashSet.values();
    }
    getLiteralsReferencingOtherSourceFilesEntries() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshSourceFileIfDirty(this.sourceFile);
        return this.nodesInThis.getEntries();
    }
    getReferencingLiteralsInOtherSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        return this.nodesInOther.getKeys();
    }
    refresh() {
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        this.clear();
        this.populateReferences();
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved);
    }
    clear() {
        this.unresolvedLiterals.length = 0;
        for (const [node, sourceFile] of this.nodesInThis.getEntries()) {
            this.nodesInThis.removeByKey(node);
            sourceFile._referenceContainer.nodesInOther.removeByKey(node);
        }
    }
    populateReferences() {
        this.sourceFile._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
            for (const literal of this.sourceFile.getImportStringLiterals()) {
                const sourceFile = this.getSourceFileForLiteral(literal);
                remember(literal);
                if (sourceFile == null)
                    this.unresolvedLiterals.push(literal);
                else
                    this.addNodeInThis(literal, sourceFile);
            }
        });
    }
    getSourceFileForLiteral(literal) {
        const parent = literal.getParentOrThrow();
        const grandParent = parent.getParent();
        if (Node.isImportDeclaration(parent) || Node.isExportDeclaration(parent))
            return parent.getModuleSpecifierSourceFile();
        else if (grandParent != null && Node.isImportEqualsDeclaration(grandParent))
            return grandParent.getExternalModuleReferenceSourceFile();
        else if (Node.isCallExpression(parent)) {
            const literalSymbol = literal.getSymbol();
            if (literalSymbol != null)
                return ModuleUtils.getReferencedSourceFileFromSymbol(literalSymbol);
        }
        else {
            this.sourceFile._context.logger.warn(`Unknown import string literal parent: ${parent.getKindName()}`);
        }
        return undefined;
    }
    addNodeInThis(literal, sourceFile) {
        this.nodesInThis.set(literal, sourceFile);
        sourceFile._referenceContainer.nodesInOther.set(literal, sourceFile);
    }
}

function getCompilerOptionsFromTsConfig(filePath, options = {}) {
    const result = common.getCompilerOptionsFromTsConfig(filePath, options);
    return {
        options: result.options,
        errors: result.errors.map(error => new Diagnostic(undefined, error)),
    };
}

common.ts.version.split(".").map(v => parseInt(v, 10));

class WriterUtils {
    constructor() {
    }
    static getLastCharactersToPos(writer, pos) {
        const writerLength = writer.getLength();
        const charCount = writerLength - pos;
        const chars = new Array(charCount);
        writer.iterateLastChars((char, i) => {
            const insertPos = i - pos;
            if (insertPos < 0)
                return true;
            chars[insertPos] = char;
            return undefined;
        });
        return chars.join("");
    }
}

function callBaseGetStructure(basePrototype, node, structure) {
    let newStructure;
    if (basePrototype.getStructure != null)
        newStructure = basePrototype.getStructure.call(node);
    else
        newStructure = {};
    if (structure != null)
        common.ObjectUtils.assign(newStructure, structure);
    return newStructure;
}

function callBaseSet(basePrototype, node, structure) {
    if (basePrototype.set != null)
        basePrototype.set.call(node, structure);
}

function AmbientableNode(Base) {
    return class extends Base {
        hasDeclareKeyword() {
            return this.getDeclareKeyword() != null;
        }
        getDeclareKeywordOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getDeclareKeyword(), "Expected to find a declare keyword.");
        }
        getDeclareKeyword() {
            return this.getFirstModifierByKind(common.SyntaxKind.DeclareKeyword);
        }
        isAmbient() {
            return isNodeAmbientOrInAmbientContext(this);
        }
        setHasDeclareKeyword(value) {
            this.toggleModifier("declare", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasDeclareKeyword != null)
                this.setHasDeclareKeyword(structure.hasDeclareKeyword);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasDeclareKeyword: this.hasDeclareKeyword(),
            });
        }
    };
}

var FormattingKind;
(function (FormattingKind) {
    FormattingKind[FormattingKind["Newline"] = 0] = "Newline";
    FormattingKind[FormattingKind["Blankline"] = 1] = "Blankline";
    FormattingKind[FormattingKind["Space"] = 2] = "Space";
    FormattingKind[FormattingKind["None"] = 3] = "None";
})(FormattingKind || (FormattingKind = {}));

function getClassMemberFormatting(parent, member) {
    if (Node.isAmbientableNode(parent) && parent.isAmbient())
        return FormattingKind.Newline;
    if (hasBody$1(member))
        return FormattingKind.Blankline;
    return FormattingKind.Newline;
}
function hasBody$1(node) {
    if (Node.isBodyableNode(node) && node.getBody() != null)
        return true;
    if (Node.isBodiedNode(node))
        return true;
    return false;
}

function getFormattingKindText(formattingKind, opts) {
    switch (formattingKind) {
        case FormattingKind.Space:
            return " ";
        case FormattingKind.Newline:
            return opts.newLineKind;
        case FormattingKind.Blankline:
            return opts.newLineKind + opts.newLineKind;
        case FormattingKind.None:
            return "";
        default:
            throw new common.errors.NotImplementedError(`Not implemented formatting kind: ${formattingKind}`);
    }
}

function getInterfaceMemberFormatting(parent, member) {
    return FormattingKind.Newline;
}

function hasBody(node) {
    if (Node.isBodyableNode(node) && node.hasBody())
        return true;
    if (Node.isBodiedNode(node))
        return true;
    return Node.isInterfaceDeclaration(node) || Node.isClassDeclaration(node) || Node.isEnumDeclaration(node);
}

function getStatementedNodeChildFormatting(parent, member) {
    if (hasBody(member))
        return FormattingKind.Blankline;
    return FormattingKind.Newline;
}
function getClausedNodeChildFormatting(parent, member) {
    return FormattingKind.Newline;
}

function getGeneralFormatting(parent, child) {
    if (Node.isClassDeclaration(parent))
        return getClassMemberFormatting(parent, child);
    if (Node.isInterfaceDeclaration(parent))
        return getInterfaceMemberFormatting();
    return getStatementedNodeChildFormatting(parent, child);
}

function getTextFromTextChanges(sourceFile, textChanges) {
    const text = sourceFile.getFullText();
    const editResult = [];
    let start = 0;
    for (const { edit } of getSortedTextChanges()) {
        const span = edit.getSpan();
        const beforeEdit = text.slice(start, span.getStart());
        start = span.getEnd();
        editResult.push(beforeEdit);
        editResult.push(edit.getNewText());
    }
    editResult.push(text.slice(start));
    return editResult.join("");
    function getSortedTextChanges() {
        return textChanges.map((edit, index) => ({ edit: toWrappedTextChange(edit), index })).sort((a, b) => {
            const aStart = a.edit.getSpan().getStart();
            const bStart = b.edit.getSpan().getStart();
            const difference = aStart - bStart;
            if (difference === 0)
                return a.index < b.index ? -1 : 1;
            return difference < 0 ? -1 : 1;
        });
    }
    function toWrappedTextChange(change) {
        if (change instanceof TextChange)
            return change;
        else
            return new TextChange(change);
    }
}

function getNewInsertCode(opts) {
    var _a;
    const { structures, newCodes, parent, getSeparator, previousFormattingKind, nextFormattingKind } = opts;
    const indentationText = (_a = opts.indentationText) !== null && _a !== void 0 ? _a : parent.getChildIndentationText();
    const newLineKind = parent._context.manipulationSettings.getNewLineKindAsString();
    return getFormattingKindTextWithIndent(previousFormattingKind) + getChildCode() + getFormattingKindTextWithIndent(nextFormattingKind);
    function getChildCode() {
        let code = newCodes[0];
        for (let i = 1; i < newCodes.length; i++) {
            const formattingKind = getSeparator(structures[i - 1], structures[i]);
            code += getFormattingKindTextWithIndent(formattingKind);
            code += newCodes[i];
        }
        return code;
    }
    function getFormattingKindTextWithIndent(formattingKind) {
        let code = getFormattingKindText(formattingKind, { newLineKind });
        if (formattingKind === FormattingKind.Newline || formattingKind === FormattingKind.Blankline)
            code += indentationText;
        return code;
    }
}

const scanner = common.ts.createScanner(common.ts.ScriptTarget.Latest, true);
function appendCommaToText(text) {
    const pos = getAppendCommaPos(text);
    if (pos === -1)
        return text;
    return text.substring(0, pos) + "," + text.substring(pos);
}
function getAppendCommaPos(text) {
    scanner.setText(text);
    try {
        if (scanner.scan() === common.ts.SyntaxKind.EndOfFileToken)
            return -1;
        while (scanner.scan() !== common.ts.SyntaxKind.EndOfFileToken) {
        }
        const pos = scanner.getStartPos();
        return text[pos - 1] === "," ? -1 : pos;
    }
    finally {
        scanner.setText(undefined);
    }
}

function getEndIndexFromArray(array) {
    var _a;
    return (_a = array === null || array === void 0 ? void 0 : array.length) !== null && _a !== void 0 ? _a : 0;
}

function getNextMatchingPos(text, pos, condition) {
    while (pos < text.length) {
        const charCode = text.charCodeAt(pos);
        if (!condition(charCode))
            pos++;
        else
            break;
    }
    return pos;
}

function getPreviousMatchingPos(text, pos, condition) {
    while (pos > 0) {
        const charCode = text.charCodeAt(pos - 1);
        if (!condition(charCode))
            pos--;
        else
            break;
    }
    return pos;
}

function getNextNonWhitespacePos(text, pos) {
    return getNextMatchingPos(text, pos, isNotWhitespace);
}
function getPreviousNonWhitespacePos(text, pos) {
    return getPreviousMatchingPos(text, pos, isNotWhitespace);
}
function isNotWhitespace(charCode) {
    return !common.StringUtils.isWhitespaceCharCode(charCode);
}

function getPosAtEndOfPreviousLine(fullText, pos) {
    while (pos > 0) {
        pos--;
        if (fullText[pos] === "\n") {
            if (fullText[pos - 1] === "\r")
                return pos - 1;
            return pos;
        }
    }
    return pos;
}

function getPosAtNextNonBlankLine(text, pos) {
    let newPos = pos;
    for (let i = pos; i < text.length; i++) {
        if (text[i] === " " || text[i] === "\t")
            continue;
        if (text[i] === "\r" && text[i + 1] === "\n" || text[i] === "\n") {
            newPos = i + 1;
            if (text[i] === "\r") {
                i++;
                newPos++;
            }
            continue;
        }
        return newPos;
    }
    return newPos;
}

function getPosAtStartOfLineOrNonWhitespace(fullText, pos) {
    while (pos > 0) {
        pos--;
        const currentChar = fullText[pos];
        if (currentChar === "\n")
            return pos + 1;
        else if (currentChar !== " " && currentChar !== "\t")
            return pos + 1;
    }
    return pos;
}

function getInsertPosFromIndex(index, syntaxList, children) {
    if (index === 0) {
        const parent = syntaxList.getParentOrThrow();
        if (Node.isSourceFile(parent))
            return 0;
        else if (Node.isCaseClause(parent) || Node.isDefaultClause(parent)) {
            const colonToken = parent.getFirstChildByKindOrThrow(common.SyntaxKind.ColonToken);
            return colonToken.getEnd();
        }
        const isInline = syntaxList !== parent.getChildSyntaxList();
        if (isInline)
            return syntaxList.getStart();
        const parentContainer = getParentContainerOrThrow(parent);
        const openBraceToken = parentContainer.getFirstChildByKindOrThrow(common.SyntaxKind.OpenBraceToken);
        return openBraceToken.getEnd();
    }
    else {
        return children[index - 1].getEnd();
    }
}
function getEndPosFromIndex(index, parent, children, fullText) {
    let endPos;
    if (index === children.length) {
        if (Node.isSourceFile(parent))
            endPos = parent.getEnd();
        else if (Node.isCaseClause(parent) || Node.isDefaultClause(parent))
            endPos = parent.getEnd();
        else {
            const parentContainer = getParentContainerOrThrow(parent);
            const closeBraceToken = parentContainer.getLastChildByKind(common.SyntaxKind.CloseBraceToken);
            if (closeBraceToken == null)
                endPos = parent.getEnd();
            else
                endPos = closeBraceToken.getStart();
        }
    }
    else {
        endPos = children[index].getNonWhitespaceStart();
    }
    return getPosAtStartOfLineOrNonWhitespace(fullText, endPos);
}
function getParentContainerOrThrow(parent) {
    if (Node.isModuleDeclaration(parent)) {
        const innerBody = parent._getInnerBody();
        if (innerBody == null)
            throw new common.errors.InvalidOperationError("This operation requires the module to have a body.");
        return innerBody;
    }
    else if (Node.isBodiedNode(parent))
        return parent.getBody();
    else if (Node.isBodyableNode(parent))
        return parent.getBodyOrThrow();
    else
        return parent;
}

function fromAbstractableNode(node) {
    return {
        isAbstract: node.isAbstract(),
    };
}
function fromAmbientableNode(node) {
    return {
        hasDeclareKeyword: node.hasDeclareKeyword(),
    };
}
function fromExportableNode(node) {
    return {
        isDefaultExport: node.hasDefaultKeyword(),
        isExported: node.hasExportKeyword(),
    };
}
function fromStaticableNode(node) {
    return {
        isStatic: node.isStatic(),
    };
}
function fromScopedNode(node) {
    return {
        scope: node.hasScopeKeyword() ? node.getScope() : undefined,
    };
}
function fromOverrideableNode(node) {
    return {
        hasOverrideKeyword: node.hasOverrideKeyword(),
    };
}
function fromQuestionTokenableNode(node) {
    return {
        hasQuestionToken: node.hasQuestionToken(),
    };
}

function getNodesToReturn(oldChildren, newChildren, index, allowCommentNodes) {
    const oldChildCount = typeof oldChildren === "number" ? oldChildren : oldChildren.length;
    const newLength = newChildren.length - oldChildCount;
    const result = [];
    for (let i = 0; i < newLength; i++) {
        const currentChild = newChildren[index + i];
        if (allowCommentNodes || !Node.isCommentNode(currentChild))
            result.push(currentChild);
    }
    return result;
}

function getRangeWithoutCommentsFromArray(array, index, length, expectedKind) {
    const children = [];
    while (index < array.length && children.length < length) {
        const child = array[index];
        const childKind = child.getKind();
        if (childKind !== common.SyntaxKind.SingleLineCommentTrivia && childKind !== common.SyntaxKind.MultiLineCommentTrivia) {
            if (childKind !== expectedKind) {
                throw new common.errors.NotImplementedError(`Unexpected! Inserting syntax kind of ${common.getSyntaxKindName(expectedKind)}`
                    + `, but ${child.getKindName()} was inserted.`);
            }
            children.push(child);
        }
        index++;
    }
    if (children.length !== length)
        throw new common.errors.NotImplementedError(`Unexpected! Inserted ${length} child/children, but ${children.length} were inserted.`);
    return children;
}

function fromConstructorDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromScopedNode(node));
    return structure;
}
function fromMethodDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromStaticableNode(node));
    common.ObjectUtils.assign(structure, fromAbstractableNode(node));
    common.ObjectUtils.assign(structure, fromScopedNode(node));
    common.ObjectUtils.assign(structure, fromQuestionTokenableNode(node));
    common.ObjectUtils.assign(structure, fromOverrideableNode(node));
    return structure;
}
function fromFunctionDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromAmbientableNode(node));
    common.ObjectUtils.assign(structure, fromExportableNode(node));
    return structure;
}

function verifyAndGetIndex(index, length) {
    const newIndex = index < 0 ? length + index : index;
    if (newIndex < 0)
        throw new common.errors.InvalidOperationError(`Invalid index: The max negative index is ${length * -1}, but ${index} was specified.`);
    if (index > length)
        throw new common.errors.InvalidOperationError(`Invalid index: The max index is ${length}, but ${index} was specified.`);
    return newIndex;
}

exports.CommentNodeKind = void 0;
(function (CommentNodeKind) {
    CommentNodeKind[CommentNodeKind["Statement"] = 0] = "Statement";
    CommentNodeKind[CommentNodeKind["ClassElement"] = 1] = "ClassElement";
    CommentNodeKind[CommentNodeKind["TypeElement"] = 2] = "TypeElement";
    CommentNodeKind[CommentNodeKind["ObjectLiteralElement"] = 3] = "ObjectLiteralElement";
    CommentNodeKind[CommentNodeKind["EnumMember"] = 4] = "EnumMember";
})(exports.CommentNodeKind || (exports.CommentNodeKind = {}));
class CompilerCommentNode {
    constructor(fullStart, pos, end, kind, sourceFile, parent) {
        this._fullStart = fullStart;
        this._start = pos;
        this._sourceFile = sourceFile;
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.flags = common.ts.NodeFlags.None;
        this.parent = parent;
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getChildCount(sourceFile) {
        return 0;
    }
    getChildAt(index, sourceFile) {
        return undefined;
    }
    getChildren(sourceFile) {
        return [];
    }
    getStart(sourceFile, includeJsDocComment) {
        return this._start;
    }
    getFullStart() {
        return this._fullStart;
    }
    getEnd() {
        return this.end;
    }
    getWidth(sourceFile) {
        return this.end - this._start;
    }
    getFullWidth() {
        return this.end - this._fullStart;
    }
    getLeadingTriviaWidth(sourceFile) {
        return this._start - this._fullStart;
    }
    getFullText(sourceFile) {
        return this._sourceFile.text.substring(this._fullStart, this.end);
    }
    getText(sourceFile) {
        return this._sourceFile.text.substring(this._start, this.end);
    }
    getFirstToken(sourceFile) {
        return undefined;
    }
    getLastToken(sourceFile) {
        return undefined;
    }
    forEachChild(cbNode, cbNodeArray) {
        return undefined;
    }
}
class CompilerCommentStatement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.Statement;
    }
}
class CompilerCommentClassElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.ClassElement;
    }
}
class CompilerCommentTypeElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.TypeElement;
    }
}
class CompilerCommentObjectLiteralElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.ObjectLiteralElement;
    }
}
class CompilerCommentEnumMember extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.EnumMember;
    }
}

var CommentKind;
(function (CommentKind) {
    CommentKind[CommentKind["SingleLine"] = 0] = "SingleLine";
    CommentKind[CommentKind["MultiLine"] = 1] = "MultiLine";
    CommentKind[CommentKind["JsDoc"] = 2] = "JsDoc";
})(CommentKind || (CommentKind = {}));
const childrenSaver = new WeakMap();
const commentNodeParserKinds = new Set([
    common.SyntaxKind.SourceFile,
    common.SyntaxKind.Block,
    common.SyntaxKind.ModuleBlock,
    common.SyntaxKind.CaseClause,
    common.SyntaxKind.DefaultClause,
    common.SyntaxKind.ClassDeclaration,
    common.SyntaxKind.InterfaceDeclaration,
    common.SyntaxKind.EnumDeclaration,
    common.SyntaxKind.ClassExpression,
    common.SyntaxKind.TypeLiteral,
    common.SyntaxKind.ObjectLiteralExpression,
]);
class CommentNodeParser {
    constructor() {
    }
    static getOrParseChildren(container, sourceFile) {
        if (isSyntaxList(container))
            container = container.parent;
        let children = childrenSaver.get(container);
        if (children == null) {
            children = Array.from(getNodes(container, sourceFile));
            childrenSaver.set(container, children);
        }
        return children;
    }
    static shouldParseChildren(container) {
        return commentNodeParserKinds.has(container.kind)
            && container.pos !== container.end;
    }
    static hasParsedChildren(container) {
        if (isSyntaxList(container))
            container = container.parent;
        return childrenSaver.has(container);
    }
    static isCommentStatement(node) {
        return node._commentKind === exports.CommentNodeKind.Statement;
    }
    static isCommentClassElement(node) {
        return node._commentKind === exports.CommentNodeKind.ClassElement;
    }
    static isCommentTypeElement(node) {
        return node._commentKind === exports.CommentNodeKind.TypeElement;
    }
    static isCommentObjectLiteralElement(node) {
        return node._commentKind === exports.CommentNodeKind.ObjectLiteralElement;
    }
    static isCommentEnumMember(node) {
        return node._commentKind === exports.CommentNodeKind.EnumMember;
    }
    static getContainerBodyPos(container, sourceFile) {
        if (common.ts.isSourceFile(container))
            return 0;
        if (common.ts.isClassDeclaration(container)
            || common.ts.isEnumDeclaration(container)
            || common.ts.isInterfaceDeclaration(container)
            || common.ts.isTypeLiteralNode(container)
            || common.ts.isClassExpression(container)
            || common.ts.isBlock(container)
            || common.ts.isModuleBlock(container)
            || common.ts.isObjectLiteralExpression(container)) {
            return getTokenEnd(container, common.SyntaxKind.OpenBraceToken);
        }
        if (common.ts.isCaseClause(container) || common.ts.isDefaultClause(container))
            return getTokenEnd(container, common.SyntaxKind.ColonToken);
        return common.errors.throwNotImplementedForNeverValueError(container);
        function getTokenEnd(node, kind) {
            var _a;
            return (_a = node.getChildren(sourceFile).find(c => c.kind === kind)) === null || _a === void 0 ? void 0 : _a.end;
        }
    }
}
function* getNodes(container, sourceFile) {
    const sourceFileText = sourceFile.text;
    const childNodes = getContainerChildren();
    const createComment = getCreationFunction();
    if (childNodes.length === 0) {
        const bodyStartPos = CommentNodeParser.getContainerBodyPos(container, sourceFile);
        if (bodyStartPos != null)
            yield* getCommentNodes(bodyStartPos, false);
    }
    else {
        for (const childNode of childNodes) {
            yield* getCommentNodes(childNode.pos, true);
            yield childNode;
        }
        const lastChild = childNodes[childNodes.length - 1];
        yield* getCommentNodes(lastChild.end, false);
    }
    function* getCommentNodes(pos, stopAtJsDoc) {
        const fullStart = pos;
        skipTrailingLine();
        const leadingComments = Array.from(getLeadingComments());
        const maxEnd = sourceFileText.length === pos || sourceFileText[pos] === "}" ? pos : common.StringUtils.getLineStartFromPos(sourceFileText, pos);
        for (const leadingComment of leadingComments) {
            if (leadingComment.end <= maxEnd)
                yield leadingComment;
        }
        function skipTrailingLine() {
            if (pos === 0)
                return;
            let lineEnd = common.StringUtils.getLineEndFromPos(sourceFileText, pos);
            while (pos < lineEnd) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const comment = parseForComment(commentKind);
                    if (comment.kind === common.SyntaxKind.SingleLineCommentTrivia)
                        return;
                    else
                        lineEnd = common.StringUtils.getLineEndFromPos(sourceFileText, pos);
                }
                else if (!common.StringUtils.isWhitespace(sourceFileText[pos]) && sourceFileText[pos] !== ",")
                    return;
                else
                    pos++;
            }
            while (common.StringUtils.startsWithNewLine(sourceFileText[pos]))
                pos++;
        }
        function* getLeadingComments() {
            while (pos < sourceFileText.length) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const isJsDoc = commentKind === CommentKind.JsDoc;
                    if (isJsDoc && stopAtJsDoc)
                        return;
                    else
                        yield parseForComment(commentKind);
                    skipTrailingLine();
                }
                else if (!common.StringUtils.isWhitespace(sourceFileText[pos]))
                    return;
                else
                    pos++;
            }
        }
        function parseForComment(commentKind) {
            if (commentKind === CommentKind.SingleLine)
                return parseSingleLineComment();
            const isJsDoc = commentKind === CommentKind.JsDoc;
            return parseMultiLineComment(isJsDoc);
        }
        function getCommentKind() {
            const currentChar = sourceFileText[pos];
            if (currentChar !== "/")
                return undefined;
            const nextChar = sourceFileText[pos + 1];
            if (nextChar === "/")
                return CommentKind.SingleLine;
            if (nextChar !== "*")
                return undefined;
            const nextNextChar = sourceFileText[pos + 2];
            return nextNextChar === "*" ? CommentKind.JsDoc : CommentKind.MultiLine;
        }
        function parseSingleLineComment() {
            const start = pos;
            skipSingleLineComment();
            const end = pos;
            return createComment(fullStart, start, end, common.SyntaxKind.SingleLineCommentTrivia);
        }
        function skipSingleLineComment() {
            pos += 2;
            while (pos < sourceFileText.length && sourceFileText[pos] !== "\n" && sourceFileText[pos] !== "\r")
                pos++;
        }
        function parseMultiLineComment(isJsDoc) {
            const start = pos;
            skipSlashStarComment(isJsDoc);
            const end = pos;
            return createComment(fullStart, start, end, common.SyntaxKind.MultiLineCommentTrivia);
        }
        function skipSlashStarComment(isJsDoc) {
            pos += isJsDoc ? 3 : 2;
            while (pos < sourceFileText.length) {
                if (sourceFileText[pos] === "*" && sourceFileText[pos + 1] === "/") {
                    pos += 2;
                    break;
                }
                pos++;
            }
        }
    }
    function getContainerChildren() {
        if (common.ts.isSourceFile(container) || common.ts.isBlock(container) || common.ts.isModuleBlock(container) || common.ts.isCaseClause(container) || common.ts.isDefaultClause(container))
            return container.statements;
        if (common.ts.isClassDeclaration(container)
            || common.ts.isClassExpression(container)
            || common.ts.isEnumDeclaration(container)
            || common.ts.isInterfaceDeclaration(container)
            || common.ts.isTypeLiteralNode(container)
            || common.ts.isClassExpression(container)) {
            return container.members;
        }
        if (common.ts.isObjectLiteralExpression(container))
            return container.properties;
        return common.errors.throwNotImplementedForNeverValueError(container);
    }
    function getCreationFunction() {
        const ctor = getCtor();
        return (fullStart, pos, end, kind) => new ctor(fullStart, pos, end, kind, sourceFile, container);
        function getCtor() {
            if (isStatementContainerNode(container))
                return CompilerCommentStatement;
            if (common.ts.isClassLike(container))
                return CompilerCommentClassElement;
            if (common.ts.isInterfaceDeclaration(container) || common.ts.isTypeLiteralNode(container))
                return CompilerCommentTypeElement;
            if (common.ts.isObjectLiteralExpression(container))
                return CompilerCommentObjectLiteralElement;
            if (common.ts.isEnumDeclaration(container))
                return CompilerCommentEnumMember;
            throw new common.errors.NotImplementedError(`Not implemented comment node container type: ${common.getSyntaxKindName(container.kind)}`);
        }
    }
}
function isSyntaxList(node) {
    return node.kind === common.SyntaxKind.SyntaxList;
}
function isStatementContainerNode(node) {
    return getStatementContainerNode() != null;
    function getStatementContainerNode() {
        const container = node;
        if (common.ts.isSourceFile(container)
            || common.ts.isBlock(container)
            || common.ts.isModuleBlock(container)
            || common.ts.isCaseClause(container)
            || common.ts.isDefaultClause(container)) {
            return container;
        }
        return undefined;
    }
}

function hasParsedTokens(node) {
    return node._children != null;
}

const forEachChildSaver = new WeakMap();
const getChildrenSaver = new WeakMap();
class ExtendedParser {
    static getContainerArray(container, sourceFile) {
        return CommentNodeParser.getOrParseChildren(container, sourceFile);
    }
    static getCompilerChildrenFast(node, sourceFile) {
        if (hasParsedTokens(node))
            return ExtendedParser.getCompilerChildren(node, sourceFile);
        return ExtendedParser.getCompilerForEachChildren(node, sourceFile);
    }
    static getCompilerForEachChildren(node, sourceFile) {
        if (CommentNodeParser.shouldParseChildren(node)) {
            let result = forEachChildSaver.get(node);
            if (result == null) {
                result = getForEachChildren();
                mergeInComments(result, CommentNodeParser.getOrParseChildren(node, sourceFile));
                forEachChildSaver.set(node, result);
            }
            return result;
        }
        return getForEachChildren();
        function getForEachChildren() {
            const children = [];
            node.forEachChild(child => {
                children.push(child);
            });
            return children;
        }
    }
    static getCompilerChildren(node, sourceFile) {
        if (isStatementMemberOrPropertyHoldingSyntaxList()) {
            let result = getChildrenSaver.get(node);
            if (result == null) {
                result = [...node.getChildren(sourceFile)];
                mergeInComments(result, CommentNodeParser.getOrParseChildren(node, sourceFile));
                getChildrenSaver.set(node, result);
            }
            return result;
        }
        return node.getChildren(sourceFile);
        function isStatementMemberOrPropertyHoldingSyntaxList() {
            if (node.kind !== common.ts.SyntaxKind.SyntaxList)
                return false;
            const parent = node.parent;
            if (!CommentNodeParser.shouldParseChildren(parent))
                return false;
            return CommentNodeParser.getContainerBodyPos(parent, sourceFile) === node.pos;
        }
    }
}
function mergeInComments(nodes, otherNodes) {
    let currentIndex = 0;
    for (const child of otherNodes) {
        if (child.kind !== common.SyntaxKind.SingleLineCommentTrivia && child.kind !== common.SyntaxKind.MultiLineCommentTrivia)
            continue;
        while (currentIndex < nodes.length && nodes[currentIndex].end < child.end)
            currentIndex++;
        nodes.splice(currentIndex, 0, child);
        currentIndex++;
    }
}

function isComment(node) {
    return node.kind === common.ts.SyntaxKind.SingleLineCommentTrivia
        || node.kind === common.ts.SyntaxKind.MultiLineCommentTrivia;
}

class NodeHandlerHelper {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
    }
    handleForValues(handler, currentNode, newNode, newSourceFile) {
        if (this.compilerFactory.hasCompilerNode(currentNode))
            handler.handleNode(this.compilerFactory.getExistingNodeFromCompilerNode(currentNode), newNode, newSourceFile);
        else if (currentNode.kind === common.SyntaxKind.SyntaxList) {
            const sourceFile = this.compilerFactory.getExistingNodeFromCompilerNode(currentNode.getSourceFile());
            handler.handleNode(this.compilerFactory.getNodeFromCompilerNode(currentNode, sourceFile), newNode, newSourceFile);
        }
    }
    forgetNodeIfNecessary(currentNode) {
        if (this.compilerFactory.hasCompilerNode(currentNode))
            this.compilerFactory.getExistingNodeFromCompilerNode(currentNode).forget();
    }
    getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile) {
        const children = this.getCompilerChildren(currentNode, newNode, newSourceFile);
        return [
            new AdvancedIterator(common.ArrayUtils.toIterator(children[0])),
            new AdvancedIterator(common.ArrayUtils.toIterator(children[1])),
        ];
    }
    getCompilerChildren(currentNode, newNode, newSourceFile) {
        const currentCompilerNode = currentNode.compilerNode;
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        return [
            ExtendedParser.getCompilerChildren(currentCompilerNode, currentSourceFile),
            ExtendedParser.getCompilerChildren(newNode, newSourceFile),
        ];
    }
    getChildrenFast(currentNode, newNode, newSourceFile) {
        const currentCompilerNode = currentNode.compilerNode;
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        if (hasParsedTokens(currentCompilerNode)) {
            return [
                ExtendedParser.getCompilerChildren(currentCompilerNode, currentSourceFile),
                ExtendedParser.getCompilerChildren(newNode, newSourceFile),
            ];
        }
        return [
            ExtendedParser.getCompilerForEachChildren(currentCompilerNode, currentSourceFile),
            ExtendedParser.getCompilerForEachChildren(newNode, newSourceFile),
        ];
    }
}

class StraightReplacementNodeHandler {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (currentNode.getKind() !== newNode.kind) {
            throw new common.errors.InvalidOperationError(`Error replacing tree! Perhaps a syntax error was inserted `
                + `(Current: ${currentNode.getKindName()} -- New: ${common.getSyntaxKindName(newNode.kind)}).`);
        }
        if (currentNode._hasWrappedChildren())
            this.handleChildren(currentNode, newNode, newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleChildren(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        if (currentChildren.length !== newChildren.length) {
            throw new Error(`Error replacing tree: The children of the old and new trees were expected to have the `
                + `same count (${currentChildren.length}:${newChildren.length}).`);
        }
        for (let i = 0; i < currentChildren.length; i++)
            this.helper.handleForValues(this, currentChildren[i], newChildren[i], newSourceFile);
    }
}

class ChangeChildOrderParentHandler {
    constructor(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.oldIndex = opts.oldIndex;
        this.newIndex = opts.newIndex;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildren(currentNode, newNode, newSourceFile);
        const currentChildrenInNewOrder = this.getChildrenInNewOrder(currentChildren);
        common.errors.throwIfNotEqual(newChildren.length, currentChildrenInNewOrder.length, "New children length should match the old children length.");
        for (let i = 0; i < newChildren.length; i++)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildrenInNewOrder[i], newChildren[i], newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    getChildrenInNewOrder(children) {
        const result = [...children];
        const movingNode = result.splice(this.oldIndex, 1)[0];
        result.splice(this.newIndex, 0, movingNode);
        return result;
    }
}

class DefaultParentHandler {
    constructor(compilerFactory, opts) {
        var _a;
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.childCount = opts.childCount;
        this.isFirstChild = opts.isFirstChild;
        this.replacingNodes = (_a = opts.replacingNodes) === null || _a === void 0 ? void 0 : _a.map(n => n.compilerNode);
        this.customMappings = opts.customMappings;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        let count = this.childCount;
        this.handleCustomMappings(newNode);
        while (!currentChildren.done && !newChildren.done && !this.isFirstChild(currentChildren.peek, newChildren.peek))
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        while (!currentChildren.done && this.tryReplaceNode(currentChildren.peek))
            currentChildren.next();
        if (count > 0) {
            while (count > 0) {
                newChildren.next();
                count--;
            }
        }
        else if (count < 0) {
            while (count < 0) {
                this.helper.forgetNodeIfNecessary(currentChildren.next());
                count++;
            }
        }
        while (!currentChildren.done)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        if (!newChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleCustomMappings(newParentNode) {
        if (this.customMappings == null)
            return;
        const customMappings = this.customMappings(newParentNode);
        for (const mapping of customMappings)
            this.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);
    }
    tryReplaceNode(currentCompilerNode) {
        if (this.replacingNodes == null || this.replacingNodes.length === 0)
            return false;
        const index = this.replacingNodes.indexOf(currentCompilerNode);
        if (index === -1)
            return false;
        this.replacingNodes.splice(index, 1);
        this.helper.forgetNodeIfNecessary(currentCompilerNode);
        return true;
    }
}

class ForgetChangedNodeHandler {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (currentNode.getKind() !== newNode.kind) {
            currentNode.forget();
            return;
        }
        if (currentNode._hasWrappedChildren())
            this.handleChildren(currentNode, newNode, newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleChildren(currentNode, newNode, newSourceFile) {
        const [currentNodeChildren, newNodeChildrenArray] = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        const newNodeChildren = common.ArrayUtils.toIterator(newNodeChildrenArray);
        for (const currentNodeChild of currentNodeChildren) {
            const nextNodeChildResult = newNodeChildren.next();
            if (nextNodeChildResult.done) {
                const existingNode = this.compilerFactory.getExistingNodeFromCompilerNode(currentNodeChild);
                if (existingNode != null)
                    existingNode.forget();
            }
            else {
                this.helper.handleForValues(this, currentNodeChild, nextNodeChildResult.value, newSourceFile);
            }
        }
    }
}

class ParentFinderReplacementNodeHandler extends StraightReplacementNodeHandler {
    constructor(compilerFactory, parentNodeHandler, changingParent) {
        super(compilerFactory);
        this.parentNodeHandler = parentNodeHandler;
        this.changingParent = changingParent;
        this.foundParent = false;
        this.changingParentParent = this.changingParent.getParentSyntaxList() || this.changingParent.getParent();
        this.parentsAtSamePos = this.changingParentParent != null && this.changingParentParent.getPos() === this.changingParent.getPos();
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (!this.foundParent && this.isParentNode(newNode, newSourceFile)) {
            this.foundParent = true;
            this.parentNodeHandler.handleNode(currentNode, newNode, newSourceFile);
        }
        else {
            super.handleNode(currentNode, newNode, newSourceFile);
        }
    }
    isParentNode(newNode, newSourceFile) {
        const positionsAndKindsEqual = areNodesEqual(newNode, this.changingParent)
            && areNodesEqual(getParentSyntaxList(newNode, newSourceFile) || newNode.parent, this.changingParentParent);
        if (!positionsAndKindsEqual)
            return false;
        if (!this.parentsAtSamePos)
            return true;
        return getAncestorLength(this.changingParent.compilerNode) === getAncestorLength(newNode);
        function getAncestorLength(nodeToCheck) {
            let node = nodeToCheck;
            let count = 0;
            while (node.parent != null) {
                count++;
                node = node.parent;
            }
            return count;
        }
    }
}
function areNodesEqual(a, b) {
    if (a == null && b == null)
        return true;
    if (a == null || b == null)
        return false;
    if (a.pos === b.getPos() && a.kind === b.getKind())
        return true;
    return false;
}

class RangeHandler {
    constructor(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        const children = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        const currentNodeChildren = new AdvancedIterator(common.ArrayUtils.toIterator(children[0]));
        const newNodeChildren = new AdvancedIterator(common.ArrayUtils.toIterator(children[1]));
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        while (!currentNodeChildren.done && !newNodeChildren.done
            && (currentNodeChildren.peek.getStart(currentSourceFile) < this.start
                || currentNodeChildren.peek.getStart(currentSourceFile) === this.start && newNodeChildren.peek.end > this.end)) {
            this.rangeHandlerReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        }
        while (!newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.end)
            newNodeChildren.next();
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    straightReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    }
    rangeHandlerReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this, currentNode, nextNode, newSourceFile);
    }
}

class RangeParentHandler {
    constructor(compilerFactory, opts) {
        var _a;
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
        this.replacingLength = opts.replacingLength;
        this.replacingNodes = (_a = opts.replacingNodes) === null || _a === void 0 ? void 0 : _a.map(n => n.compilerNode);
        this.customMappings = opts.customMappings;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        const [currentNodeChildren, newNodeChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        this.handleCustomMappings(newNode, newSourceFile);
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getStart(newSourceFile) < this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        const newNodes = [];
        while (!newNodeChildren.done && newNodeChildren.peek.getStart(newSourceFile) >= this.start
            && getRealEnd(newNodeChildren.peek, newSourceFile) <= this.end) {
            newNodes.push(newNodeChildren.next());
        }
        if (this.replacingLength != null) {
            const replacingEnd = this.start + this.replacingLength;
            const oldNodes = [];
            while (!currentNodeChildren.done
                && (getRealEnd(currentNodeChildren.peek, currentSourceFile) <= replacingEnd
                    || currentNodeChildren.peek.getStart(currentSourceFile) < replacingEnd)) {
                oldNodes.push(currentNodeChildren.next());
            }
            if (oldNodes.length === newNodes.length && oldNodes.every((node, i) => node.kind === newNodes[i].kind)) {
                for (let i = 0; i < oldNodes.length; i++) {
                    const node = this.compilerFactory.getExistingNodeFromCompilerNode(oldNodes[i]);
                    if (node != null) {
                        node.forgetDescendants();
                        this.compilerFactory.replaceCompilerNode(oldNodes[i], newNodes[i]);
                    }
                }
            }
            else {
                oldNodes.forEach(node => this.helper.forgetNodeIfNecessary(node));
            }
        }
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleCustomMappings(newParentNode, newSourceFile) {
        if (this.customMappings == null)
            return;
        const customMappings = this.customMappings(newParentNode, newSourceFile);
        for (const mapping of customMappings)
            mapping.currentNode._context.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);
    }
    straightReplace(currentNode, nextNode, newSourceFile) {
        if (!this.tryReplaceNode(currentNode))
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    }
    tryReplaceNode(currentCompilerNode) {
        if (this.replacingNodes == null || this.replacingNodes.length === 0)
            return false;
        const index = this.replacingNodes.indexOf(currentCompilerNode);
        if (index === -1)
            return false;
        this.replacingNodes.splice(index, 1);
        this.helper.forgetNodeIfNecessary(currentCompilerNode);
        return true;
    }
}
function getRealEnd(node, sourceFile) {
    if (node.kind >= common.ts.SyntaxKind.FirstJSDocNode && node.kind <= common.ts.SyntaxKind.LastJSDocNode) {
        return getPreviousMatchingPos(sourceFile.text, node.end, charCode => charCode !== CharCodes.ASTERISK && !common.StringUtils.isWhitespaceCharCode(charCode));
    }
    return node.end;
}

class RenameNodeHandler extends StraightReplacementNodeHandler {
    handleNode(currentNode, newNode, newSourceFile) {
        const currentNodeKind = currentNode.getKind();
        const newNodeKind = newNode.kind;
        if (currentNodeKind === common.SyntaxKind.ShorthandPropertyAssignment && newNodeKind === common.SyntaxKind.PropertyAssignment) {
            const currentSourceFile = currentNode.getSourceFile();
            const currentIdentifier = currentNode.getNameNode();
            const newIdentifier = newNode.initializer;
            this.compilerFactory.replaceCompilerNode(currentIdentifier, newIdentifier);
            currentNode.forget();
            this.compilerFactory.getNodeFromCompilerNode(newNode, currentSourceFile);
            return;
        }
        else if (currentNodeKind === common.SyntaxKind.ExportSpecifier && newNodeKind === common.SyntaxKind.ExportSpecifier
            && currentNode.compilerNode.propertyName == null && newNode.propertyName != null) {
            handleImportOrExportSpecifier(this.compilerFactory);
            return;
        }
        else if (currentNodeKind === common.SyntaxKind.ImportSpecifier && newNodeKind === common.SyntaxKind.ImportSpecifier
            && currentNode.compilerNode.propertyName == null && newNode.propertyName != null) {
            handleImportOrExportSpecifier(this.compilerFactory);
            return;
        }
        super.handleNode(currentNode, newNode, newSourceFile);
        return;
        function handleImportOrExportSpecifier(compilerFactory) {
            const currentIdentifier = currentNode.getNameNode();
            const newSpecifier = newNode;
            const newPropertyName = newSpecifier.propertyName;
            const newName = newSpecifier.name;
            const newIdentifier = newPropertyName.escapedText === currentIdentifier.compilerNode.escapedText ? newName : newPropertyName;
            compilerFactory.replaceCompilerNode(currentIdentifier, newIdentifier);
            compilerFactory.replaceCompilerNode(currentNode, newNode);
        }
    }
}

class TryOrForgetNodeHandler {
    constructor(handler) {
        this.handler = handler;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (!Node.isSourceFile(currentNode))
            throw new common.errors.InvalidOperationError(`Can only use a ${"TryOrForgetNodeHandler"} with a source file.`);
        try {
            this.handler.handleNode(currentNode, newNode, newSourceFile);
        }
        catch (ex) {
            currentNode._context.logger.warn("Could not replace tree, so forgetting all nodes instead. Message: " + ex);
            currentNode.getChildSyntaxListOrThrow().forget();
            currentNode._context.compilerFactory.replaceCompilerNode(currentNode, newNode);
        }
    }
}

class UnwrapParentHandler {
    constructor(compilerFactory, childIndex) {
        this.compilerFactory = compilerFactory;
        this.childIndex = childIndex;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        let index = 0;
        while (!currentChildren.done && !newChildren.done && index++ < this.childIndex)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        const currentChild = this.compilerFactory.getExistingNodeFromCompilerNode(currentChildren.next());
        const childSyntaxList = currentChild.getChildSyntaxListOrThrow();
        for (const child of ExtendedParser.getCompilerChildren(childSyntaxList.compilerNode, childSyntaxList._sourceFile.compilerNode))
            this.helper.handleForValues(this.straightReplacementNodeHandler, child, newChildren.next(), newSourceFile);
        forgetNodes(currentChild);
        function forgetNodes(node) {
            if (node === childSyntaxList) {
                node._forgetOnlyThis();
                return;
            }
            for (const child of node._getChildrenInCacheIterator())
                forgetNodes(child);
            node._forgetOnlyThis();
        }
        while (!currentChildren.done)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        if (!newChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
}

class NodeHandlerFactory {
    getDefault(opts) {
        const { parent: changingParent, isFirstChild, childCount, customMappings } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const replacingNodes = opts.replacingNodes == null ? undefined : [...opts.replacingNodes];
        const parentHandler = new DefaultParentHandler(compilerFactory, { childCount, isFirstChild, replacingNodes, customMappings });
        if (changingParent === sourceFile)
            return parentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
    }
    getForParentRange(opts) {
        const { parent: changingParent, start, end, replacingLength, replacingNodes, customMappings } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const parentHandler = new RangeParentHandler(compilerFactory, { start, end, replacingLength, replacingNodes, customMappings });
        if (changingParent === sourceFile)
            return parentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
    }
    getForRange(opts) {
        const { sourceFile, start, end } = opts;
        const compilerFactory = sourceFile._context.compilerFactory;
        return new RangeHandler(compilerFactory, { start, end });
    }
    getForChildIndex(opts) {
        const { parent, childIndex, childCount, replacingNodes, customMappings } = opts;
        const parentChildren = parent.getChildren();
        common.errors.throwIfOutOfRange(childIndex, [0, parentChildren.length], "opts.childIndex");
        if (childCount < 0)
            common.errors.throwIfOutOfRange(childCount, [childIndex - parentChildren.length, 0], "opts.childCount");
        let i = 0;
        const isFirstChild = () => i++ === childIndex;
        return this.getDefault({
            parent,
            isFirstChild,
            childCount,
            replacingNodes,
            customMappings,
        });
    }
    getForStraightReplacement(compilerFactory) {
        return new StraightReplacementNodeHandler(compilerFactory);
    }
    getForForgetChanged(compilerFactory) {
        return new ForgetChangedNodeHandler(compilerFactory);
    }
    getForRename(compilerFactory) {
        return new RenameNodeHandler(compilerFactory);
    }
    getForTryOrForget(handler) {
        return new TryOrForgetNodeHandler(handler);
    }
    getForChangingChildOrder(opts) {
        const { parent: changingParent, oldIndex, newIndex } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const changeChildOrderParentHandler = new ChangeChildOrderParentHandler(compilerFactory, { oldIndex, newIndex });
        if (changingParent === sourceFile)
            return changeChildOrderParentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, changeChildOrderParentHandler, changingParent);
    }
    getForUnwrappingNode(unwrappingNode) {
        const changingParent = unwrappingNode.getParentSyntaxList() || unwrappingNode.getParentOrThrow();
        const childIndex = unwrappingNode.getChildIndex();
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const unwrapParentHandler = new UnwrapParentHandler(compilerFactory, childIndex);
        if (changingParent === sourceFile)
            return unwrapParentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, unwrapParentHandler, changingParent);
    }
}

function getSpacingBetweenNodes(opts) {
    const { parent, previousSibling, nextSibling, newLineKind, getSiblingFormatting } = opts;
    if (previousSibling == null || nextSibling == null)
        return "";
    const previousSiblingFormatting = getSiblingFormatting(parent, previousSibling);
    const nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
    if (previousSiblingFormatting === FormattingKind.Blankline || nextSiblingFormatting === FormattingKind.Blankline)
        return newLineKind + newLineKind;
    else if (previousSiblingFormatting === FormattingKind.Newline || nextSiblingFormatting === FormattingKind.Newline)
        return newLineKind;
    else if (previousSiblingFormatting === FormattingKind.Space || nextSiblingFormatting === FormattingKind.Space)
        return " ";
    else
        return "";
}

class ChangingChildOrderTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { parent, oldIndex, newIndex, getSiblingFormatting } = this.opts;
        const children = parent.getChildren();
        const newLineKind = parent._context.manipulationSettings.getNewLineKindAsString();
        const movingNode = children[oldIndex];
        const fullText = parent._sourceFile.getFullText();
        const movingNodeStart = getPosAtNextNonBlankLine(fullText, movingNode.getPos());
        const movingNodeText = fullText.substring(movingNodeStart, movingNode.getEnd());
        const lowerIndex = Math.min(newIndex, oldIndex);
        const upperIndex = Math.max(newIndex, oldIndex);
        const childrenInNewOrder = getChildrenInNewOrder();
        const isParentSourceFile = Node.isSourceFile(parent.getParentOrThrow());
        let finalText = "";
        fillPrefixText();
        fillTextForIndex(lowerIndex);
        fillMiddleText();
        fillTextForIndex(upperIndex);
        fillSuffixText();
        return finalText;
        function getChildrenInNewOrder() {
            const result = [...children];
            result.splice(oldIndex, 1);
            result.splice(newIndex, 0, movingNode);
            return result;
        }
        function fillPrefixText() {
            finalText += fullText.substring(0, children[lowerIndex].getPos());
            if (lowerIndex === 0 && !isParentSourceFile)
                finalText += newLineKind;
        }
        function fillMiddleText() {
            let startPos;
            let endPos;
            if (lowerIndex === oldIndex) {
                startPos = getPosAtNextNonBlankLine(fullText, children[lowerIndex].getEnd());
                endPos = children[upperIndex].getEnd();
            }
            else {
                startPos = getPosAtNextNonBlankLine(fullText, children[lowerIndex].getPos());
                endPos = children[upperIndex].getPos();
            }
            finalText += fullText.substring(startPos, endPos);
        }
        function fillSuffixText() {
            if (children.length - 1 === upperIndex && !isParentSourceFile)
                finalText += newLineKind;
            finalText += fullText.substring(getPosAtNextNonBlankLine(fullText, children[upperIndex].getEnd()));
        }
        function fillTextForIndex(index) {
            if (index === oldIndex)
                fillSpacingForRemoval();
            else {
                fillSpacingBeforeInsertion();
                finalText += movingNodeText;
                fillSpacingAfterInsertion();
            }
        }
        function fillSpacingForRemoval() {
            if (oldIndex === 0 || oldIndex === children.length - 1)
                return;
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[oldIndex - 1],
                nextSibling: childrenInNewOrder[oldIndex],
            });
        }
        function fillSpacingBeforeInsertion() {
            if (newIndex === 0)
                return;
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[newIndex - 1],
                nextSibling: childrenInNewOrder[newIndex],
            });
        }
        function fillSpacingAfterInsertion() {
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[newIndex],
                nextSibling: childrenInNewOrder[newIndex + 1],
            });
        }
        function fillSpacingCommon(spacingOpts) {
            const spacing = getSpacingBetweenNodes({
                parent,
                getSiblingFormatting,
                newLineKind,
                previousSibling: spacingOpts.previousSibling,
                nextSibling: spacingOpts.nextSibling,
            });
            const twoNewLines = newLineKind + newLineKind;
            if (spacing === twoNewLines) {
                if (finalText.endsWith(twoNewLines))
                    return;
                else if (finalText.endsWith(newLineKind))
                    finalText += newLineKind;
                else
                    finalText += twoNewLines;
            }
            else if (spacing === newLineKind) {
                if (finalText.endsWith(newLineKind))
                    return;
                else
                    finalText += newLineKind;
            }
            else if (spacing === " ") {
                if (finalText.endsWith(" "))
                    return;
                else
                    finalText += " ";
            }
            else {
                finalText += spacing;
            }
        }
    }
    getTextForError(newText) {
        return newText;
    }
}

class FullReplacementTextManipulator {
    constructor(newText) {
        this.newText = newText;
    }
    getNewText(inputText) {
        return this.newText;
    }
    getTextForError(newText) {
        return newText;
    }
}

function getTextForError(newText, pos, length = 0) {
    const startPos = Math.max(0, newText.lastIndexOf("\n", pos) - 100);
    let endPos = Math.min(newText.length, newText.indexOf("\n", pos + length));
    endPos = endPos === -1 ? newText.length : Math.min(newText.length, endPos + 100);
    let text = "";
    text += newText.substring(startPos, endPos);
    if (startPos !== 0)
        text = "..." + text;
    if (endPos !== newText.length)
        text += "...";
    return text;
}

class InsertionTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { insertPos, newText, replacingLength = 0 } = this.opts;
        return inputText.substring(0, insertPos) + newText + inputText.substring(insertPos + replacingLength);
    }
    getTextForError(newText) {
        return getTextForError(newText, this.opts.insertPos, this.opts.newText.length);
    }
}

class RemoveChildrenTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const opts = this.opts;
        const { children, removePrecedingSpaces = false, removeFollowingSpaces = false, removePrecedingNewLines = false, removeFollowingNewLines = false, replaceTrivia = "", } = opts;
        const sourceFile = children[0].getSourceFile();
        const fullText = sourceFile.getFullText();
        const removalPos = getRemovalPos();
        this.removalPos = removalPos;
        return getPrefix() + replaceTrivia + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (opts.customRemovalPos != null)
                return opts.customRemovalPos;
            const pos = children[0].getNonWhitespaceStart();
            if (removePrecedingSpaces || removePrecedingNewLines)
                return getPreviousMatchingPos(fullText, pos, getCharRemovalFunction(removePrecedingSpaces, removePrecedingNewLines));
            return pos;
        }
        function getRemovalEnd() {
            if (opts.customRemovalEnd != null)
                return opts.customRemovalEnd;
            const end = children[children.length - 1].getEnd();
            if (removeFollowingSpaces || removeFollowingNewLines)
                return getNextMatchingPos(fullText, end, getCharRemovalFunction(removeFollowingSpaces, removeFollowingNewLines));
            return end;
        }
        function getCharRemovalFunction(removeSpaces, removeNewLines) {
            return (char) => {
                if (removeNewLines && (char === CharCodes.CARRIAGE_RETURN || char === CharCodes.NEWLINE))
                    return false;
                if (removeSpaces && !charNotSpaceOrTab(char))
                    return false;
                return true;
            };
        }
        function charNotSpaceOrTab(charCode) {
            return charCode !== CharCodes.SPACE && charCode !== CharCodes.TAB;
        }
    }
    getTextForError(newText) {
        return getTextForError(newText, this.removalPos);
    }
}

function isNewLineAtPos(fullText, pos) {
    return fullText[pos] === "\n" || (fullText[pos] === "\r" && fullText[pos + 1] === "\n");
}
function hasNewLineInRange(fullText, range) {
    for (let i = range[0]; i < range[1]; i++) {
        if (fullText[i] === "\n")
            return true;
    }
    return false;
}

class RemoveChildrenWithFormattingTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { children, getSiblingFormatting } = this.opts;
        const firstChild = children[0];
        const lastChild = children[children.length - 1];
        const parent = firstChild.getParentOrThrow();
        const sourceFile = parent.getSourceFile();
        const fullText = sourceFile.getFullText();
        const newLineKind = sourceFile._context.manipulationSettings.getNewLineKindAsString();
        const previousSibling = firstChild.getPreviousSibling();
        const nextSibling = lastChild.getNextSibling();
        const removalPos = getRemovalPos();
        this.removalPos = removalPos;
        return getPrefix() + getSpacing() + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSpacing() {
            return getSpacingBetweenNodes({
                parent,
                previousSibling,
                nextSibling,
                newLineKind,
                getSiblingFormatting,
            });
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (previousSibling != null) {
                const trailingEnd = previousSibling.getTrailingTriviaEnd();
                return isNewLineAtPos(fullText, trailingEnd) ? trailingEnd : previousSibling.getEnd();
            }
            const firstPos = getPreviousNonWhitespacePos(fullText, firstChild.getPos());
            if (parent.getPos() === firstPos)
                return firstChild.getNonWhitespaceStart();
            return firstChild.isFirstNodeOnLine() ? firstPos : firstChild.getNonWhitespaceStart();
        }
        function getRemovalEnd() {
            const triviaEnd = lastChild.getTrailingTriviaEnd();
            if (previousSibling != null && nextSibling != null) {
                const nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
                if (nextSiblingFormatting === FormattingKind.Blankline || nextSiblingFormatting === FormattingKind.Newline)
                    return getPosAtStartOfLineOrNonWhitespace(fullText, nextSibling.getNonWhitespaceStart());
                return nextSibling.getNonWhitespaceStart();
            }
            if (parent.getEnd() === lastChild.getEnd())
                return lastChild.getEnd();
            if (isNewLineAtPos(fullText, triviaEnd)) {
                if (previousSibling == null && firstChild.getPos() === 0)
                    return getPosAtNextNonBlankLine(fullText, triviaEnd);
                return getPosAtEndOfPreviousLine(fullText, getPosAtNextNonBlankLine(fullText, triviaEnd));
            }
            if (previousSibling == null)
                return triviaEnd;
            else
                return lastChild.getEnd();
        }
    }
    getTextForError(newText) {
        return getTextForError(newText, this.removalPos);
    }
}

class RenameLocationTextManipulator {
    constructor(renameLocations, newName) {
        this.renameLocations = renameLocations;
        this.newName = newName;
    }
    getNewText(inputText) {
        const renameLocations = [...this.renameLocations].sort((a, b) => b.getTextSpan().getStart() - a.getTextSpan().getStart());
        let currentPos = inputText.length;
        let result = "";
        for (let i = 0; i < renameLocations.length; i++) {
            const renameLocation = renameLocations[i];
            const textSpan = renameLocation.getTextSpan();
            result = (renameLocation.getPrefixText() || "")
                + this.newName
                + (renameLocation.getSuffixText() || "")
                + inputText.substring(textSpan.getEnd(), currentPos)
                + result;
            currentPos = textSpan.getStart();
        }
        return inputText.substring(0, currentPos) + result;
    }
    getTextForError(newText) {
        if (this.renameLocations.length === 0)
            return newText;
        return "..." + newText.substring(this.renameLocations[0].getTextSpan().getStart());
    }
}

class UnchangedTextManipulator {
    getNewText(inputText) {
        return inputText;
    }
    getTextForError(newText) {
        return newText;
    }
}

class UnwrapTextManipulator extends InsertionTextManipulator {
    constructor(node) {
        super({
            insertPos: node.getStart(true),
            newText: getReplacementText(node),
            replacingLength: node.getWidth(true),
        });
    }
}
function getReplacementText(node) {
    const sourceFile = node._sourceFile;
    const range = getInnerBraceRange();
    const startPos = range[0];
    const text = sourceFile.getFullText().substring(range[0], range[1]);
    return common.StringUtils.indent(text, -1, {
        indentText: sourceFile._context.manipulationSettings.getIndentationText(),
        indentSizeInSpaces: sourceFile._context.manipulationSettings._getIndentSizeInSpaces(),
        isInStringAtPos: pos => sourceFile.isInStringAtPos(startPos + pos),
    }).trim();
    function getInnerBraceRange() {
        const bodyNode = getBodyNodeOrThrow();
        return [bodyNode.getStart() + 1, bodyNode.getEnd() - 1];
        function getBodyNodeOrThrow() {
            if (Node.isModuleDeclaration(node)) {
                const bodyNode = node._getInnerBody();
                if (bodyNode == null)
                    throw new common.errors.InvalidOperationError("This operation requires the module to have a body.");
                return bodyNode;
            }
            else if (Node.isBodiedNode(node))
                return node.getBody();
            else if (Node.isBodyableNode(node))
                return node.getBodyOrThrow();
            else
                throw new common.errors.NotImplementedError(`Not implemented unwrap scenario for ${node.getKindName()}.`);
        }
    }
}

class ManipulationError extends common.errors.InvalidOperationError {
    constructor(filePath, oldText, newText, errorMessage) {
        super(errorMessage);
        this.filePath = filePath;
        this.oldText = oldText;
        this.newText = newText;
    }
}

function doManipulation(sourceFile, textManipulator, nodeHandler, newFilePath) {
    sourceFile._firePreModified();
    const oldFileText = sourceFile.getFullText();
    const newFileText = textManipulator.getNewText(oldFileText);
    try {
        const replacementSourceFile = sourceFile._context.compilerFactory.createCompilerSourceFileFromText(newFilePath || sourceFile.getFilePath(), newFileText, sourceFile.getScriptKind());
        nodeHandler.handleNode(sourceFile, replacementSourceFile, replacementSourceFile);
    }
    catch (err) {
        const diagnostics = getSyntacticDiagnostics(sourceFile, newFileText);
        const errorDetails = err.message + "\n\n"
            + `-- Details --\n`
            + "Path: " + sourceFile.getFilePath() + "\n"
            + "Text: " + JSON.stringify(textManipulator.getTextForError(newFileText)) + "\n"
            + "Stack: " + err.stack;
        if (diagnostics.length > 0) {
            throwError("Manipulation error: " + "A syntax error was inserted." + "\n\n"
                + sourceFile._context.project.formatDiagnosticsWithColorAndContext(diagnostics, { newLineChar: "\n" })
                + "\n" + errorDetails);
        }
        throwError("Manipulation error: " + errorDetails);
        function throwError(message) {
            throw new ManipulationError(sourceFile.getFilePath(), oldFileText, newFileText, message);
        }
    }
}
function getSyntacticDiagnostics(sourceFile, newText) {
    try {
        const projectOptions = { useInMemoryFileSystem: true };
        const project = new sourceFile._context.project.constructor(projectOptions);
        const newFile = project.createSourceFile(sourceFile.getFilePath(), newText);
        return project.getProgram().getSyntacticDiagnostics(newFile);
    }
    catch (err) {
        return [];
    }
}

function insertIntoParentTextRange(opts) {
    var _a, _b, _c;
    const { insertPos, newText, parent } = opts;
    doManipulation(parent._sourceFile, new InsertionTextManipulator({
        insertPos,
        newText,
        replacingLength: (_a = opts.replacing) === null || _a === void 0 ? void 0 : _a.textLength,
    }), new NodeHandlerFactory().getForParentRange({
        parent,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength: (_b = opts.replacing) === null || _b === void 0 ? void 0 : _b.textLength,
        replacingNodes: (_c = opts.replacing) === null || _c === void 0 ? void 0 : _c.nodes,
        customMappings: opts.customMappings,
    }));
}
function insertIntoTextRange(opts) {
    const { insertPos, newText, sourceFile } = opts;
    doManipulation(sourceFile, new InsertionTextManipulator({
        insertPos,
        newText,
    }), new NodeHandlerFactory().getForRange({
        sourceFile,
        start: insertPos,
        end: insertPos + newText.length,
    }));
}
function insertIntoCommaSeparatedNodes(opts) {
    const { currentNodes, insertIndex, parent } = opts;
    const previousNode = currentNodes[insertIndex - 1];
    const previousNonCommentNode = getPreviousNonCommentNode();
    const nextNode = currentNodes[insertIndex];
    const nextNonCommentNode = getNextNonCommentNode();
    const separator = opts.useNewLines ? parent._context.manipulationSettings.getNewLineKindAsString() : " ";
    const parentNextSibling = parent.getNextSibling();
    const isContained = parentNextSibling != null && (parentNextSibling.getKind() === common.SyntaxKind.CloseBraceToken || parentNextSibling.getKind() === common.SyntaxKind.CloseBracketToken);
    let { newText } = opts;
    if (previousNode != null) {
        prependCommaAndSeparator();
        if (nextNonCommentNode != null || opts.useTrailingCommas)
            appendCommaAndSeparator();
        else if (opts.useNewLines || opts.surroundWithSpaces)
            appendSeparator();
        else
            appendIndentation();
        const nextEndStart = nextNode == null ? (isContained ? parentNextSibling.getStart(true) : parent.getEnd()) : nextNode.getStart(true);
        const insertPos = (previousNonCommentNode || previousNode).getEnd();
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextEndStart - insertPos },
        });
    }
    else if (nextNode != null) {
        if (opts.useNewLines || opts.surroundWithSpaces)
            prependSeparator();
        if (nextNonCommentNode != null || opts.useTrailingCommas)
            appendCommaAndSeparator();
        else
            appendSeparator();
        const insertPos = isContained ? parent.getPos() : parent.getStart(true);
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextNode.getStart(true) - insertPos },
        });
    }
    else {
        if (opts.useNewLines || opts.surroundWithSpaces) {
            prependSeparator();
            if (opts.useTrailingCommas)
                appendCommaAndSeparator();
            else
                appendSeparator();
        }
        else {
            appendIndentation();
        }
        insertIntoParentTextRange({
            insertPos: parent.getPos(),
            newText,
            parent,
            replacing: { textLength: parent.getNextSiblingOrThrow().getStart() - parent.getPos() },
        });
    }
    function prependCommaAndSeparator() {
        if (previousNonCommentNode == null) {
            prependSeparator();
            return;
        }
        const originalSourceFileText = parent.getSourceFile().getFullText();
        const previousNodeNextSibling = previousNonCommentNode.getNextSibling();
        let text = "";
        if (previousNodeNextSibling != null && previousNodeNextSibling.getKind() === common.SyntaxKind.CommaToken) {
            appendNodeTrailingCommentRanges(previousNonCommentNode);
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNodeNextSibling);
            else
                appendCommentNodeTexts();
        }
        else {
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNonCommentNode);
            else
                appendCommentNodeTexts();
        }
        prependSeparator();
        newText = text + newText;
        function appendCommentNodeTexts() {
            const lastCommentRangeEnd = getLastCommentRangeEnd(previousNode) || previousNode.getEnd();
            text += originalSourceFileText.substring(previousNonCommentNode.getEnd(), lastCommentRangeEnd);
        }
        function appendNodeTrailingCommentRanges(node) {
            const lastCommentRangeEnd = getLastCommentRangeEnd(node);
            if (lastCommentRangeEnd == null)
                return;
            text += originalSourceFileText.substring(node.getEnd(), lastCommentRangeEnd);
        }
        function getLastCommentRangeEnd(node) {
            const commentRanges = node.getTrailingCommentRanges();
            const lastCommentRange = commentRanges[commentRanges.length - 1];
            return lastCommentRange === null || lastCommentRange === void 0 ? void 0 : lastCommentRange.getEnd();
        }
    }
    function getPreviousNonCommentNode() {
        for (let i = insertIndex - 1; i >= 0; i--) {
            if (!Node.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function getNextNonCommentNode() {
        for (let i = insertIndex; i < currentNodes.length; i++) {
            if (!Node.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function prependSeparator() {
        if (!common.StringUtils.startsWithNewLine(newText))
            newText = separator + newText;
    }
    function appendCommaAndSeparator() {
        newText = appendCommaToText(newText);
        appendSeparator();
    }
    function appendSeparator() {
        if (!common.StringUtils.endsWithNewLine(newText))
            newText += separator;
        appendIndentation();
    }
    function appendIndentation() {
        if (opts.useNewLines || common.StringUtils.endsWithNewLine(newText)) {
            if (nextNode != null)
                newText += parent.getParentOrThrow().getChildIndentationText();
            else
                newText += parent.getParentOrThrow().getIndentationText();
        }
    }
}
function insertIntoBracesOrSourceFile(opts) {
    const { parent, index, children } = opts;
    const fullText = parent._sourceFile.getFullText();
    const childSyntaxList = parent.getChildSyntaxListOrThrow();
    const insertPos = getInsertPosFromIndex(index, childSyntaxList, children);
    const endPos = getEndPosFromIndex(index, parent, children, fullText);
    const replacingLength = endPos - insertPos;
    const newText = getNewText();
    doManipulation(parent._sourceFile, new InsertionTextManipulator({ insertPos, replacingLength, newText }), new NodeHandlerFactory().getForParentRange({
        parent: childSyntaxList,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength,
    }));
    function getNewText() {
        const writer = parent._getWriterWithChildIndentation();
        opts.write(writer, {
            previousMember: getChild(children[index - 1]),
            nextMember: getChild(children[index]),
            isStartOfFile: insertPos === 0,
        });
        return writer.toString();
        function getChild(child) {
            if (child == null)
                return child;
            else if (Node.isOverloadableNode(child))
                return child.getImplementation() || child;
            else
                return child;
        }
    }
}
function insertIntoBracesOrSourceFileWithGetChildren(opts) {
    if (opts.structures.length === 0)
        return [];
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = verifyAndGetIndex(opts.index, startChildren.length);
    const previousJsDocCount = getPreviousJsDocCount();
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write,
    });
    return getRangeWithoutCommentsFromArray(opts.getIndexedChildren(), opts.index - previousJsDocCount, opts.structures.length, opts.expectedKind);
    function getChildIndex() {
        if (index === 0)
            return 0;
        return startChildren[index - 1].getChildIndex() + 1;
    }
    function getPreviousJsDocCount() {
        let commentCount = 0;
        let count = 0;
        for (let i = index - 1; i >= 0; i--) {
            const node = startChildren[i];
            if (Node.isCommentNode(node)) {
                commentCount++;
                if (node.getText().startsWith("/**"))
                    count = commentCount;
            }
            else {
                break;
            }
        }
        return count;
    }
}
function insertIntoBracesOrSourceFileWithGetChildrenWithComments(opts) {
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = verifyAndGetIndex(opts.index, startChildren.length);
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write,
    });
    return getNodesToReturn(startChildren, opts.getIndexedChildren(), index, true);
    function getChildIndex() {
        if (index === 0)
            return 0;
        return startChildren[index - 1].getChildIndex() + 1;
    }
}

function changeChildOrder(opts) {
    const { parent } = opts;
    doManipulation(parent._sourceFile, new ChangingChildOrderTextManipulator(opts), new NodeHandlerFactory().getForChangingChildOrder(opts));
}

function removeChildren(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    doManipulation(children[0].getSourceFile(), new RemoveChildrenTextManipulator(opts), new NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length,
    }));
}
function removeChildrenWithFormattingFromCollapsibleSyntaxList(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    const syntaxList = children[0].getParentSyntaxListOrThrow();
    if (syntaxList.getChildCount() === children.length) {
        removeChildrenWithFormatting({
            children: [syntaxList],
            getSiblingFormatting: () => FormattingKind.None,
        });
    }
    else {
        removeChildrenWithFormatting(opts);
    }
}
function removeChildrenWithFormatting(opts) {
    const { children, getSiblingFormatting } = opts;
    if (children.length === 0)
        return;
    doManipulation(children[0]._sourceFile, new RemoveChildrenWithFormattingTextManipulator({
        children,
        getSiblingFormatting,
    }), new NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length,
    }));
}
function removeClassMember(classMember) {
    if (Node.isOverloadableNode(classMember)) {
        if (classMember.isImplementation())
            removeClassMembers([...classMember.getOverloads(), classMember]);
        else {
            const parent = classMember.getParentOrThrow();
            if (Node.isAmbientableNode(parent) && parent.isAmbient())
                removeClassMembers([classMember]);
            else
                removeChildren({ children: [classMember], removeFollowingSpaces: true, removeFollowingNewLines: true });
        }
    }
    else {
        removeClassMembers([classMember]);
    }
}
function removeClassMembers(classMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getClassMemberFormatting,
        children: classMembers,
    });
}
function removeInterfaceMember(interfaceMember) {
    removeInterfaceMembers([interfaceMember]);
}
function removeInterfaceMembers(interfaceMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getInterfaceMemberFormatting,
        children: interfaceMembers,
    });
}
function removeCommaSeparatedChild(child) {
    const childrenToRemove = [child];
    const syntaxList = child.getParentSyntaxListOrThrow();
    const isRemovingFirstChild = childrenToRemove[0] === syntaxList.getFirstChild();
    addNextCommaIfAble();
    addPreviousCommaIfAble();
    removeChildren({
        children: childrenToRemove,
        removePrecedingSpaces: !isRemovingFirstChild || syntaxList.getChildren().length === childrenToRemove.length && childrenToRemove[0].isFirstNodeOnLine(),
        removeFollowingSpaces: isRemovingFirstChild,
        removePrecedingNewLines: !isRemovingFirstChild,
        removeFollowingNewLines: isRemovingFirstChild,
    });
    function addNextCommaIfAble() {
        const commaToken = child.getNextSiblingIfKind(common.SyntaxKind.CommaToken);
        if (commaToken != null)
            childrenToRemove.push(commaToken);
    }
    function addPreviousCommaIfAble() {
        if (syntaxList.getLastChild() !== childrenToRemove[childrenToRemove.length - 1])
            return;
        const precedingComma = child.getPreviousSiblingIfKind(common.SyntaxKind.CommaToken);
        if (precedingComma != null)
            childrenToRemove.unshift(precedingComma);
    }
}
function removeOverloadableStatementedNodeChild(node) {
    if (node.isOverload())
        removeChildren({ children: [node], removeFollowingSpaces: true, removeFollowingNewLines: true });
    else
        removeStatementedNodeChildren([...node.getOverloads(), node]);
}
function removeStatementedNodeChild(node) {
    removeStatementedNodeChildren([node]);
}
function removeStatementedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getStatementedNodeChildFormatting,
        children: nodes,
    });
}
function removeClausedNodeChild(node) {
    removeClausedNodeChildren([node]);
}
function removeClausedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getClausedNodeChildFormatting,
        children: nodes,
    });
}
function unwrapNode(node) {
    doManipulation(node._sourceFile, new UnwrapTextManipulator(node), new NodeHandlerFactory().getForUnwrappingNode(node));
}

function replaceNodeText(opts) {
    doManipulation(opts.sourceFile, new InsertionTextManipulator({
        insertPos: opts.start,
        newText: opts.newText,
        replacingLength: opts.replacingLength,
    }), new NodeHandlerFactory().getForForgetChanged(opts.sourceFile._context.compilerFactory));
}
function replaceSourceFileTextForFormatting(opts) {
    replaceSourceFileTextStraight(opts);
}
function replaceSourceFileTextStraight(opts) {
    const { sourceFile, newText } = opts;
    doManipulation(sourceFile, new FullReplacementTextManipulator(newText), new NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory));
}
function replaceSourceFileTextForRename(opts) {
    const { sourceFile, renameLocations, newName } = opts;
    const nodeHandlerFactory = new NodeHandlerFactory();
    doManipulation(sourceFile, new RenameLocationTextManipulator(renameLocations, newName), nodeHandlerFactory.getForTryOrForget(nodeHandlerFactory.getForRename(sourceFile._context.compilerFactory)));
}
function replaceTextPossiblyCreatingChildNodes(opts) {
    const { replacePos, replacingLength, newText, parent } = opts;
    doManipulation(parent._sourceFile, new InsertionTextManipulator({
        insertPos: replacePos,
        replacingLength,
        newText,
    }), new NodeHandlerFactory().getForParentRange({
        parent,
        start: replacePos,
        end: replacePos + newText.length,
    }));
}
function replaceSourceFileForFilePathMove(opts) {
    const { sourceFile, newFilePath } = opts;
    doManipulation(sourceFile, new UnchangedTextManipulator(), new NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory), newFilePath);
}
function replaceSourceFileForCacheUpdate(sourceFile) {
    replaceSourceFileForFilePathMove({ sourceFile, newFilePath: sourceFile.getFilePath() });
}

function ArgumentedNode(Base) {
    return class extends Base {
        getArguments() {
            var _a, _b;
            return (_b = (_a = this.compilerNode.arguments) === null || _a === void 0 ? void 0 : _a.map(a => this._getNodeFromCompilerNode(a))) !== null && _b !== void 0 ? _b : [];
        }
        addArgument(argumentText) {
            return this.addArguments([argumentText])[0];
        }
        addArguments(argumentTexts) {
            return this.insertArguments(this.getArguments().length, argumentTexts);
        }
        insertArgument(index, argumentText) {
            return this.insertArguments(index, [argumentText])[0];
        }
        insertArguments(index, argumentTexts) {
            if (argumentTexts instanceof Function)
                argumentTexts = [argumentTexts];
            if (common.ArrayUtils.isNullOrEmpty(argumentTexts))
                return [];
            this._addParensIfNecessary();
            const originalArgs = this.getArguments();
            index = verifyAndGetIndex(index, originalArgs.length);
            const writer = this._getWriterWithQueuedChildIndentation();
            for (let i = 0; i < argumentTexts.length; i++) {
                writer.conditionalWrite(i > 0, ", ");
                printTextFromStringOrWriter(writer, argumentTexts[i]);
            }
            insertIntoCommaSeparatedNodes({
                parent: this.getFirstChildByKindOrThrow(common.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(common.SyntaxKind.SyntaxList),
                currentNodes: originalArgs,
                insertIndex: index,
                newText: writer.toString(),
                useTrailingCommas: false,
            });
            return getNodesToReturn(originalArgs, this.getArguments(), index, false);
        }
        removeArgument(argOrIndex) {
            const args = this.getArguments();
            if (args.length === 0)
                throw new common.errors.InvalidOperationError("Cannot remove an argument when none exist.");
            const argToRemove = typeof argOrIndex === "number" ? getArgFromIndex(argOrIndex) : argOrIndex;
            removeCommaSeparatedChild(argToRemove);
            return this;
            function getArgFromIndex(index) {
                return args[verifyAndGetIndex(index, args.length - 1)];
            }
        }
        _addParensIfNecessary() {
            const fullText = this.getFullText();
            if (fullText[fullText.length - 1] !== ")") {
                insertIntoParentTextRange({
                    insertPos: this.getEnd(),
                    newText: "()",
                    parent: this,
                });
            }
        }
    };
}

function AsyncableNode(Base) {
    return class extends Base {
        isAsync() {
            return this.hasModifier(common.SyntaxKind.AsyncKeyword);
        }
        getAsyncKeyword() {
            return this.getFirstModifierByKind(common.SyntaxKind.AsyncKeyword);
        }
        getAsyncKeywordOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getAsyncKeyword(), "Expected to find an async keyword.");
        }
        setIsAsync(value) {
            this.toggleModifier("async", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isAsync != null)
                this.setIsAsync(structure.isAsync);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isAsync: this.isAsync(),
            });
        }
    };
}

function AwaitableNode(Base) {
    return class extends Base {
        isAwaited() {
            return this.compilerNode.awaitModifier != null;
        }
        getAwaitKeyword() {
            const awaitModifier = this.compilerNode.awaitModifier;
            return this._getNodeFromCompilerNodeIfExists(awaitModifier);
        }
        getAwaitKeywordOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getAwaitKeyword(), "Expected to find an await token.");
        }
        setIsAwaited(value) {
            const awaitModifier = this.getAwaitKeyword();
            const isSet = awaitModifier != null;
            if (isSet === value)
                return this;
            if (awaitModifier == null) {
                insertIntoParentTextRange({
                    insertPos: getAwaitInsertPos(this),
                    parent: this,
                    newText: " await",
                });
            }
            else {
                removeChildren({
                    children: [awaitModifier],
                    removePrecedingSpaces: true,
                });
            }
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isAwaited != null)
                this.setIsAwaited(structure.isAwaited);
            return this;
        }
    };
}
function getAwaitInsertPos(node) {
    if (node.getKind() === common.SyntaxKind.ForOfStatement)
        return node.getFirstChildByKindOrThrow(common.SyntaxKind.ForKeyword).getEnd();
    throw new common.errors.NotImplementedError("Expected a for of statement node.");
}

function getBodyText(writer, textOrWriterFunction) {
    writer.newLineIfLastNot();
    if (typeof textOrWriterFunction !== "string" || textOrWriterFunction.length > 0) {
        writer.indent(() => {
            printTextFromStringOrWriter(writer, textOrWriterFunction);
        });
    }
    writer.newLineIfLastNot();
    writer.write("");
    return writer.toString();
}

function getBodyTextWithoutLeadingIndentation(body) {
    const sourceFile = body._sourceFile;
    const textArea = body.getChildSyntaxList() || body;
    const startPos = textArea.getNonWhitespaceStart();
    const endPos = Math.max(startPos, textArea._getTrailingTriviaNonWhitespaceEnd());
    const width = endPos - startPos;
    if (width === 0)
        return "";
    const fullText = sourceFile.getFullText().substring(startPos, endPos);
    return common.StringUtils.removeIndentation(fullText, {
        indentSizeInSpaces: body._context.manipulationSettings._getIndentSizeInSpaces(),
        isInStringAtPos: pos => sourceFile.isInStringAtPos(pos + startPos),
    });
}

class TextRange {
    constructor(compilerObject, sourceFile) {
        this._compilerObject = compilerObject;
        this._sourceFile = sourceFile;
    }
    get compilerObject() {
        this._throwIfForgotten();
        return this._compilerObject;
    }
    getSourceFile() {
        this._throwIfForgotten();
        return this._sourceFile;
    }
    getPos() {
        return this.compilerObject.pos;
    }
    getEnd() {
        return this.compilerObject.end;
    }
    getWidth() {
        return this.getEnd() - this.getPos();
    }
    getText() {
        const fullText = this.getSourceFile().getFullText();
        return fullText.substring(this.compilerObject.pos, this.compilerObject.end);
    }
    _forget() {
        this._compilerObject = undefined;
        this._sourceFile = undefined;
    }
    wasForgotten() {
        return this._compilerObject == null;
    }
    _throwIfForgotten() {
        if (this._compilerObject != null)
            return;
        const message = "Attempted to get a text range that was forgotten. "
            + "Text ranges are forgotten after a manipulation has occurred. "
            + "Please re-request the text range after manipulations.";
        throw new common.errors.InvalidOperationError(message);
    }
}

class CommentRange extends TextRange {
    constructor(compilerObject, sourceFile) {
        super(compilerObject, sourceFile);
    }
    getKind() {
        return this.compilerObject.kind;
    }
}

class Node {
    constructor(context, node, sourceFile) {
        this._wrappedChildCount = 0;
        if (context == null || context.compilerFactory == null) {
            throw new common.errors.InvalidOperationError("Constructing a node is not supported. Please create a source file from the default export "
                + "of the package and manipulate the source file from there.");
        }
        this._context = context;
        this._compilerNode = node;
        this.__sourceFile = sourceFile;
    }
    get _sourceFile() {
        if (this.__sourceFile == null)
            throw new common.errors.InvalidOperationError("Operation cannot be performed on a node that has no source file.");
        return this.__sourceFile;
    }
    get compilerNode() {
        if (this._compilerNode == null) {
            let message = "Attempted to get information from a node that was removed or forgotten.";
            if (this._forgottenText != null)
                message += `\n\nNode text: ${this._forgottenText}`;
            throw new common.errors.InvalidOperationError(message);
        }
        return this._compilerNode;
    }
    forget() {
        if (this.wasForgotten())
            return;
        this.forgetDescendants();
        this._forgetOnlyThis();
    }
    forgetDescendants() {
        for (const child of this._getChildrenInCacheIterator())
            child.forget();
        return this;
    }
    _forgetOnlyThis() {
        if (this.wasForgotten())
            return;
        const parent = this.getParent();
        if (parent != null)
            parent._wrappedChildCount--;
        const parentSyntaxList = this._getParentSyntaxListIfWrapped();
        if (parentSyntaxList != null)
            parentSyntaxList._wrappedChildCount--;
        this._storeTextForForgetting();
        this._context.compilerFactory.removeNodeFromCache(this);
        this._clearInternals();
    }
    wasForgotten() {
        return this._compilerNode == null;
    }
    _hasWrappedChildren() {
        return this._wrappedChildCount > 0;
    }
    _replaceCompilerNodeFromFactory(compilerNode) {
        if (compilerNode == null)
            this._storeTextForForgetting();
        this._clearInternals();
        this._compilerNode = compilerNode;
    }
    _storeTextForForgetting() {
        const sourceFileCompilerNode = this._sourceFile && this._sourceFile.compilerNode;
        const compilerNode = this._compilerNode;
        if (sourceFileCompilerNode == null || compilerNode == null)
            return;
        this._forgottenText = getText();
        function getText() {
            const start = compilerNode.getStart(sourceFileCompilerNode);
            const length = compilerNode.end - start;
            const trimmedLength = Math.min(length, 100);
            const text = sourceFileCompilerNode.text.substr(start, trimmedLength);
            return trimmedLength !== length ? text + "..." : text;
        }
    }
    _clearInternals() {
        this._compilerNode = undefined;
        this._childStringRanges = undefined;
        clearTextRanges(this._leadingCommentRanges);
        clearTextRanges(this._trailingCommentRanges);
        delete this._leadingCommentRanges;
        delete this._trailingCommentRanges;
        function clearTextRanges(textRanges) {
            if (textRanges == null)
                return;
            textRanges.forEach(r => r._forget());
        }
    }
    getKind() {
        return this.compilerNode.kind;
    }
    getKindName() {
        return common.getSyntaxKindName(this.compilerNode.kind);
    }
    getFlags() {
        return this.compilerNode.flags;
    }
    print(options = {}) {
        if (options.newLineKind == null)
            options.newLineKind = this._context.manipulationSettings.getNewLineKind();
        if (this.getKind() === common.SyntaxKind.SourceFile)
            return printNode(this.compilerNode, options);
        else
            return printNode(this.compilerNode, this._sourceFile.compilerNode, options);
    }
    getSymbolOrThrow() {
        return common.errors.throwIfNullOrUndefined(this.getSymbol(), "Could not find the node's symbol.");
    }
    getSymbol() {
        const boundSymbol = this.compilerNode.symbol;
        if (boundSymbol != null)
            return this._context.compilerFactory.getSymbol(boundSymbol);
        const typeChecker = this._context.typeChecker;
        const typeCheckerSymbol = typeChecker.getSymbolAtLocation(this);
        if (typeCheckerSymbol != null)
            return typeCheckerSymbol;
        const nameNode = this.compilerNode.name;
        if (nameNode != null)
            return this._getNodeFromCompilerNode(nameNode).getSymbol();
        return undefined;
    }
    getSymbolsInScope(meaning) {
        return this._context.typeChecker.getSymbolsInScope(this, meaning);
    }
    getLocalOrThrow(name) {
        return common.errors.throwIfNullOrUndefined(this.getLocal(name), `Expected to find local symbol with name: ${name}`);
    }
    getLocal(name) {
        const locals = this._getCompilerLocals();
        if (locals == null)
            return undefined;
        const tsSymbol = locals.get(common.ts.escapeLeadingUnderscores(name));
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getLocals() {
        const locals = this._getCompilerLocals();
        if (locals == null)
            return [];
        return common.ArrayUtils.from(locals.values()).map(symbol => this._context.compilerFactory.getSymbol(symbol));
    }
    _getCompilerLocals() {
        this._ensureBound();
        return this.compilerNode.locals;
    }
    getType() {
        return this._context.typeChecker.getTypeAtLocation(this);
    }
    containsRange(pos, end) {
        return this.getPos() <= pos && end <= this.getEnd();
    }
    isInStringAtPos(pos) {
        common.errors.throwIfOutOfRange(pos, [this.getPos(), this.getEnd()], "pos");
        if (this._childStringRanges == null) {
            this._childStringRanges = [];
            for (const descendant of this._getCompilerDescendantsIterator()) {
                if (isStringKind(descendant.kind))
                    this._childStringRanges.push([descendant.getStart(this._sourceFile.compilerNode), descendant.getEnd()]);
            }
        }
        class InStringRangeComparer {
            compareTo(value) {
                if (pos <= value[0])
                    return -1;
                if (pos >= value[1] - 1)
                    return 1;
                return 0;
            }
        }
        return common.ArrayUtils.binarySearch(this._childStringRanges, new InStringRangeComparer()) !== -1;
    }
    asKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.asKind(kind), () => `Expected the node to be of kind ${common.getSyntaxKindName(kind)}, but it was ${common.getSyntaxKindName(this.getKind())}.`);
    }
    asKind(kind) {
        if (this.getKind() === kind) {
            return this;
        }
        else {
            return undefined;
        }
    }
    getFirstChildOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getFirstChild(condition), "Could not find a child that matched the specified condition.");
    }
    getFirstChild(condition) {
        const firstChild = this._getCompilerFirstChild(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(firstChild);
    }
    getLastChildOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getLastChild(condition), "Could not find a child that matched the specified condition.");
    }
    getLastChild(condition) {
        const lastChild = this._getCompilerLastChild(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(lastChild);
    }
    getFirstDescendantOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getFirstDescendant(condition), "Could not find a descendant that matched the specified condition.");
    }
    getFirstDescendant(condition) {
        for (const descendant of this._getDescendantsIterator()) {
            if (condition == null || condition(descendant))
                return descendant;
        }
        return undefined;
    }
    getPreviousSiblingOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getPreviousSibling(condition), "Could not find the previous sibling.");
    }
    getPreviousSibling(condition) {
        const previousSibling = this._getCompilerPreviousSibling(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(previousSibling);
    }
    getNextSiblingOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getNextSibling(condition), "Could not find the next sibling.");
    }
    getNextSibling(condition) {
        const nextSibling = this._getCompilerNextSibling(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(nextSibling);
    }
    getPreviousSiblings() {
        return this._getCompilerPreviousSiblings().map(n => this._getNodeFromCompilerNode(n));
    }
    getNextSiblings() {
        return this._getCompilerNextSiblings().map(n => this._getNodeFromCompilerNode(n));
    }
    getChildren() {
        return this._getCompilerChildren().map(n => this._getNodeFromCompilerNode(n));
    }
    getChildAtIndex(index) {
        return this._getNodeFromCompilerNode(this._getCompilerChildAtIndex(index));
    }
    *_getChildrenIterator() {
        for (const compilerChild of this._getCompilerChildren())
            yield this._getNodeFromCompilerNode(compilerChild);
    }
    *_getChildrenInCacheIterator() {
        const children = this._getCompilerChildrenFast();
        for (const child of children) {
            if (this._context.compilerFactory.hasCompilerNode(child))
                yield this._context.compilerFactory.getExistingNodeFromCompilerNode(child);
            else if (child.kind === common.SyntaxKind.SyntaxList) {
                yield this._getNodeFromCompilerNode(child);
            }
        }
    }
    getChildSyntaxListOrThrow() {
        return common.errors.throwIfNullOrUndefined(this.getChildSyntaxList(), "A child syntax list was expected.");
    }
    getChildSyntaxList() {
        let node = this;
        if (Node.isBodyableNode(node) || Node.isBodiedNode(node)) {
            do {
                const bodyNode = Node.isBodyableNode(node) ? node.getBody() : node.getBody();
                if (bodyNode == null)
                    return undefined;
                node = bodyNode;
            } while ((Node.isBodyableNode(node) || Node.isBodiedNode(node)) && node.compilerNode.statements == null);
        }
        if (Node.isSourceFile(node)
            || Node.isBodyableNode(this)
            || Node.isBodiedNode(this)
            || Node.isCaseBlock(this)
            || Node.isCaseClause(this)
            || Node.isDefaultClause(this)
            || Node.isJsxElement(this)) {
            return node.getFirstChildByKind(common.SyntaxKind.SyntaxList);
        }
        let passedBrace = false;
        for (const child of node._getCompilerChildren()) {
            if (!passedBrace)
                passedBrace = child.kind === common.SyntaxKind.OpenBraceToken;
            else if (child.kind === common.SyntaxKind.SyntaxList)
                return this._getNodeFromCompilerNode(child);
        }
        return undefined;
    }
    forEachChild(cbNode, cbNodeArray) {
        const snapshots = [];
        this.compilerNode.forEachChild(node => {
            snapshots.push(this._getNodeFromCompilerNode(node));
        }, cbNodeArray == null ? undefined : nodes => {
            snapshots.push(nodes.map(n => this._getNodeFromCompilerNode(n)));
        });
        for (const snapshot of snapshots) {
            if (snapshot instanceof Array) {
                const filteredNodes = snapshot.filter(n => !n.wasForgotten());
                if (filteredNodes.length > 0) {
                    const returnValue = cbNodeArray(filteredNodes);
                    if (returnValue)
                        return returnValue;
                }
            }
            else if (!snapshot.wasForgotten()) {
                const returnValue = cbNode(snapshot);
                if (returnValue)
                    return returnValue;
            }
        }
        return undefined;
    }
    forEachDescendant(cbNode, cbNodeArray) {
        const stopReturnValue = {};
        const upReturnValue = {};
        let stop = false;
        let up = false;
        const traversal = {
            stop: () => stop = true,
            up: () => up = true,
        };
        const nodeCallback = (node) => {
            if (stop)
                return stopReturnValue;
            let skip = false;
            const returnValue = cbNode(node, Object.assign(Object.assign({}, traversal), { skip: () => skip = true }));
            if (returnValue)
                return returnValue;
            if (stop)
                return stopReturnValue;
            if (skip || up)
                return undefined;
            if (!node.wasForgotten())
                return forEachChildForNode(node);
            return undefined;
        };
        const arrayCallback = cbNodeArray == null ? undefined : (nodes) => {
            if (stop)
                return stopReturnValue;
            let skip = false;
            const returnValue = cbNodeArray(nodes, Object.assign(Object.assign({}, traversal), { skip: () => skip = true }));
            if (returnValue)
                return returnValue;
            if (skip)
                return undefined;
            for (const node of nodes) {
                if (stop)
                    return stopReturnValue;
                if (up)
                    return undefined;
                const innerReturnValue = forEachChildForNode(node);
                if (innerReturnValue)
                    return innerReturnValue;
            }
            return undefined;
        };
        const finalResult = forEachChildForNode(this);
        return finalResult === stopReturnValue ? undefined : finalResult;
        function forEachChildForNode(node) {
            const result = node.forEachChild(innerNode => {
                const returnValue = nodeCallback(innerNode);
                if (up) {
                    up = false;
                    return returnValue || upReturnValue;
                }
                return returnValue;
            }, arrayCallback == null ? undefined : nodes => {
                const returnValue = arrayCallback(nodes);
                if (up) {
                    up = false;
                    return returnValue || upReturnValue;
                }
                return returnValue;
            });
            return result === upReturnValue ? undefined : result;
        }
    }
    forEachChildAsArray() {
        const children = [];
        this.compilerNode.forEachChild(child => {
            children.push(this._getNodeFromCompilerNode(child));
        });
        return children;
    }
    forEachDescendantAsArray() {
        const descendants = [];
        this.forEachDescendant(descendant => {
            descendants.push(descendant);
        });
        return descendants;
    }
    getDescendants() {
        return Array.from(this._getDescendantsIterator());
    }
    *_getDescendantsIterator() {
        for (const descendant of this._getCompilerDescendantsIterator())
            yield this._getNodeFromCompilerNode(descendant);
    }
    getDescendantStatements() {
        const statements = [];
        handleNode(this, this.compilerNode);
        return statements;
        function handleNode(thisNode, node) {
            if (handleStatements(thisNode, node))
                return;
            else if (node.kind === common.SyntaxKind.ArrowFunction) {
                const arrowFunction = node;
                if (arrowFunction.body.kind !== common.SyntaxKind.Block)
                    statements.push(thisNode._getNodeFromCompilerNode(arrowFunction.body));
                else
                    handleNode(thisNode, arrowFunction.body);
            }
            else {
                handleChildren(thisNode, node);
            }
        }
        function handleStatements(thisNode, node) {
            if (node.statements == null)
                return false;
            const statementedNode = thisNode._getNodeFromCompilerNode(node);
            for (const statement of statementedNode.getStatements()) {
                statements.push(statement);
                handleChildren(thisNode, statement.compilerNode);
            }
            return true;
        }
        function handleChildren(thisNode, node) {
            common.ts.forEachChild(node, childNode => handleNode(thisNode, childNode));
        }
    }
    getChildCount() {
        return this._getCompilerChildren().length;
    }
    getChildAtPos(pos) {
        if (pos < this.getPos() || pos >= this.getEnd())
            return undefined;
        for (const child of this._getCompilerChildren()) {
            if (pos >= child.pos && pos < child.end)
                return this._getNodeFromCompilerNode(child);
        }
        return undefined;
    }
    getDescendantAtPos(pos) {
        let node;
        while (true) {
            const nextNode = (node || this).getChildAtPos(pos);
            if (nextNode == null)
                return node;
            else
                node = nextNode;
        }
    }
    getDescendantAtStartWithWidth(start, width) {
        let foundNode;
        this._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
            let nextNode = this.getSourceFile();
            do {
                nextNode = nextNode.getChildAtPos(start);
                if (nextNode != null) {
                    if (nextNode.getStart() === start && nextNode.getWidth() === width)
                        foundNode = nextNode;
                    else if (foundNode != null)
                        break;
                }
            } while (nextNode != null);
            if (foundNode != null)
                remember(foundNode);
        });
        return foundNode;
    }
    getPos() {
        return this.compilerNode.pos;
    }
    getEnd() {
        return this.compilerNode.end;
    }
    getStart(includeJsDocComments) {
        return this.compilerNode.getStart(this._sourceFile.compilerNode, includeJsDocComments);
    }
    getFullStart() {
        return this.compilerNode.getFullStart();
    }
    getNonWhitespaceStart() {
        return this._context.compilerFactory.forgetNodesCreatedInBlock(() => {
            const parent = this.getParent();
            const pos = this.getPos();
            const parentTakesPrecedence = parent != null
                && !Node.isSourceFile(parent)
                && parent.getPos() === pos;
            if (parentTakesPrecedence)
                return this.getStart(true);
            let startSearchPos;
            const sourceFileFullText = this._sourceFile.getFullText();
            const previousSibling = this.getPreviousSibling();
            if (previousSibling != null && Node.isCommentNode(previousSibling))
                startSearchPos = previousSibling.getEnd();
            else if (previousSibling != null) {
                if (hasNewLineInRange(sourceFileFullText, [pos, this.getStart(true)]))
                    startSearchPos = previousSibling.getTrailingTriviaEnd();
                else
                    startSearchPos = pos;
            }
            else {
                startSearchPos = this.getPos();
            }
            return getNextNonWhitespacePos(sourceFileFullText, startSearchPos);
        });
    }
    _getTrailingTriviaNonWhitespaceEnd() {
        return getPreviousNonWhitespacePos(this._sourceFile.getFullText(), this.getTrailingTriviaEnd());
    }
    getWidth(includeJsDocComments) {
        return this.getEnd() - this.getStart(includeJsDocComments);
    }
    getFullWidth() {
        return this.compilerNode.getFullWidth();
    }
    getLeadingTriviaWidth() {
        return this.compilerNode.getLeadingTriviaWidth(this._sourceFile.compilerNode);
    }
    getTrailingTriviaWidth() {
        return this.getTrailingTriviaEnd() - this.getEnd();
    }
    getTrailingTriviaEnd() {
        const parent = this.getParent();
        const end = this.getEnd();
        if (parent == null)
            return end;
        const parentEnd = parent.getEnd();
        if (parentEnd === end)
            return end;
        const trailingComments = this.getTrailingCommentRanges();
        const searchStart = getSearchStart();
        return getNextMatchingPos(this._sourceFile.getFullText(), searchStart, char => char !== CharCodes.SPACE && char !== CharCodes.TAB);
        function getSearchStart() {
            return trailingComments.length > 0 ? trailingComments[trailingComments.length - 1].getEnd() : end;
        }
    }
    getText(includeJsDocCommentOrOptions) {
        const options = typeof includeJsDocCommentOrOptions === "object" ? includeJsDocCommentOrOptions : undefined;
        const includeJsDocComments = includeJsDocCommentOrOptions === true || (options != null && options.includeJsDocComments);
        const trimLeadingIndentation = options != null && options.trimLeadingIndentation;
        const startPos = this.getStart(includeJsDocComments);
        const text = this._sourceFile.getFullText().substring(startPos, this.getEnd());
        if (trimLeadingIndentation) {
            return common.StringUtils.removeIndentation(text, {
                isInStringAtPos: pos => this._sourceFile.isInStringAtPos(pos + startPos),
                indentSizeInSpaces: this._context.manipulationSettings._getIndentSizeInSpaces(),
            });
        }
        else {
            return text;
        }
    }
    getFullText() {
        return this.compilerNode.getFullText(this._sourceFile.compilerNode);
    }
    getCombinedModifierFlags() {
        return common.ts.getCombinedModifierFlags(this.compilerNode);
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getProject() {
        return this._context.project;
    }
    getNodeProperty(propertyName) {
        const property = this.compilerNode[propertyName];
        if (property == null)
            return undefined;
        else if (property instanceof Array)
            return property.map(p => isNode(p) ? this._getNodeFromCompilerNode(p) : p);
        else if (isNode(property))
            return this._getNodeFromCompilerNode(property);
        else
            return property;
        function isNode(value) {
            return typeof value.kind === "number" && typeof value.pos === "number" && typeof value.end === "number";
        }
    }
    getAncestors(includeSyntaxLists = false) {
        return Array.from(this._getAncestorsIterator(includeSyntaxLists));
    }
    *_getAncestorsIterator(includeSyntaxLists) {
        let parent = getParent(this);
        while (parent != null) {
            yield parent;
            parent = getParent(parent);
        }
        function getParent(node) {
            return includeSyntaxLists ? node.getParentSyntaxList() || node.getParent() : node.getParent();
        }
    }
    getParent() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.parent);
    }
    getParentOrThrow() {
        return common.errors.throwIfNullOrUndefined(this.getParent(), "Expected to find a parent.");
    }
    getParentWhileOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getParentWhile(condition), "The initial parent did not match the provided condition.");
    }
    getParentWhile(condition) {
        let node = undefined;
        let parent = this.getParent();
        while (parent && condition(parent, node || this)) {
            node = parent;
            parent = node.getParent();
        }
        return node;
    }
    getParentWhileKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getParentWhileKind(kind), `The initial parent was not a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getParentWhileKind(kind) {
        return this.getParentWhile(n => n.getKind() === kind);
    }
    getLastToken() {
        const lastToken = this.compilerNode.getLastToken(this._sourceFile.compilerNode);
        if (lastToken == null)
            throw new common.errors.NotImplementedError("Not implemented scenario where the last token does not exist.");
        return this._getNodeFromCompilerNode(lastToken);
    }
    isInSyntaxList() {
        return this.getParentSyntaxList() != null;
    }
    getParentSyntaxListOrThrow() {
        return common.errors.throwIfNullOrUndefined(this.getParentSyntaxList(), "Expected the parent to be a syntax list.");
    }
    getParentSyntaxList() {
        const kind = this.getKind();
        if (kind === common.SyntaxKind.SingleLineCommentTrivia || kind === common.SyntaxKind.MultiLineCommentTrivia)
            return this.getParentOrThrow().getChildSyntaxList();
        const syntaxList = getParentSyntaxList(this.compilerNode, this._sourceFile.compilerNode);
        return this._getNodeFromCompilerNodeIfExists(syntaxList);
    }
    _getParentSyntaxListIfWrapped() {
        const parent = this.getParent();
        if (parent == null || !hasParsedTokens(parent.compilerNode))
            return undefined;
        return this.getParentSyntaxList();
    }
    getChildIndex() {
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const index = parent._getCompilerChildren().indexOf(this.compilerNode);
        if (index === -1)
            throw new common.errors.NotImplementedError("For some reason the child's parent did not contain the child.");
        return index;
    }
    getIndentationLevel() {
        const indentationText = this._context.manipulationSettings.getIndentationText();
        return this._context.languageService.getIdentationAtPosition(this._sourceFile, this.getStart()) / indentationText.length;
    }
    getChildIndentationLevel() {
        if (Node.isSourceFile(this))
            return 0;
        return this.getIndentationLevel() + 1;
    }
    getIndentationText(offset = 0) {
        return this._getIndentationTextForLevel(this.getIndentationLevel() + offset);
    }
    getChildIndentationText(offset = 0) {
        return this._getIndentationTextForLevel(this.getChildIndentationLevel() + offset);
    }
    _getIndentationTextForLevel(level) {
        return this._context.manipulationSettings.getIndentationText().repeat(level);
    }
    getStartLinePos(includeJsDocComments) {
        const sourceFileText = this._sourceFile.getFullText();
        return getPreviousMatchingPos(sourceFileText, this.getStart(includeJsDocComments), char => char === CharCodes.NEWLINE || char === CharCodes.CARRIAGE_RETURN);
    }
    getStartLineNumber(includeJsDocComments) {
        return common.StringUtils.getLineNumberAtPos(this._sourceFile.getFullText(), this.getStartLinePos(includeJsDocComments));
    }
    getEndLineNumber() {
        const sourceFileText = this._sourceFile.getFullText();
        const endLinePos = getPreviousMatchingPos(sourceFileText, this.getEnd(), char => char === CharCodes.NEWLINE || char === CharCodes.CARRIAGE_RETURN);
        return common.StringUtils.getLineNumberAtPos(this._sourceFile.getFullText(), endLinePos);
    }
    isFirstNodeOnLine() {
        const sourceFileText = this._sourceFile.getFullText();
        const startPos = this.getNonWhitespaceStart();
        for (let i = startPos - 1; i >= 0; i--) {
            const currentChar = sourceFileText[i];
            if (currentChar === " " || currentChar === "\t")
                continue;
            if (currentChar === "\n")
                return true;
            return false;
        }
        return true;
    }
    replaceWithText(textOrWriterFunction, writer) {
        const newText = getTextFromStringOrWriter(writer || this._getWriterWithQueuedIndentation(), textOrWriterFunction);
        if (Node.isSourceFile(this)) {
            this.replaceText([this.getPos(), this.getEnd()], newText);
            return this;
        }
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const childIndex = this.getChildIndex();
        const start = this.getStart(true);
        insertIntoParentTextRange({
            parent,
            insertPos: start,
            newText,
            replacing: {
                textLength: this.getEnd() - start,
            },
        });
        return parent.getChildren()[childIndex];
    }
    prependWhitespace(textOrWriterFunction) {
        insertWhiteSpaceTextAtPos(this, this.getStart(true), textOrWriterFunction, "prependWhitespace");
    }
    appendWhitespace(textOrWriterFunction) {
        insertWhiteSpaceTextAtPos(this, this.getEnd(), textOrWriterFunction, "appendWhitespace");
    }
    formatText(settings = {}) {
        const formattingEdits = this._context.languageService.getFormattingEditsForRange(this._sourceFile.getFilePath(), [this.getStart(true), this.getEnd()], settings);
        replaceSourceFileTextForFormatting({
            sourceFile: this._sourceFile,
            newText: getTextFromTextChanges(this._sourceFile, formattingEdits),
        });
    }
    transform(visitNode) {
        const compilerFactory = this._context.compilerFactory;
        const printer = common.ts.createPrinter({
            newLine: this._context.manipulationSettings.getNewLineKind(),
            removeComments: false,
        });
        const transformations = [];
        const compilerSourceFile = this._sourceFile.compilerNode;
        const compilerNode = this.compilerNode;
        const transformerFactory = context => {
            return rootNode => innerVisit(rootNode, context);
        };
        common.ts.transform(compilerNode, [transformerFactory], this._context.compilerOptions.get());
        replaceSourceFileTextStraight({
            sourceFile: this._sourceFile,
            newText: getTransformedText(),
        });
        return this;
        function innerVisit(node, context) {
            const traversal = {
                visitChildren() {
                    node = common.ts.visitEachChild(node, child => innerVisit(child, context), context);
                    return node;
                },
                currentNode: node,
            };
            const resultNode = visitNode(traversal);
            handleTransformation(node, resultNode);
            return resultNode;
        }
        function handleTransformation(oldNode, newNode) {
            if (oldNode === newNode)
                return;
            const start = oldNode.getStart(compilerSourceFile, true);
            const end = oldNode.end;
            let lastTransformation;
            while ((lastTransformation = transformations[transformations.length - 1]) && lastTransformation.start > start)
                transformations.pop();
            const wrappedNode = compilerFactory.getExistingNodeFromCompilerNode(oldNode);
            transformations.push({
                start,
                end,
                compilerNode: newNode,
            });
            if (wrappedNode != null) {
                if (oldNode.kind !== newNode.kind)
                    wrappedNode.forget();
                else
                    wrappedNode.forgetDescendants();
            }
        }
        function getTransformedText() {
            const fileText = compilerSourceFile.getFullText();
            let finalText = "";
            let lastPos = 0;
            for (const transform of transformations) {
                finalText += fileText.substring(lastPos, transform.start);
                finalText += printer.printNode(common.ts.EmitHint.Unspecified, transform.compilerNode, compilerSourceFile);
                lastPos = transform.end;
            }
            finalText += fileText.substring(lastPos);
            return finalText;
        }
    }
    getLeadingCommentRanges() {
        return this._leadingCommentRanges || (this._leadingCommentRanges = this._getCommentsAtPos(this.getFullStart(), (text, pos) => {
            const comments = common.ts.getLeadingCommentRanges(text, pos) || [];
            if (this.getKind() === common.SyntaxKind.SingleLineCommentTrivia || this.getKind() === common.SyntaxKind.MultiLineCommentTrivia) {
                const thisPos = this.getPos();
                return comments.filter(r => r.pos < thisPos);
            }
            else {
                return comments;
            }
        }));
    }
    getTrailingCommentRanges() {
        return this._trailingCommentRanges || (this._trailingCommentRanges = this._getCommentsAtPos(this.getEnd(), common.ts.getTrailingCommentRanges));
    }
    _getCommentsAtPos(pos, getComments) {
        if (this.getKind() === common.SyntaxKind.SourceFile)
            return [];
        return (getComments(this._sourceFile.getFullText(), pos) || []).map(r => new CommentRange(r, this._sourceFile));
    }
    getChildrenOfKind(kind) {
        return this._getCompilerChildrenOfKind(kind).map(c => this._getNodeFromCompilerNode(c));
    }
    getFirstChildByKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getFirstChildByKind(kind), `A child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getFirstChildByKind(kind) {
        const child = this._getCompilerChildrenOfKind(kind)[0];
        return child == null ? undefined : this._getNodeFromCompilerNode(child);
    }
    getFirstChildIfKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getFirstChildIfKind(kind), `A first child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getFirstChildIfKind(kind) {
        const firstChild = this._getCompilerFirstChild();
        return firstChild != null && firstChild.kind === kind ? this._getNodeFromCompilerNode(firstChild) : undefined;
    }
    getLastChildByKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getLastChildByKind(kind), `A child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getLastChildByKind(kind) {
        const children = this._getCompilerChildrenOfKind(kind);
        const lastChild = children[children.length - 1];
        return this._getNodeFromCompilerNodeIfExists(lastChild);
    }
    getLastChildIfKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getLastChildIfKind(kind), `A last child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getLastChildIfKind(kind) {
        const lastChild = this._getCompilerLastChild();
        return lastChild != null && lastChild.kind === kind ? this._getNodeFromCompilerNode(lastChild) : undefined;
    }
    getChildAtIndexIfKindOrThrow(index, kind) {
        return common.errors.throwIfNullOrUndefined(this.getChildAtIndexIfKind(index, kind), `Child at index ${index} was expected to be ${common.getSyntaxKindName(kind)}`);
    }
    getChildAtIndexIfKind(index, kind) {
        const node = this._getCompilerChildAtIndex(index);
        return node.kind === kind ? this._getNodeFromCompilerNode(node) : undefined;
    }
    getPreviousSiblingIfKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getPreviousSiblingIfKind(kind), `A previous sibling of kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getNextSiblingIfKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getNextSiblingIfKind(kind), `A next sibling of kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getPreviousSiblingIfKind(kind) {
        const previousSibling = this._getCompilerPreviousSibling();
        return previousSibling != null && previousSibling.kind === kind
            ? this._getNodeFromCompilerNode(previousSibling)
            : undefined;
    }
    getNextSiblingIfKind(kind) {
        const nextSibling = this._getCompilerNextSibling();
        return nextSibling != null && nextSibling.kind === kind ? this._getNodeFromCompilerNode(nextSibling) : undefined;
    }
    getParentIfOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getParentIf(condition), "The parent did not match the provided condition.");
    }
    getParentIf(condition) {
        return condition(this.getParent(), this) ? this.getParent() : undefined;
    }
    getParentIfKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getParentIfKind(kind), `The parent was not a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getParentIfKind(kind) {
        return this.getParentIf(n => n !== undefined && n.getKind() === kind);
    }
    getFirstAncestorByKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getFirstAncestorByKind(kind), `Expected an ancestor with a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getFirstAncestorByKind(kind) {
        for (const parent of this._getAncestorsIterator(kind === common.SyntaxKind.SyntaxList)) {
            if (parent.getKind() === kind)
                return parent;
        }
        return undefined;
    }
    getFirstAncestorOrThrow(condition) {
        return common.errors.throwIfNullOrUndefined(this.getFirstAncestor(condition), `Expected to find an ancestor that matched the provided condition.`);
    }
    getFirstAncestor(condition) {
        for (const ancestor of this._getAncestorsIterator(false)) {
            if (condition == null || condition(ancestor))
                return ancestor;
        }
        return undefined;
    }
    getDescendantsOfKind(kind) {
        const descendants = [];
        for (const descendant of this._getCompilerDescendantsOfKindIterator(kind))
            descendants.push(this._getNodeFromCompilerNode(descendant));
        return descendants;
    }
    getFirstDescendantByKindOrThrow(kind) {
        return common.errors.throwIfNullOrUndefined(this.getFirstDescendantByKind(kind), `A descendant of kind ${common.getSyntaxKindName(kind)} was expected to be found.`);
    }
    getFirstDescendantByKind(kind) {
        for (const descendant of this._getCompilerDescendantsOfKindIterator(kind))
            return this._getNodeFromCompilerNode(descendant);
        return undefined;
    }
    _getCompilerChildren() {
        return ExtendedParser.getCompilerChildren(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerForEachChildren() {
        return ExtendedParser.getCompilerForEachChildren(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerChildrenFast() {
        return hasParsedTokens(this.compilerNode) ? this._getCompilerChildren() : this._getCompilerForEachChildren();
    }
    _getCompilerChildrenOfKind(kind) {
        const children = useParseTreeSearchForKind(this, kind) ? this._getCompilerForEachChildren() : this._getCompilerChildren();
        return children.filter(c => c.kind === kind);
    }
    *_getCompilerDescendantsOfKindIterator(kind) {
        const children = useParseTreeSearchForKind(this, kind) ? this._getCompilerForEachChildren() : this._getCompilerChildren();
        for (const child of children) {
            if (child.kind === kind)
                yield child;
            const descendants = useParseTreeSearchForKind(child.kind, kind)
                ? getCompilerForEachDescendantsIterator(child)
                : getCompilerDescendantsIterator(child, this._sourceFile.compilerNode);
            for (const descendant of descendants) {
                if (descendant.kind === kind)
                    yield descendant;
            }
        }
    }
    _getCompilerDescendantsIterator() {
        return getCompilerDescendantsIterator(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerForEachDescendantsIterator() {
        return getCompilerForEachDescendantsIterator(this.compilerNode);
    }
    _getCompilerFirstChild(condition) {
        for (const child of this._getCompilerChildren()) {
            if (condition == null || condition(child))
                return child;
        }
        return undefined;
    }
    _getCompilerLastChild(condition) {
        const children = this._getCompilerChildren();
        for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            if (condition == null || condition(child))
                return child;
        }
        return undefined;
    }
    _getCompilerPreviousSiblings() {
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const previousSiblings = [];
        for (const child of parent._getCompilerChildren()) {
            if (child === this.compilerNode)
                break;
            previousSiblings.unshift(child);
        }
        return previousSiblings;
    }
    _getCompilerNextSiblings() {
        let foundChild = false;
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const nextSiblings = [];
        for (const child of parent._getCompilerChildren()) {
            if (!foundChild) {
                foundChild = child === this.compilerNode;
                continue;
            }
            nextSiblings.push(child);
        }
        return nextSiblings;
    }
    _getCompilerPreviousSibling(condition) {
        for (const sibling of this._getCompilerPreviousSiblings()) {
            if (condition == null || condition(sibling))
                return sibling;
        }
        return undefined;
    }
    _getCompilerNextSibling(condition) {
        for (const sibling of this._getCompilerNextSiblings()) {
            if (condition == null || condition(sibling))
                return sibling;
        }
        return undefined;
    }
    _getCompilerChildAtIndex(index) {
        const children = this._getCompilerChildren();
        common.errors.throwIfOutOfRange(index, [0, children.length - 1], "index");
        return children[index];
    }
    _getWriterWithIndentation() {
        const writer = this._getWriter();
        writer.setIndentationLevel(this.getIndentationLevel());
        return writer;
    }
    _getWriterWithQueuedIndentation() {
        const writer = this._getWriter();
        writer.queueIndentationLevel(this.getIndentationLevel());
        return writer;
    }
    _getWriterWithChildIndentation() {
        const writer = this._getWriter();
        writer.setIndentationLevel(this.getChildIndentationLevel());
        return writer;
    }
    _getWriterWithQueuedChildIndentation() {
        const writer = this._getWriter();
        writer.queueIndentationLevel(this.getChildIndentationLevel());
        return writer;
    }
    _getTextWithQueuedChildIndentation(textOrWriterFunc) {
        const writer = this._getWriterWithQueuedChildIndentation();
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else
            textOrWriterFunc(writer);
        return writer.toString();
    }
    _getWriter() {
        return this._context.createWriter();
    }
    _getNodeFromCompilerNode(compilerNode) {
        return this._context.compilerFactory.getNodeFromCompilerNode(compilerNode, this._sourceFile);
    }
    _getNodeFromCompilerNodeIfExists(compilerNode) {
        return compilerNode == null ? undefined : this._getNodeFromCompilerNode(compilerNode);
    }
    _ensureBound() {
        if (this.compilerNode.symbol != null)
            return;
        this.getSymbol();
    }
    static hasExpression(node) {
        var _a, _b;
        return ((_b = (_a = node).getExpression) === null || _b === void 0 ? void 0 : _b.call(_a)) != null;
    }
    static hasName(node) {
        var _a, _b;
        return typeof ((_b = (_a = node).getName) === null || _b === void 0 ? void 0 : _b.call(_a)) === "string";
    }
    static hasBody(node) {
        var _a, _b;
        return ((_b = (_a = node).getBody) === null || _b === void 0 ? void 0 : _b.call(_a)) != null;
    }
    static is(kind) {
        return (node) => {
            return (node === null || node === void 0 ? void 0 : node.getKind()) == kind;
        };
    }
    static isNode(value) {
        return value != null && value.compilerNode != null;
    }
    static isCommentNode(node) {
        const kind = node === null || node === void 0 ? void 0 : node.getKind();
        return kind === common.SyntaxKind.SingleLineCommentTrivia || kind === common.SyntaxKind.MultiLineCommentTrivia;
    }
    static isCommentStatement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.Statement;
    }
    static isCommentClassElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.ClassElement;
    }
    static isCommentTypeElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.TypeElement;
    }
    static isCommentObjectLiteralElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.ObjectLiteralElement;
    }
    static isCommentEnumMember(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind == exports.CommentNodeKind.EnumMember;
    }
    static isAbstractableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.ConstructorType:
                return true;
            default:
                return false;
        }
    }
    static isAmbientableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isArgumentedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }
    static isArrayTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ArrayType;
    }
    static isAsyncableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isAwaitableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ForOfStatement;
    }
    static isBindingNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isBodiedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isBodyableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isCallSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.CallSignature;
    }
    static isChildOrderableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.ExportAssignment:
            case common.SyntaxKind.ExportDeclaration:
            case common.SyntaxKind.ImportDeclaration:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.ModuleBlock:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.Block:
            case common.SyntaxKind.BreakStatement:
            case common.SyntaxKind.ContinueStatement:
            case common.SyntaxKind.DebuggerStatement:
            case common.SyntaxKind.DoStatement:
            case common.SyntaxKind.EmptyStatement:
            case common.SyntaxKind.ExpressionStatement:
            case common.SyntaxKind.ForInStatement:
            case common.SyntaxKind.ForOfStatement:
            case common.SyntaxKind.ForStatement:
            case common.SyntaxKind.IfStatement:
            case common.SyntaxKind.LabeledStatement:
            case common.SyntaxKind.NotEmittedStatement:
            case common.SyntaxKind.ReturnStatement:
            case common.SyntaxKind.SwitchStatement:
            case common.SyntaxKind.ThrowStatement:
            case common.SyntaxKind.TryStatement:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.WhileStatement:
            case common.SyntaxKind.WithStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isClassLikeDeclarationBase(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    static isConditionalTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ConditionalType;
    }
    static isConstructSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ConstructSignature;
    }
    static isConstructorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.Constructor;
    }
    static isConstructorTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ConstructorType;
    }
    static isDecoratableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }
    static isDotDotDotTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.JsxExpression:
            case common.SyntaxKind.NamedTupleMember:
                return true;
            default:
                return false;
        }
    }
    static isExclamationTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExportGetableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExportableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.AnyKeyword:
            case common.SyntaxKind.BooleanKeyword:
            case common.SyntaxKind.NumberKeyword:
            case common.SyntaxKind.ObjectKeyword:
            case common.SyntaxKind.StringKeyword:
            case common.SyntaxKind.SymbolKeyword:
            case common.SyntaxKind.UndefinedKeyword:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.AsExpression:
            case common.SyntaxKind.AwaitExpression:
            case common.SyntaxKind.BinaryExpression:
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.CommaListExpression:
            case common.SyntaxKind.ConditionalExpression:
            case common.SyntaxKind.DeleteExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.NonNullExpression:
            case common.SyntaxKind.OmittedExpression:
            case common.SyntaxKind.ParenthesizedExpression:
            case common.SyntaxKind.PartiallyEmittedExpression:
            case common.SyntaxKind.PostfixUnaryExpression:
            case common.SyntaxKind.PrefixUnaryExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.SpreadElement:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.TypeAssertionExpression:
            case common.SyntaxKind.TypeOfExpression:
            case common.SyntaxKind.VoidExpression:
            case common.SyntaxKind.YieldExpression:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxClosingFragment:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxExpression:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxOpeningElement:
            case common.SyntaxKind.JsxOpeningFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TaggedTemplateExpression:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isExpressionableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.YieldExpression:
            case common.SyntaxKind.JsxExpression:
            case common.SyntaxKind.ExternalModuleReference:
            case common.SyntaxKind.ReturnStatement:
                return true;
            default:
                return false;
        }
    }
    static isExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.AsExpression:
            case common.SyntaxKind.NonNullExpression:
            case common.SyntaxKind.ParenthesizedExpression:
            case common.SyntaxKind.PartiallyEmittedExpression:
            case common.SyntaxKind.SpreadElement:
            case common.SyntaxKind.JsxSpreadAttribute:
            case common.SyntaxKind.ExportAssignment:
            case common.SyntaxKind.ComputedPropertyName:
            case common.SyntaxKind.CaseClause:
            case common.SyntaxKind.DoStatement:
            case common.SyntaxKind.ExpressionStatement:
            case common.SyntaxKind.ForInStatement:
            case common.SyntaxKind.ForOfStatement:
            case common.SyntaxKind.IfStatement:
            case common.SyntaxKind.SwitchStatement:
            case common.SyntaxKind.ThrowStatement:
            case common.SyntaxKind.WhileStatement:
            case common.SyntaxKind.WithStatement:
            case common.SyntaxKind.SpreadAssignment:
            case common.SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }
    static isExtendsClauseableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.InterfaceDeclaration;
    }
    static isFalseLiteral(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.FalseKeyword;
    }
    static isFunctionLikeDeclaration(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isFunctionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.FunctionType;
    }
    static isGeneratorableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.YieldExpression:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isGetAccessorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.GetAccessor;
    }
    static isHeritageClauseableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isImplementsClauseableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    static isImportExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ImportKeyword;
    }
    static isImportTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ImportType;
    }
    static isIndexSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.IndexSignature;
    }
    static isIndexedAccessTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.IndexedAccessType;
    }
    static isInferTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.InferType;
    }
    static isInitializerExpressionGetableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.VariableDeclaration:
            case common.SyntaxKind.PropertyAssignment:
            case common.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isInitializerExpressionableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isIntersectionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.IntersectionType;
    }
    static isIterationStatement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.DoStatement:
            case common.SyntaxKind.ForInStatement:
            case common.SyntaxKind.ForOfStatement:
            case common.SyntaxKind.ForStatement:
            case common.SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }
    static isJSDoc(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.JSDocComment;
    }
    static isJSDocPropertyLikeTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JSDocParameterTag:
            case common.SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JSDocAugmentsTag:
            case common.SyntaxKind.JSDocAuthorTag:
            case common.SyntaxKind.JSDocCallbackTag:
            case common.SyntaxKind.JSDocClassTag:
            case common.SyntaxKind.JSDocDeprecatedTag:
            case common.SyntaxKind.JSDocEnumTag:
            case common.SyntaxKind.JSDocImplementsTag:
            case common.SyntaxKind.JSDocOverrideTag:
            case common.SyntaxKind.JSDocParameterTag:
            case common.SyntaxKind.JSDocPrivateTag:
            case common.SyntaxKind.JSDocPropertyTag:
            case common.SyntaxKind.JSDocProtectedTag:
            case common.SyntaxKind.JSDocPublicTag:
            case common.SyntaxKind.JSDocReadonlyTag:
            case common.SyntaxKind.JSDocReturnTag:
            case common.SyntaxKind.JSDocSeeTag:
            case common.SyntaxKind.JSDocTemplateTag:
            case common.SyntaxKind.JSDocThisTag:
            case common.SyntaxKind.JSDocTypedefTag:
            case common.SyntaxKind.JSDocTypeTag:
            case common.SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocType(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JSDocFunctionType:
            case common.SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTypeExpressionableTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JSDocReturnTag:
            case common.SyntaxKind.JSDocSeeTag:
            case common.SyntaxKind.JSDocThisTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTypeParameteredTag(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.JSDocTemplateTag;
    }
    static isJSDocUnknownTag(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.JSDocTag;
    }
    static isJSDocableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.ExpressionStatement:
            case common.SyntaxKind.LabeledStatement:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isJsxAttributedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JsxOpeningElement:
            case common.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    static isJsxTagNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JsxClosingElement:
            case common.SyntaxKind.JsxOpeningElement:
            case common.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    static isLeftHandSideExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.NonNullExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TaggedTemplateExpression:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isLeftHandSideExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.Decorator:
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }
    static isLiteralExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }
    static isLiteralLikeNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JsxText:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TemplateHead:
            case common.SyntaxKind.TemplateMiddle:
            case common.SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }
    static isLiteralTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.LiteralType;
    }
    static isMappedTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.MappedType;
    }
    static isMemberExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TaggedTemplateExpression:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isModifierableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.ConstructorType:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }
    static isModuleChildableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }
    static isModuleNamedNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ModuleDeclaration;
    }
    static isModuledNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }
    static isNameableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.JsxAttribute:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.TypeParameter:
            case common.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isNullLiteral(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.NullKeyword;
    }
    static isOverloadableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isOverrideableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }
    static isParameterDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.Parameter;
    }
    static isParameteredNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.JSDocFunctionType:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.ConstructorType:
            case common.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isParenthesizedTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ParenthesizedType;
    }
    static isPrimaryExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isPropertyNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isQuestionDotTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.PropertyAccessExpression:
                return true;
            default:
                return false;
        }
    }
    static isQuestionTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.PropertyAssignment:
            case common.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isReadonlyableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    static isReferenceFindableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.JsxAttribute:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.PrivateIdentifier:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.TypeParameter:
            case common.SyntaxKind.VariableDeclaration:
            case common.SyntaxKind.PropertyAssignment:
            case common.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isRenameableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.BindingElement:
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.JsxAttribute:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.NamespaceExport:
            case common.SyntaxKind.NamespaceImport:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.PrivateIdentifier:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.TypeParameter:
            case common.SyntaxKind.VariableDeclaration:
            case common.SyntaxKind.PropertyAssignment:
            case common.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isReturnTypedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.JSDocFunctionType:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.ConstructorType:
            case common.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isScopeableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.Parameter;
    }
    static isScopedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    static isSetAccessorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.SetAccessor;
    }
    static isSignaturedDeclaration(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.JSDocFunctionType:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.ConstructorType:
            case common.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isStatement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ExportAssignment:
            case common.SyntaxKind.ExportDeclaration:
            case common.SyntaxKind.ImportDeclaration:
            case common.SyntaxKind.ImportEqualsDeclaration:
            case common.SyntaxKind.ModuleBlock:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.Block:
            case common.SyntaxKind.BreakStatement:
            case common.SyntaxKind.ContinueStatement:
            case common.SyntaxKind.DebuggerStatement:
            case common.SyntaxKind.DoStatement:
            case common.SyntaxKind.EmptyStatement:
            case common.SyntaxKind.ExpressionStatement:
            case common.SyntaxKind.ForInStatement:
            case common.SyntaxKind.ForOfStatement:
            case common.SyntaxKind.ForStatement:
            case common.SyntaxKind.IfStatement:
            case common.SyntaxKind.LabeledStatement:
            case common.SyntaxKind.NotEmittedStatement:
            case common.SyntaxKind.ReturnStatement:
            case common.SyntaxKind.SwitchStatement:
            case common.SyntaxKind.ThrowStatement:
            case common.SyntaxKind.TryStatement:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.WhileStatement:
            case common.SyntaxKind.WithStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isStatementedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.ModuleBlock:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.SourceFile:
            case common.SyntaxKind.Block:
            case common.SyntaxKind.CaseClause:
            case common.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    static isStaticableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    static isSuperExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.SuperKeyword;
    }
    static isTemplateLiteralTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TemplateLiteralType;
    }
    static isTextInsertableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.SourceFile:
            case common.SyntaxKind.Block:
            case common.SyntaxKind.CaseBlock:
            case common.SyntaxKind.CaseClause:
            case common.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    static isThisExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ThisKeyword;
    }
    static isThisTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.ThisType;
    }
    static isTrueLiteral(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TrueKeyword;
    }
    static isTupleTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TupleType;
    }
    static isTypeArgumentedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }
    static isTypeAssertion(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TypeAssertionExpression;
    }
    static isTypeElement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    static isTypeElementMemberedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }
    static isTypeLiteralNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TypeLiteral;
    }
    static isTypeNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.JSDocFunctionType:
            case common.SyntaxKind.JSDocSignature:
            case common.SyntaxKind.JSDocTypeExpression:
            case common.SyntaxKind.ArrayType:
            case common.SyntaxKind.ConditionalType:
            case common.SyntaxKind.ConstructorType:
            case common.SyntaxKind.ExpressionWithTypeArguments:
            case common.SyntaxKind.FunctionType:
            case common.SyntaxKind.ImportType:
            case common.SyntaxKind.IndexedAccessType:
            case common.SyntaxKind.InferType:
            case common.SyntaxKind.IntersectionType:
            case common.SyntaxKind.LiteralType:
            case common.SyntaxKind.MappedType:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.ParenthesizedType:
            case common.SyntaxKind.TemplateLiteralType:
            case common.SyntaxKind.ThisType:
            case common.SyntaxKind.TupleType:
            case common.SyntaxKind.TypeLiteral:
            case common.SyntaxKind.TypePredicate:
            case common.SyntaxKind.TypeReference:
            case common.SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }
    static isTypeParameterDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TypeParameter;
    }
    static isTypeParameteredNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.ArrowFunction:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.FunctionType:
            case common.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isTypePredicateNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TypePredicate;
    }
    static isTypeReferenceNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.TypeReference;
    }
    static isTypedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.AsExpression:
            case common.SyntaxKind.TypeAssertionExpression:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.NamedTupleMember:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isUnaryExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.AwaitExpression:
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.DeleteExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.NonNullExpression:
            case common.SyntaxKind.PostfixUnaryExpression:
            case common.SyntaxKind.PrefixUnaryExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.TypeAssertionExpression:
            case common.SyntaxKind.TypeOfExpression:
            case common.SyntaxKind.VoidExpression:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TaggedTemplateExpression:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isUnaryExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.AwaitExpression:
            case common.SyntaxKind.DeleteExpression:
            case common.SyntaxKind.TypeAssertionExpression:
            case common.SyntaxKind.TypeOfExpression:
            case common.SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }
    static isUnionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === common.SyntaxKind.UnionType;
    }
    static isUnwrappableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isUpdateExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassExpression:
            case common.SyntaxKind.CallExpression:
            case common.SyntaxKind.ElementAccessExpression:
            case common.SyntaxKind.ImportKeyword:
            case common.SyntaxKind.MetaProperty:
            case common.SyntaxKind.NewExpression:
            case common.SyntaxKind.NonNullExpression:
            case common.SyntaxKind.PropertyAccessExpression:
            case common.SyntaxKind.SuperKeyword:
            case common.SyntaxKind.ThisKeyword:
            case common.SyntaxKind.FunctionExpression:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxFragment:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.BigIntLiteral:
            case common.SyntaxKind.TrueKeyword:
            case common.SyntaxKind.FalseKeyword:
            case common.SyntaxKind.NullKeyword:
            case common.SyntaxKind.NumericLiteral:
            case common.SyntaxKind.RegularExpressionLiteral:
            case common.SyntaxKind.StringLiteral:
            case common.SyntaxKind.Identifier:
            case common.SyntaxKind.ArrayLiteralExpression:
            case common.SyntaxKind.ObjectLiteralExpression:
            case common.SyntaxKind.NoSubstitutionTemplateLiteral:
            case common.SyntaxKind.TaggedTemplateExpression:
            case common.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static _hasStructure(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case common.SyntaxKind.ClassDeclaration:
            case common.SyntaxKind.ClassStaticBlockDeclaration:
            case common.SyntaxKind.Constructor:
            case common.SyntaxKind.GetAccessor:
            case common.SyntaxKind.MethodDeclaration:
            case common.SyntaxKind.PropertyDeclaration:
            case common.SyntaxKind.SetAccessor:
            case common.SyntaxKind.Decorator:
            case common.SyntaxKind.JSDocComment:
            case common.SyntaxKind.EnumDeclaration:
            case common.SyntaxKind.EnumMember:
            case common.SyntaxKind.FunctionDeclaration:
            case common.SyntaxKind.Parameter:
            case common.SyntaxKind.CallSignature:
            case common.SyntaxKind.ConstructSignature:
            case common.SyntaxKind.IndexSignature:
            case common.SyntaxKind.InterfaceDeclaration:
            case common.SyntaxKind.MethodSignature:
            case common.SyntaxKind.PropertySignature:
            case common.SyntaxKind.JsxAttribute:
            case common.SyntaxKind.JsxElement:
            case common.SyntaxKind.JsxSelfClosingElement:
            case common.SyntaxKind.JsxSpreadAttribute:
            case common.SyntaxKind.ExportAssignment:
            case common.SyntaxKind.ExportDeclaration:
            case common.SyntaxKind.ExportSpecifier:
            case common.SyntaxKind.ImportDeclaration:
            case common.SyntaxKind.ImportSpecifier:
            case common.SyntaxKind.ModuleDeclaration:
            case common.SyntaxKind.SourceFile:
            case common.SyntaxKind.VariableStatement:
            case common.SyntaxKind.TypeAliasDeclaration:
            case common.SyntaxKind.TypeParameter:
            case common.SyntaxKind.VariableDeclaration:
            case common.SyntaxKind.PropertyAssignment:
            case common.SyntaxKind.ShorthandPropertyAssignment:
            case common.SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
Node.isAnyKeyword = Node.is(common.SyntaxKind.AnyKeyword);
Node.isArrayBindingPattern = Node.is(common.SyntaxKind.ArrayBindingPattern);
Node.isArrayLiteralExpression = Node.is(common.SyntaxKind.ArrayLiteralExpression);
Node.isArrowFunction = Node.is(common.SyntaxKind.ArrowFunction);
Node.isAsExpression = Node.is(common.SyntaxKind.AsExpression);
Node.isAwaitExpression = Node.is(common.SyntaxKind.AwaitExpression);
Node.isBigIntLiteral = Node.is(common.SyntaxKind.BigIntLiteral);
Node.isBinaryExpression = Node.is(common.SyntaxKind.BinaryExpression);
Node.isBindingElement = Node.is(common.SyntaxKind.BindingElement);
Node.isBlock = Node.is(common.SyntaxKind.Block);
Node.isBooleanKeyword = Node.is(common.SyntaxKind.BooleanKeyword);
Node.isBreakStatement = Node.is(common.SyntaxKind.BreakStatement);
Node.isCallExpression = Node.is(common.SyntaxKind.CallExpression);
Node.isCaseBlock = Node.is(common.SyntaxKind.CaseBlock);
Node.isCaseClause = Node.is(common.SyntaxKind.CaseClause);
Node.isCatchClause = Node.is(common.SyntaxKind.CatchClause);
Node.isClassDeclaration = Node.is(common.SyntaxKind.ClassDeclaration);
Node.isClassExpression = Node.is(common.SyntaxKind.ClassExpression);
Node.isClassStaticBlockDeclaration = Node.is(common.SyntaxKind.ClassStaticBlockDeclaration);
Node.isCommaListExpression = Node.is(common.SyntaxKind.CommaListExpression);
Node.isComputedPropertyName = Node.is(common.SyntaxKind.ComputedPropertyName);
Node.isConditionalExpression = Node.is(common.SyntaxKind.ConditionalExpression);
Node.isContinueStatement = Node.is(common.SyntaxKind.ContinueStatement);
Node.isDebuggerStatement = Node.is(common.SyntaxKind.DebuggerStatement);
Node.isDecorator = Node.is(common.SyntaxKind.Decorator);
Node.isDefaultClause = Node.is(common.SyntaxKind.DefaultClause);
Node.isDeleteExpression = Node.is(common.SyntaxKind.DeleteExpression);
Node.isDoStatement = Node.is(common.SyntaxKind.DoStatement);
Node.isElementAccessExpression = Node.is(common.SyntaxKind.ElementAccessExpression);
Node.isEmptyStatement = Node.is(common.SyntaxKind.EmptyStatement);
Node.isEnumDeclaration = Node.is(common.SyntaxKind.EnumDeclaration);
Node.isEnumMember = Node.is(common.SyntaxKind.EnumMember);
Node.isExportAssignment = Node.is(common.SyntaxKind.ExportAssignment);
Node.isExportDeclaration = Node.is(common.SyntaxKind.ExportDeclaration);
Node.isExportSpecifier = Node.is(common.SyntaxKind.ExportSpecifier);
Node.isExpressionStatement = Node.is(common.SyntaxKind.ExpressionStatement);
Node.isExpressionWithTypeArguments = Node.is(common.SyntaxKind.ExpressionWithTypeArguments);
Node.isExternalModuleReference = Node.is(common.SyntaxKind.ExternalModuleReference);
Node.isForInStatement = Node.is(common.SyntaxKind.ForInStatement);
Node.isForOfStatement = Node.is(common.SyntaxKind.ForOfStatement);
Node.isForStatement = Node.is(common.SyntaxKind.ForStatement);
Node.isFunctionDeclaration = Node.is(common.SyntaxKind.FunctionDeclaration);
Node.isFunctionExpression = Node.is(common.SyntaxKind.FunctionExpression);
Node.isHeritageClause = Node.is(common.SyntaxKind.HeritageClause);
Node.isIdentifier = Node.is(common.SyntaxKind.Identifier);
Node.isIfStatement = Node.is(common.SyntaxKind.IfStatement);
Node.isImportClause = Node.is(common.SyntaxKind.ImportClause);
Node.isImportDeclaration = Node.is(common.SyntaxKind.ImportDeclaration);
Node.isImportEqualsDeclaration = Node.is(common.SyntaxKind.ImportEqualsDeclaration);
Node.isImportSpecifier = Node.is(common.SyntaxKind.ImportSpecifier);
Node.isInferKeyword = Node.is(common.SyntaxKind.InferKeyword);
Node.isInterfaceDeclaration = Node.is(common.SyntaxKind.InterfaceDeclaration);
Node.isJSDocAugmentsTag = Node.is(common.SyntaxKind.JSDocAugmentsTag);
Node.isJSDocAuthorTag = Node.is(common.SyntaxKind.JSDocAuthorTag);
Node.isJSDocCallbackTag = Node.is(common.SyntaxKind.JSDocCallbackTag);
Node.isJSDocClassTag = Node.is(common.SyntaxKind.JSDocClassTag);
Node.isJSDocDeprecatedTag = Node.is(common.SyntaxKind.JSDocDeprecatedTag);
Node.isJSDocEnumTag = Node.is(common.SyntaxKind.JSDocEnumTag);
Node.isJSDocFunctionType = Node.is(common.SyntaxKind.JSDocFunctionType);
Node.isJSDocImplementsTag = Node.is(common.SyntaxKind.JSDocImplementsTag);
Node.isJSDocLink = Node.is(common.SyntaxKind.JSDocLink);
Node.isJSDocLinkCode = Node.is(common.SyntaxKind.JSDocLinkCode);
Node.isJSDocLinkPlain = Node.is(common.SyntaxKind.JSDocLinkPlain);
Node.isJSDocMemberName = Node.is(common.SyntaxKind.JSDocMemberName);
Node.isJSDocOverrideTag = Node.is(common.SyntaxKind.JSDocOverrideTag);
Node.isJSDocParameterTag = Node.is(common.SyntaxKind.JSDocParameterTag);
Node.isJSDocPrivateTag = Node.is(common.SyntaxKind.JSDocPrivateTag);
Node.isJSDocPropertyTag = Node.is(common.SyntaxKind.JSDocPropertyTag);
Node.isJSDocProtectedTag = Node.is(common.SyntaxKind.JSDocProtectedTag);
Node.isJSDocPublicTag = Node.is(common.SyntaxKind.JSDocPublicTag);
Node.isJSDocReadonlyTag = Node.is(common.SyntaxKind.JSDocReadonlyTag);
Node.isJSDocReturnTag = Node.is(common.SyntaxKind.JSDocReturnTag);
Node.isJSDocSeeTag = Node.is(common.SyntaxKind.JSDocSeeTag);
Node.isJSDocSignature = Node.is(common.SyntaxKind.JSDocSignature);
Node.isJSDocTemplateTag = Node.is(common.SyntaxKind.JSDocTemplateTag);
Node.isJSDocText = Node.is(common.SyntaxKind.JSDocText);
Node.isJSDocThisTag = Node.is(common.SyntaxKind.JSDocThisTag);
Node.isJSDocTypeExpression = Node.is(common.SyntaxKind.JSDocTypeExpression);
Node.isJSDocTypeTag = Node.is(common.SyntaxKind.JSDocTypeTag);
Node.isJSDocTypedefTag = Node.is(common.SyntaxKind.JSDocTypedefTag);
Node.isJsxAttribute = Node.is(common.SyntaxKind.JsxAttribute);
Node.isJsxClosingElement = Node.is(common.SyntaxKind.JsxClosingElement);
Node.isJsxClosingFragment = Node.is(common.SyntaxKind.JsxClosingFragment);
Node.isJsxElement = Node.is(common.SyntaxKind.JsxElement);
Node.isJsxExpression = Node.is(common.SyntaxKind.JsxExpression);
Node.isJsxFragment = Node.is(common.SyntaxKind.JsxFragment);
Node.isJsxOpeningElement = Node.is(common.SyntaxKind.JsxOpeningElement);
Node.isJsxOpeningFragment = Node.is(common.SyntaxKind.JsxOpeningFragment);
Node.isJsxSelfClosingElement = Node.is(common.SyntaxKind.JsxSelfClosingElement);
Node.isJsxSpreadAttribute = Node.is(common.SyntaxKind.JsxSpreadAttribute);
Node.isJsxText = Node.is(common.SyntaxKind.JsxText);
Node.isLabeledStatement = Node.is(common.SyntaxKind.LabeledStatement);
Node.isMetaProperty = Node.is(common.SyntaxKind.MetaProperty);
Node.isMethodDeclaration = Node.is(common.SyntaxKind.MethodDeclaration);
Node.isMethodSignature = Node.is(common.SyntaxKind.MethodSignature);
Node.isModuleBlock = Node.is(common.SyntaxKind.ModuleBlock);
Node.isModuleDeclaration = Node.is(common.SyntaxKind.ModuleDeclaration);
Node.isNamedExports = Node.is(common.SyntaxKind.NamedExports);
Node.isNamedImports = Node.is(common.SyntaxKind.NamedImports);
Node.isNamedTupleMember = Node.is(common.SyntaxKind.NamedTupleMember);
Node.isNamespaceExport = Node.is(common.SyntaxKind.NamespaceExport);
Node.isNamespaceImport = Node.is(common.SyntaxKind.NamespaceImport);
Node.isNeverKeyword = Node.is(common.SyntaxKind.NeverKeyword);
Node.isNewExpression = Node.is(common.SyntaxKind.NewExpression);
Node.isNoSubstitutionTemplateLiteral = Node.is(common.SyntaxKind.NoSubstitutionTemplateLiteral);
Node.isNonNullExpression = Node.is(common.SyntaxKind.NonNullExpression);
Node.isNotEmittedStatement = Node.is(common.SyntaxKind.NotEmittedStatement);
Node.isNumberKeyword = Node.is(common.SyntaxKind.NumberKeyword);
Node.isNumericLiteral = Node.is(common.SyntaxKind.NumericLiteral);
Node.isObjectBindingPattern = Node.is(common.SyntaxKind.ObjectBindingPattern);
Node.isObjectKeyword = Node.is(common.SyntaxKind.ObjectKeyword);
Node.isObjectLiteralExpression = Node.is(common.SyntaxKind.ObjectLiteralExpression);
Node.isOmittedExpression = Node.is(common.SyntaxKind.OmittedExpression);
Node.isParenthesizedExpression = Node.is(common.SyntaxKind.ParenthesizedExpression);
Node.isPartiallyEmittedExpression = Node.is(common.SyntaxKind.PartiallyEmittedExpression);
Node.isPostfixUnaryExpression = Node.is(common.SyntaxKind.PostfixUnaryExpression);
Node.isPrefixUnaryExpression = Node.is(common.SyntaxKind.PrefixUnaryExpression);
Node.isPrivateIdentifier = Node.is(common.SyntaxKind.PrivateIdentifier);
Node.isPropertyAccessExpression = Node.is(common.SyntaxKind.PropertyAccessExpression);
Node.isPropertyAssignment = Node.is(common.SyntaxKind.PropertyAssignment);
Node.isPropertyDeclaration = Node.is(common.SyntaxKind.PropertyDeclaration);
Node.isPropertySignature = Node.is(common.SyntaxKind.PropertySignature);
Node.isQualifiedName = Node.is(common.SyntaxKind.QualifiedName);
Node.isRegularExpressionLiteral = Node.is(common.SyntaxKind.RegularExpressionLiteral);
Node.isReturnStatement = Node.is(common.SyntaxKind.ReturnStatement);
Node.isSemicolonToken = Node.is(common.SyntaxKind.SemicolonToken);
Node.isShorthandPropertyAssignment = Node.is(common.SyntaxKind.ShorthandPropertyAssignment);
Node.isSourceFile = Node.is(common.SyntaxKind.SourceFile);
Node.isSpreadAssignment = Node.is(common.SyntaxKind.SpreadAssignment);
Node.isSpreadElement = Node.is(common.SyntaxKind.SpreadElement);
Node.isStringKeyword = Node.is(common.SyntaxKind.StringKeyword);
Node.isStringLiteral = Node.is(common.SyntaxKind.StringLiteral);
Node.isSwitchStatement = Node.is(common.SyntaxKind.SwitchStatement);
Node.isSymbolKeyword = Node.is(common.SyntaxKind.SymbolKeyword);
Node.isSyntaxList = Node.is(common.SyntaxKind.SyntaxList);
Node.isTaggedTemplateExpression = Node.is(common.SyntaxKind.TaggedTemplateExpression);
Node.isTemplateExpression = Node.is(common.SyntaxKind.TemplateExpression);
Node.isTemplateHead = Node.is(common.SyntaxKind.TemplateHead);
Node.isTemplateMiddle = Node.is(common.SyntaxKind.TemplateMiddle);
Node.isTemplateSpan = Node.is(common.SyntaxKind.TemplateSpan);
Node.isTemplateTail = Node.is(common.SyntaxKind.TemplateTail);
Node.isThrowStatement = Node.is(common.SyntaxKind.ThrowStatement);
Node.isTryStatement = Node.is(common.SyntaxKind.TryStatement);
Node.isTypeAliasDeclaration = Node.is(common.SyntaxKind.TypeAliasDeclaration);
Node.isTypeOfExpression = Node.is(common.SyntaxKind.TypeOfExpression);
Node.isUndefinedKeyword = Node.is(common.SyntaxKind.UndefinedKeyword);
Node.isVariableDeclaration = Node.is(common.SyntaxKind.VariableDeclaration);
Node.isVariableDeclarationList = Node.is(common.SyntaxKind.VariableDeclarationList);
Node.isVariableStatement = Node.is(common.SyntaxKind.VariableStatement);
Node.isVoidExpression = Node.is(common.SyntaxKind.VoidExpression);
Node.isWhileStatement = Node.is(common.SyntaxKind.WhileStatement);
Node.isWithStatement = Node.is(common.SyntaxKind.WithStatement);
Node.isYieldExpression = Node.is(common.SyntaxKind.YieldExpression);
function getWrappedCondition(thisNode, condition) {
    return condition == null ? undefined : ((c) => condition(thisNode._getNodeFromCompilerNode(c)));
}
function insertWhiteSpaceTextAtPos(node, insertPos, textOrWriterFunction, methodName) {
    const parent = Node.isSourceFile(node) ? node.getChildSyntaxListOrThrow() : node.getParentSyntaxList() || node.getParentOrThrow();
    const newText = getTextFromStringOrWriter(node._getWriterWithQueuedIndentation(), textOrWriterFunction);
    if (!/^[\s\r\n]*$/.test(newText))
        throw new common.errors.InvalidOperationError(`Cannot insert non-whitespace into ${methodName}.`);
    insertIntoParentTextRange({
        parent,
        insertPos,
        newText,
    });
}
function* getCompilerForEachDescendantsIterator(node) {
    for (const child of getForEachChildren()) {
        yield child;
        yield* getCompilerForEachDescendantsIterator(child);
    }
    function getForEachChildren() {
        const children = [];
        node.forEachChild(child => {
            children.push(child);
        });
        return children;
    }
}
function* getCompilerDescendantsIterator(node, sourceFile) {
    for (const child of ExtendedParser.getCompilerChildren(node, sourceFile)) {
        yield child;
        yield* getCompilerDescendantsIterator(child, sourceFile);
    }
}
function useParseTreeSearchForKind(thisNodeOrSyntaxKind, searchingKind) {
    return searchingKind >= common.SyntaxKind.FirstNode && searchingKind < common.SyntaxKind.FirstJSDocNode
        && getThisKind() !== common.SyntaxKind.SyntaxList;
    function getThisKind() {
        if (typeof thisNodeOrSyntaxKind === "number")
            return thisNodeOrSyntaxKind;
        return thisNodeOrSyntaxKind.compilerNode.kind;
    }
}

exports.Scope = void 0;
(function (Scope) {
    Scope["Public"] = "public";
    Scope["Protected"] = "protected";
    Scope["Private"] = "private";
})(exports.Scope || (exports.Scope = {}));

class SyntaxList extends Node {
    addChildText(textOrWriterFunction) {
        return this.insertChildText(this.getChildCount(), textOrWriterFunction);
    }
    insertChildText(index, textOrWriterFunction) {
        const initialChildCount = this.getChildCount();
        const newLineKind = this._context.manipulationSettings.getNewLineKindAsString();
        const parent = this.getParentOrThrow();
        index = verifyAndGetIndex(index, initialChildCount);
        const isInline = this !== parent.getChildSyntaxList();
        let insertText = getTextFromStringOrWriter(isInline ? parent._getWriterWithQueuedChildIndentation() : parent._getWriterWithChildIndentation(), textOrWriterFunction);
        if (insertText.length === 0)
            return [];
        if (isInline) {
            if (index === 0)
                insertText += " ";
            else
                insertText = " " + insertText;
        }
        else {
            if (index === 0 && Node.isSourceFile(parent)) {
                if (!insertText.endsWith("\n"))
                    insertText += newLineKind;
            }
            else {
                insertText = newLineKind + insertText;
                if (!Node.isSourceFile(parent) && index === initialChildCount && insertText.endsWith("\n"))
                    insertText = insertText.replace(/\r?\n$/, "");
            }
        }
        const insertPos = getInsertPosFromIndex(index, this, this.getChildren());
        insertIntoParentTextRange({
            insertPos,
            newText: insertText,
            parent: this,
        });
        const finalChildren = this.getChildren();
        return getNodesToReturn(initialChildCount, finalChildren, index, true);
    }
}

function renameNode(node, newName, options) {
    common.errors.throwIfWhitespaceOrNotString(newName, "newName");
    if (node.getText() === newName)
        return;
    const renameLocations = node._context.languageService.findRenameLocations(node, options);
    const renameLocationsBySourceFile = new common.KeyValueCache();
    for (const renameLocation of renameLocations) {
        const locations = renameLocationsBySourceFile.getOrCreate(renameLocation.getSourceFile(), () => []);
        locations.push(renameLocation);
    }
    for (const [sourceFile, locations] of renameLocationsBySourceFile.getEntries()) {
        replaceSourceFileTextForRename({
            sourceFile,
            renameLocations: locations,
            newName,
        });
    }
}

function setBodyTextForNode(body, textOrWriterFunction) {
    const newText = getBodyText(body._getWriterWithIndentation(), textOrWriterFunction);
    const openBrace = body.getFirstChildByKindOrThrow(common.SyntaxKind.OpenBraceToken);
    const closeBrace = body.getFirstChildByKindOrThrow(common.SyntaxKind.CloseBraceToken);
    insertIntoParentTextRange({
        insertPos: openBrace.getEnd(),
        newText,
        parent: body,
        replacing: {
            textLength: closeBrace.getStart() - openBrace.getEnd(),
        },
    });
}

function BodiedNode(Base) {
    return class extends Base {
        getBody() {
            const body = this.compilerNode.body;
            if (body == null)
                throw new common.errors.InvalidOperationError("Bodied node should have a body.");
            return this._getNodeFromCompilerNode(body);
        }
        setBodyText(textOrWriterFunction) {
            const body = this.getBody();
            setBodyTextForNode(body, textOrWriterFunction);
            return this;
        }
        getBodyText() {
            return getBodyTextWithoutLeadingIndentation(this.getBody());
        }
    };
}

function BodyableNode(Base) {
    return class extends Base {
        getBodyOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getBody(), "Expected to find the node's body.");
        }
        getBody() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.body);
        }
        getBodyText() {
            const body = this.getBody();
            return body == null ? undefined : getBodyTextWithoutLeadingIndentation(body);
        }
        setBodyText(textOrWriterFunction) {
            this.addBody();
            setBodyTextForNode(this.getBodyOrThrow(), textOrWriterFunction);
            return this;
        }
        hasBody() {
            return this.compilerNode.body != null;
        }
        addBody() {
            var _a;
            if (this.hasBody())
                return this;
            const semiColon = this.getLastChildByKind(common.SyntaxKind.SemicolonToken);
            insertIntoParentTextRange({
                parent: this,
                insertPos: semiColon == null ? this.getEnd() : semiColon.getStart(),
                newText: this._getWriterWithQueuedIndentation().space().block().toString(),
                replacing: {
                    textLength: (_a = semiColon === null || semiColon === void 0 ? void 0 : semiColon.getFullWidth()) !== null && _a !== void 0 ? _a : 0,
                },
            });
            return this;
        }
        removeBody() {
            const body = this.getBody();
            if (body == null)
                return this;
            insertIntoParentTextRange({
                parent: this,
                insertPos: body.getPos(),
                newText: ";",
                replacing: {
                    textLength: body.getFullWidth(),
                },
            });
            return this;
        }
    };
}

function ChildOrderableNode(Base) {
    return class extends Base {
        setOrder(order) {
            const childIndex = this.getChildIndex();
            const parent = this.getParentSyntaxList() || this.getParentSyntaxListOrThrow();
            common.errors.throwIfOutOfRange(order, [0, parent.getChildCount() - 1], "order");
            if (childIndex === order)
                return this;
            changeChildOrder({
                parent,
                getSiblingFormatting: getGeneralFormatting,
                oldIndex: childIndex,
                newIndex: order,
            });
            return this;
        }
    };
}

function DecoratableNode(Base) {
    return class extends Base {
        getDecorator(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getDecorators(), nameOrFindFunction);
        }
        getDecoratorOrThrow(nameOrFindFunction) {
            return common.errors.throwIfNullOrUndefined(this.getDecorator(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("decorator", nameOrFindFunction));
        }
        getDecorators() {
            var _a, _b;
            return (_b = (_a = this.compilerNode.decorators) === null || _a === void 0 ? void 0 : _a.map(d => this._getNodeFromCompilerNode(d))) !== null && _b !== void 0 ? _b : [];
        }
        addDecorator(structure) {
            return this.insertDecorator(getEndIndexFromArray(this.compilerNode.decorators), structure);
        }
        addDecorators(structures) {
            return this.insertDecorators(getEndIndexFromArray(this.compilerNode.decorators), structures);
        }
        insertDecorator(index, structure) {
            return this.insertDecorators(index, [structure])[0];
        }
        insertDecorators(index, structures) {
            if (common.ArrayUtils.isNullOrEmpty(structures))
                return [];
            const decoratorLines = getDecoratorLines(this, structures);
            const decorators = this.getDecorators();
            index = verifyAndGetIndex(index, decorators.length);
            const formattingKind = getDecoratorFormattingKind(this, decorators);
            const previousDecorator = decorators[index - 1];
            const decoratorCode = getNewInsertCode({
                structures,
                newCodes: decoratorLines,
                parent: this,
                indentationText: this.getIndentationText(),
                getSeparator: () => formattingKind,
                previousFormattingKind: previousDecorator == null ? FormattingKind.None : formattingKind,
                nextFormattingKind: previousDecorator == null ? formattingKind : FormattingKind.None,
            });
            insertIntoParentTextRange({
                parent: decorators.length === 0 ? this : decorators[0].getParentSyntaxListOrThrow(),
                insertPos: decorators[index - 1] == null ? this.getStart() : decorators[index - 1].getEnd(),
                newText: decoratorCode,
            });
            return getNodesToReturn(decorators, this.getDecorators(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.decorators != null) {
                this.getDecorators().forEach(d => d.remove());
                this.addDecorators(structure.decorators);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                decorators: this.getDecorators().map(d => d.getStructure()),
            });
        }
    };
}
function getDecoratorLines(node, structures) {
    const lines = [];
    for (const structure of structures) {
        const writer = node._getWriter();
        const structurePrinter = node._context.structurePrinterFactory.forDecorator();
        structurePrinter.printText(writer, structure);
        lines.push(writer.toString());
    }
    return lines;
}
function getDecoratorFormattingKind(parent, currentDecorators) {
    const sameLine = areDecoratorsOnSameLine(parent, currentDecorators);
    return sameLine ? FormattingKind.Space : FormattingKind.Newline;
}
function areDecoratorsOnSameLine(parent, currentDecorators) {
    if (currentDecorators.length <= 1)
        return parent.getKind() === common.SyntaxKind.Parameter;
    const startLinePos = currentDecorators[0].getStartLinePos();
    for (let i = 1; i < currentDecorators.length; i++) {
        if (currentDecorators[i].getStartLinePos() !== startLinePos)
            return false;
    }
    return true;
}

function DotDotDotTokenableNode(Base) {
    return class extends Base {
        getDotDotDotTokenOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getDotDotDotToken(), "Expected to find a dot dot dot token (...).");
        }
        getDotDotDotToken() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);
        }
    };
}

function ExclamationTokenableNode(Base) {
    return class extends Base {
        hasExclamationToken() {
            return this.compilerNode.exclamationToken != null;
        }
        getExclamationTokenNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.exclamationToken);
        }
        getExclamationTokenNodeOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getExclamationTokenNode(), "Expected to find an exclamation token.");
        }
        setHasExclamationToken(value) {
            const exclamationTokenNode = this.getExclamationTokenNode();
            const hasExclamationToken = exclamationTokenNode != null;
            if (value === hasExclamationToken)
                return this;
            if (value) {
                if (Node.isQuestionTokenableNode(this))
                    this.setHasQuestionToken(false);
                const colonNode = this.getFirstChildByKind(common.SyntaxKind.ColonToken);
                if (colonNode == null)
                    throw new common.errors.InvalidOperationError("Cannot add an exclamation token to a node that does not have a type.");
                insertIntoParentTextRange({
                    insertPos: colonNode.getStart(),
                    parent: this,
                    newText: "!",
                });
            }
            else {
                removeChildren({ children: [exclamationTokenNode] });
            }
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasExclamationToken != null)
                this.setHasExclamationToken(structure.hasExclamationToken);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasExclamationToken: this.hasExclamationToken(),
            });
        }
    };
}

function ModifierableNode(Base) {
    return class extends Base {
        getModifiers() {
            return this.getCompilerModifiers().map(m => this._getNodeFromCompilerNode(m));
        }
        getFirstModifierByKindOrThrow(kind) {
            return common.errors.throwIfNullOrUndefined(this.getFirstModifierByKind(kind), `Expected a modifier of syntax kind: ${common.getSyntaxKindName(kind)}`);
        }
        getFirstModifierByKind(kind) {
            for (const modifier of this.getCompilerModifiers()) {
                if (modifier.kind === kind)
                    return this._getNodeFromCompilerNode(modifier);
            }
            return undefined;
        }
        hasModifier(textOrKind) {
            if (typeof textOrKind === "string")
                return this.getModifiers().some(m => m.getText() === textOrKind);
            else
                return this.getCompilerModifiers().some(m => m.kind === textOrKind);
        }
        toggleModifier(text, value) {
            if (value == null)
                value = !this.hasModifier(text);
            if (value)
                this.addModifier(text);
            else
                this.removeModifier(text);
            return this;
        }
        addModifier(text) {
            const modifiers = this.getModifiers();
            const existingModifier = modifiers.find(m => m.getText() === text);
            if (existingModifier != null)
                return existingModifier;
            const insertPos = getInsertPos(this);
            let startPos;
            let newText;
            const isFirstModifier = modifiers.length === 0 || insertPos === modifiers[0].getStart();
            if (isFirstModifier) {
                newText = text + " ";
                startPos = insertPos;
            }
            else {
                newText = " " + text;
                startPos = insertPos + 1;
            }
            insertIntoParentTextRange({
                parent: modifiers.length === 0 ? this : modifiers[0].getParentSyntaxListOrThrow(),
                insertPos,
                newText,
            });
            return this.getModifiers().find(m => m.getStart() === startPos);
            function getInsertPos(node) {
                let pos = getInitialInsertPos();
                for (const addAfterText of getAddAfterModifierTexts(text)) {
                    for (let i = 0; i < modifiers.length; i++) {
                        const modifier = modifiers[i];
                        if (modifier.getText() === addAfterText) {
                            if (pos < modifier.getEnd())
                                pos = modifier.getEnd();
                            break;
                        }
                    }
                }
                return pos;
                function getInitialInsertPos() {
                    if (modifiers.length > 0)
                        return modifiers[0].getStart();
                    for (const child of node._getChildrenIterator()) {
                        if (child.getKind() === common.SyntaxKind.SyntaxList || common.ts.isJSDocCommentContainingNode(child.compilerNode))
                            continue;
                        return child.getStart();
                    }
                    return node.getStart();
                }
            }
        }
        removeModifier(text) {
            const modifiers = this.getModifiers();
            const modifier = modifiers.find(m => m.getText() === text);
            if (modifier == null)
                return false;
            removeChildren({
                children: [modifiers.length === 1 ? modifier.getParentSyntaxListOrThrow() : modifier],
                removeFollowingSpaces: true,
            });
            return true;
        }
        getCompilerModifiers() {
            return this.compilerNode.modifiers || [];
        }
    };
}
function getAddAfterModifierTexts(text) {
    switch (text) {
        case "export":
            return [];
        case "public":
        case "protected":
        case "private":
            return [];
        case "default":
            return ["export"];
        case "const":
            return ["export"];
        case "declare":
            return ["export", "default"];
        case "static":
            return ["public", "protected", "private"];
        case "override":
            return ["public", "private", "protected", "static"];
        case "abstract":
            return ["export", "default", "declare", "public", "private", "protected", "static", "override"];
        case "async":
            return ["export", "default", "declare", "public", "private", "protected", "static", "override", "abstract"];
        case "readonly":
            return ["export", "default", "declare", "public", "private", "protected", "static", "override", "abstract"];
        default:
            common.errors.throwNotImplementedForNeverValueError(text);
    }
}

function ExportGetableNode(Base) {
    return class extends Base {
        hasExportKeyword() {
            return this.getExportKeyword() != null;
        }
        getExportKeyword() {
            if (Node.isVariableDeclaration(this)) {
                const variableStatement = this.getVariableStatement();
                return variableStatement === null || variableStatement === void 0 ? void 0 : variableStatement.getExportKeyword();
            }
            if (!Node.isModifierableNode(this))
                return throwForNotModifierableNode();
            return this.getFirstModifierByKind(common.SyntaxKind.ExportKeyword);
        }
        getExportKeywordOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getExportKeyword(), "Expected to find an export keyword.");
        }
        hasDefaultKeyword() {
            return this.getDefaultKeyword() != null;
        }
        getDefaultKeyword() {
            if (Node.isVariableDeclaration(this)) {
                const variableStatement = this.getVariableStatement();
                return variableStatement === null || variableStatement === void 0 ? void 0 : variableStatement.getDefaultKeyword();
            }
            if (!Node.isModifierableNode(this))
                return throwForNotModifierableNode();
            return this.getFirstModifierByKind(common.SyntaxKind.DefaultKeyword);
        }
        getDefaultKeywordOrThrow() {
            return common.errors.throwIfNullOrUndefined(this.getDefaultKeyword(), "Expected to find a default keyword.");
        }
        isExported() {
            if (this.hasExportKeyword())
                return true;
            const thisSymbol = this.getSymbol();
            const sourceFileSymbol = this.getSourceFile().getSymbol();
            if (thisSymbol == null || sourceFileSymbol == null)
                return false;
            return sourceFileSymbol.getExports().some(e => e === thisSymbol || e.getAliasedSymbol() === thisSymbol);
        }
        isDefaultExport() {
            if (this.hasDefaultKeyword())
                return true;
            const thisSymbol = this.getSymbol();
            if (thisSymbol == null)
                return false;
            const defaultExportSymbol = this.getSourceFile().getDefaultExportSymbol();
            if (defaultExportSymbol == null)
                return false;
            if (thisSymbol === defaultExportSymbol)
                return true;
            const aliasedSymbol = defaultExportSymbol.getAliasedSymbol();
            return thisSymbol === aliasedSymbol;
        }
        isNamedExport() {
            const thisSymbol = this.getSymbol();
            const sourceFileSymbol = this.getSourceFile().getSymbol();
            if (thisSymbol == null || sourceFileSymbol == null)
                return false;
            return !isDefaultExport() && sourceFileSymbol.getExports().some(e => e === thisSymbol || e.getAliasedSymbol() === thisSymbol);
            function isDefaultExport() {
                const defaultExportSymbol = sourceFileSymbol.getExport("default");
                if (defaultExportSymbol == null)
                    return false;
                return thisSymbol === defaultExportSymbol || thisSymbol === defaultExportSymbol.getAliasedSymbol();
            }
        }
    };
}
function throwForNotModifierableNode() {
    throw new common.errors.NotImplementedError(`Not implemented situation where node was not a ${"ModifierableNode"}.`);
}

function ExportableNode(Base) {
    return apply$1(ExportGetableNode(Base));
}
function apply$1(Base) {
    return class extends Base {
        setIsDefaultExport(value) {
            if (value === this.isDefaultExport())
                return this;
            if (value && !Node.isSourceFile(this.getParentOrThrow()))
                throw new common.errors.InvalidOperationError("The parent must be a source file in order to set this node as a default export.");
            const sourceFile = this.getSourceFile();
            const fileDefaultExportSymbol = sourceFile.getDefaultExportSymbol();
            if (fileDefaultExportSymbol != null)
                sourceFile.removeDefaultExport(fileDefaultExportSymbol);
            if (!value)
                return this;
            if (Node.hasName(this) && shouldWriteAsSeparateStatement.call(this)) {
                const parentSyntaxList = this.getFirstAncestorByKindOrThrow(common.SyntaxKind.SyntaxList);
                const name = this.getName();
                parentSyntaxList.insertChildText(this.getChildIndex() + 1, writer => {
                    writer.newLine().write(`export default ${name};`);
                });
            }
            else {
                this.addModifier("export");
                this.addModifier("default");
            }
            return this;
            function shouldWriteAsSeparateStatement() {
                if (Node.isEnumDeclaration(this) || Node.isModuleDeclaration(this) || Node.isTypeAliasDeclaration(this))
                    return true;
                if (Node.isAmbientableNode(this) && this.isAmbient())
                    return true;
                return false;
            }
        }
        setIsExported(value) {
            if (Node.isSourceFile(this.getParentOrThrow()))
                this.toggleModifier("default", false);
            this.toggleModifier("export", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isExported != null)
                this.setIsExported(structure.isExported);
            if (structure.isDefaultExport != null)
                this.setIsDefaultExport(structure.isDefaultExport);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isExported: this.hasExportKeyword(),
                isDefaultExport: this.hasDefaultKeyword(),
            });
        }
    };
}

class Printer {
    printTextOrWriterFunc(writer, textOrWriterFunc) {
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else if (textOrWriterFunc != null)
            textOrWriterFunc(writer);
    }
    getNewWriter(writer) {
        return new CodeBlockWriter__default['default'](writer.getOptions());
    }
    getNewWriterWithQueuedChildIndentation(writer) {
        const newWriter = new CodeBlockWriter__default['default'](writer.getOptions());
        newWriter.queueIndentationLevel(1);
        return newWriter;
    }
    getText(writer, textOrWriterFunc) {
        const newWriter = this.getNewWriter(writer);
        this.printTextOrWriterFunc(newWriter, textOrWriterFunc);
        return newWriter.toString();
    }
    getTextWithQueuedChildIndentation(writer, textOrWriterFunc) {
        const queuedChildIndentationWriter = this.getNewWriterWithQueuedChildIndentation(writer);
        this.printTextOrWriterFunc(queuedChildIndentationWriter, textOrWriterFunc);
        return queuedChildIndentationWriter.toString();
    }
}

class InitializerExpressionableNodeStructurePrinter extends Printer {
    printText(writer, structure) {
        const { initializer } = structure;
        if (initializer == null)
            return;
        const initializerText = this.getText(writer, initializer);
        if (!common.StringUtils.isNullOrWhitespace(initializerText)) {
            writer.hangingIndent(() => {
                writer.spaceIfLastNot();
                writer.write(`= ${initializerText}`);
            });
        }
    }
}

class ModifierableNodeStructurePrinter extends Printer {
    printText(writer, structure) {
        const scope = structure.scope;
        if (structure.isDefaultExport)
            writer.write("export default ");
        else if (structure.isExported)
            writer.write("export ");
        if (structure.hasDeclareKeyword)
            writer.write("declare ");
        if (scope != null)
            writer.write(`${scope} `);
        if (structure.isStatic)
            writer.write("static ");
        if (structure.hasOverrideKeyword)
            writer.write("override ");
        if (structure.isAbstract)
            writer.write("abstract ");
        if (structure.isAsync)
            writer.write("async ");
        if (structure.isReadonly)
            writer.write("readonly ");
    }
}

class ReturnTypedNodeStructurePrinter extends Printer {
    constructor(alwaysWrite = false) {
        super();
        this.alwaysWrite = alwaysWrite;
    }
    printText(writer, structure) {
        let { returnType } = structure;
        if (returnType == null && this.alwaysWrite === false)
            return;
        returnType = returnType !== null && returnType !== void 0 ? returnType : "void";
        const returnTypeText = this.getText(writer, returnType);
        if (!common.StringUtils.isNullOrWhitespace(returnTypeText)) {
            writer.hangingIndent(() => {
                writer.write(`: ${returnTypeText}`);
            });
        }
    }
}

class TypedNodeStructurePrinter extends Printer {
    constructor(separator, alwaysWrite = false) {
        super();
        this.separator = separator;
        this.alwaysWrite = alwaysWrite;
    }
    printText(writer, structure) {
        let { type } = structure;
        if (type == null && this.alwaysWrite === false)
            return;
        type = type !== null && type !== void 0 ? type : "any";
        const typeText = this.getText(writer, type);
        if (!common.StringUtils.isNullOrWhitespace(typeText)) {
            writer.hangingIndent(() => {
                writer.write(`${this.separator} ${typeText}`);
            });
        }
    }
}

class BlankLineFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalBlankLine(i > 0);
            this.printer.printText(writer, structures[i]);
        }
    }
}

class CommaSeparatedStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        printTextWithSeparator(this.printer, writer, structures, () => writer.spaceIfLastNot());
    }
}
function printTextWithSeparator(printer, writer, structures, separator) {
    if (structures == null)
        return;
    if (structures instanceof Function || typeof structures === "string")
        printer.printText(writer, structures);
    else {
        const commaAppendPositions = new Array(structures.length);
        for (let i = 0; i < structures.length; i++) {
            if (i > 0)
                separator();
            const structure = structures[i];
            const startPos = writer.getLength();
            printer.printText(writer, structure);
            const pos = getAppendCommaPos(WriterUtils.getLastCharactersToPos(writer, startPos));
            commaAppendPositions[i] = pos === -1 ? false : pos + startPos;
        }
        let foundFirst = false;
        for (let i = commaAppendPositions.length - 1; i >= 0; i--) {
            const pos = commaAppendPositions[i];
            if (pos === false)
                continue;
            else if (!foundFirst)
                foundFirst = true;
            else
                writer.unsafeInsert(pos, ",");
        }
    }
}

class CommaNewLineSeparatedStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        printTextWithSeparator(this.printer, writer, structures, () => writer.newLineIfLastNot());
    }
}

class NewLineFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalNewLine(i > 0);
            this.printer.printText(writer, structures[i]);
        }
    }
}

class SpaceFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalWrite(i > 0, " ");
            this.printer.printText(writer, structures[i]);
        }
    }
}

class NodePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printTextWithoutTrivia(writer, structure) {
        this.printTextInternal(writer, structure);
    }
    printText(writer, structure) {
        this.printLeadingTrivia(writer, structure);
        writer.closeComment();
        this.printTextInternal(writer, structure);
        this.printTrailingTrivia(writer, structure);
    }
    printLeadingTrivia(writer, structure) {
        const leadingTrivia = structure["leadingTrivia"];
        if (leadingTrivia != null) {
            this.printTrivia(writer, leadingTrivia);
            if (writer.isInComment())
                writer.closeComment();
        }
    }
    printTrailingTrivia(writer, structure) {
        const trailingTrivia = structure["trailingTrivia"];
        if (trailingTrivia != null)
            this.printTrivia(writer, trailingTrivia);
    }
    printTrivia(writer, trivia) {
        if (trivia instanceof Array) {
            for (let i = 0; i < trivia.length; i++) {
                this.printTextOrWriterFunc(writer, trivia[i]);
                if (i !== trivia.length - 1)
                    writer.newLineIfLastNot();
            }
        }
        else {
            this.printTextOrWriterFunc(writer, trivia);
        }
    }
}

class ClassDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        const isAmbient = structure.hasDeclareKeyword || this.options.isAmbient;
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.printHeader(writer, structure);
        writer.inlineBlock(() => {
            this.factory.forPropertyDeclaration().printTexts(writer, structure.properties);
            this.printCtors(writer, structure, isAmbient);
            this.printGetAndSet(writer, structure, isAmbient);
            if (!common.ArrayUtils.isNullOrEmpty(structure.methods)) {
                this.conditionalSeparator(writer, isAmbient);
                this.factory.forMethodDeclaration({ isAmbient }).printTexts(writer, structure.methods);
            }
        });
    }
    printHeader(writer, structure) {
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`class`);
        if (!common.StringUtils.isNullOrWhitespace(structure.name))
            writer.space().write(structure.name);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        writer.space();
        writer.hangingIndent(() => {
            if (structure.extends != null) {
                const extendsText = this.getText(writer, structure.extends);
                if (!common.StringUtils.isNullOrWhitespace(extendsText))
                    writer.write(`extends ${extendsText} `);
            }
            if (structure.implements != null) {
                const implementsText = structure.implements instanceof Array
                    ? structure.implements.map(i => this.getText(writer, i)).join(", ")
                    : this.getText(writer, structure.implements);
                if (!common.StringUtils.isNullOrWhitespace(implementsText))
                    writer.write(`implements ${implementsText} `);
            }
        });
    }
    printCtors(writer, structure, isAmbient) {
        if (common.ArrayUtils.isNullOrEmpty(structure.ctors))
            return;
        for (const ctor of structure.ctors) {
            this.conditionalSeparator(writer, isAmbient);
            this.factory.forConstructorDeclaration({ isAmbient }).printText(writer, ctor);
        }
    }
    printGetAndSet(writer, structure, isAmbient) {
        var _a, _b;
        const getAccessors = [...(_a = structure.getAccessors) !== null && _a !== void 0 ? _a : []];
        const setAccessors = [...(_b = structure.setAccessors) !== null && _b !== void 0 ? _b : []];
        const getAccessorWriter = this.factory.forGetAccessorDeclaration({ isAmbient });
        const setAccessorWriter = this.factory.forSetAccessorDeclaration({ isAmbient });
        for (const getAccessor of getAccessors) {
            this.conditionalSeparator(writer, isAmbient);
            getAccessorWriter.printText(writer, getAccessor);
            const setAccessorIndex = setAccessors.findIndex(item => item.name === getAccessor.name);
            if (setAccessorIndex >= 0) {
                this.conditionalSeparator(writer, isAmbient);
                setAccessorWriter.printText(writer, setAccessors[setAccessorIndex]);
                setAccessors.splice(setAccessorIndex, 1);
            }
        }
        for (const setAccessor of setAccessors) {
            this.conditionalSeparator(writer, isAmbient);
            setAccessorWriter.printText(writer, setAccessor);
        }
    }
    conditionalSeparator(writer, isAmbient) {
        if (writer.isAtStartOfFirstLineOfBlock())
            return;
        if (isAmbient)
            writer.newLine();
        else
            writer.blankLine();
    }
}

exports.StructureKind = void 0;
(function (StructureKind) {
    StructureKind[StructureKind["CallSignature"] = 0] = "CallSignature";
    StructureKind[StructureKind["Class"] = 1] = "Class";
    StructureKind[StructureKind["ClassStaticBlock"] = 2] = "ClassStaticBlock";
    StructureKind[StructureKind["ConstructSignature"] = 3] = "ConstructSignature";
    StructureKind[StructureKind["Constructor"] = 4] = "Constructor";
    StructureKind[StructureKind["ConstructorOverload"] = 5] = "ConstructorOverload";
    StructureKind[StructureKind["Decorator"] = 6] = "Decorator";
    StructureKind[StructureKind["Enum"] = 7] = "Enum";
    StructureKind[StructureKind["EnumMember"] = 8] = "EnumMember";
    StructureKind[StructureKind["ExportAssignment"] = 9] = "ExportAssignment";
    StructureKind[StructureKind["ExportDeclaration"] = 10] = "ExportDeclaration";
    StructureKind[StructureKind["ExportSpecifier"] = 11] = "ExportSpecifier";
    StructureKind[StructureKind["Function"] = 12] = "Function";
    StructureKind[StructureKind["FunctionOverload"] = 13] = "FunctionOverload";
    StructureKind[StructureKind["GetAccessor"] = 14] = "GetAccessor";
    StructureKind[StructureKind["ImportDeclaration"] = 15] = "ImportDeclaration";
    StructureKind[StructureKind["ImportSpecifier"] = 16] = "ImportSpecifier";
    StructureKind[StructureKind["IndexSignature"] = 17] = "IndexSignature";
    StructureKind[StructureKind["Interface"] = 18] = "Interface";
    StructureKind[StructureKind["JsxAttribute"] = 19] = "JsxAttribute";
    StructureKind[StructureKind["JsxSpreadAttribute"] = 20] = "JsxSpreadAttribute";
    StructureKind[StructureKind["JsxElement"] = 21] = "JsxElement";
    StructureKind[StructureKind["JsxSelfClosingElement"] = 22] = "JsxSelfClosingElement";
    StructureKind[StructureKind["JSDoc"] = 23] = "JSDoc";
    StructureKind[StructureKind["JSDocTag"] = 24] = "JSDocTag";
    StructureKind[StructureKind["Method"] = 25] = "Method";
    StructureKind[StructureKind["MethodOverload"] = 26] = "MethodOverload";
    StructureKind[StructureKind["MethodSignature"] = 27] = "MethodSignature";
    StructureKind[StructureKind["Module"] = 28] = "Module";
    StructureKind[StructureKind["Parameter"] = 29] = "Parameter";
    StructureKind[StructureKind["Property"] = 30] = "Property";
    StructureKind[StructureKind["PropertyAssignment"] = 31] = "PropertyAssignment";
    StructureKind[StructureKind["PropertySignature"] = 32] = "PropertySignature";
    StructureKind[StructureKind["SetAccessor"] = 33] = "SetAccessor";
    StructureKind[StructureKind["ShorthandPropertyAssignment"] = 34] = "ShorthandPropertyAssignment";
    StructureKind[StructureKind["SourceFile"] = 35] = "SourceFile";
    StructureKind[StructureKind["SpreadAssignment"] = 36] = "SpreadAssignment";
    StructureKind[StructureKind["TypeAlias"] = 37] = "TypeAlias";
    StructureKind[StructureKind["TypeParameter"] = 38] = "TypeParameter";
    StructureKind[StructureKind["VariableDeclaration"] = 39] = "VariableDeclaration";
    StructureKind[StructureKind["VariableStatement"] = 40] = "VariableStatement";
})(exports.StructureKind || (exports.StructureKind = {}));

const Structure = {
    hasName(structure) {
        return typeof structure.name === "string";
    },
    isClass(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isClassLikeDeclarationBase(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isNameable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Function:
                return true;
            default:
                return false;
        }
    },
    isImplementsClauseable(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isDecoratable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Parameter:
                return true;
            default:
                return false;
        }
    },
    isTypeParametered(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.Interface:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isJSDocable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Enum:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.Interface:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.Module:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isAbstractable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isAmbientable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Property:
            case exports.StructureKind.Enum:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.Interface:
            case exports.StructureKind.Module:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isExportable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Enum:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.Interface:
            case exports.StructureKind.Module:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isClassStaticBlock(structure) {
        return structure.kind === exports.StructureKind.ClassStaticBlock;
    },
    isStaticable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isFunctionLike(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
                return true;
            default:
                return false;
        }
    },
    isSignatured(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isParametered(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isReturnTyped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isStatemented(structure) {
        switch (structure.kind) {
            case exports.StructureKind.ClassStaticBlock:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.Module:
            case exports.StructureKind.SourceFile:
                return true;
            default:
                return false;
        }
    },
    isConstructor(structure) {
        return structure.kind === exports.StructureKind.Constructor;
    },
    isScoped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isConstructorDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.ConstructorOverload;
    },
    isGetAccessor(structure) {
        return structure.kind === exports.StructureKind.GetAccessor;
    },
    isPropertyNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    },
    isMethod(structure) {
        return structure.kind === exports.StructureKind.Method;
    },
    isAsyncable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
                return true;
            default:
                return false;
        }
    },
    isGeneratorable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
                return true;
            default:
                return false;
        }
    },
    isQuestionTokenable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
                return true;
            default:
                return false;
        }
    },
    isOverrideable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
                return true;
            default:
                return false;
        }
    },
    isMethodDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.MethodOverload;
    },
    isProperty(structure) {
        return structure.kind === exports.StructureKind.Property;
    },
    isTyped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.VariableDeclaration:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isExclamationTokenable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isReadonlyable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.PropertySignature:
                return true;
            default:
                return false;
        }
    },
    isInitializerExpressionable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isSetAccessor(structure) {
        return structure.kind === exports.StructureKind.SetAccessor;
    },
    isDecorator(structure) {
        return structure.kind === exports.StructureKind.Decorator;
    },
    isJSDoc(structure) {
        return structure.kind === exports.StructureKind.JSDoc;
    },
    isJSDocTag(structure) {
        return structure.kind === exports.StructureKind.JSDocTag;
    },
    isEnum(structure) {
        return structure.kind === exports.StructureKind.Enum;
    },
    isNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Enum:
            case exports.StructureKind.Interface:
            case exports.StructureKind.JsxAttribute:
            case exports.StructureKind.TypeAlias:
            case exports.StructureKind.TypeParameter:
            case exports.StructureKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    },
    isEnumMember(structure) {
        return structure.kind === exports.StructureKind.EnumMember;
    },
    isFunction(structure) {
        return structure.kind === exports.StructureKind.Function;
    },
    isFunctionDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.FunctionOverload;
    },
    isParameter(structure) {
        return structure.kind === exports.StructureKind.Parameter;
    },
    isBindingNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Parameter:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isScopeable(structure) {
        return structure.kind === exports.StructureKind.Parameter;
    },
    isCallSignature(structure) {
        return structure.kind === exports.StructureKind.CallSignature;
    },
    isConstructSignature(structure) {
        return structure.kind === exports.StructureKind.ConstructSignature;
    },
    isIndexSignature(structure) {
        return structure.kind === exports.StructureKind.IndexSignature;
    },
    isInterface(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isExtendsClauseable(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isTypeElementMembered(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isMethodSignature(structure) {
        return structure.kind === exports.StructureKind.MethodSignature;
    },
    isPropertySignature(structure) {
        return structure.kind === exports.StructureKind.PropertySignature;
    },
    isJsxAttribute(structure) {
        return structure.kind === exports.StructureKind.JsxAttribute;
    },
    isJsxElement(structure) {
        return structure.kind === exports.StructureKind.JsxElement;
    },
    isJsxSelfClosingElement(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxTagNamed(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxAttributed(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxSpreadAttribute(structure) {
        return structure.kind === exports.StructureKind.JsxSpreadAttribute;
    },
    isExportAssignment(structure) {
        return structure.kind === exports.StructureKind.ExportAssignment;
    },
    isExportDeclaration(structure) {
        return structure.kind === exports.StructureKind.ExportDeclaration;
    },
    isExportSpecifier(structure) {
        return structure.kind === exports.StructureKind.ExportSpecifier;
    },
    isImportDeclaration(structure) {
        return structure.kind === exports.StructureKind.ImportDeclaration;
    },
    isImportSpecifier(structure) {
        return structure.kind === exports.StructureKind.ImportSpecifier;
    },
    isModule(structure) {
        return structure.kind === exports.StructureKind.Module;
    },
    isModuleNamed(structure) {
        return structure.kind === exports.StructureKind.Module;
    },
    isSourceFile(structure) {
        return structure.kind === exports.StructureKind.SourceFile;
    },
    isVariableDeclaration(structure) {
        return structure.kind === exports.StructureKind.VariableDeclaration;
    },
    isVariableStatement(structure) {
        return structure.kind === exports.StructureKind.VariableStatement;
    },
    isTypeAlias(structure) {
        return structure.kind === exports.StructureKind.TypeAlias;
    },
    isTypeParameter(structure) {
        return structure.kind === exports.StructureKind.TypeParameter;
    },
    isPropertyAssignment(structure) {
        return structure.kind === exports.StructureKind.PropertyAssignment;
    },
    isShorthandPropertyAssignment(structure) {
        return structure.kind === exports.StructureKind.ShorthandPropertyAssignment;
    },
    isSpreadAssignment(structure) {
        return structure.kind === exports.StructureKind.SpreadAssignment;
    },
    isExpressioned(structure) {
        return structure.kind === exports.StructureKind.SpreadAssignment;
    }
};

function forEachStructureChild(structure, callback) {
    if (common.ArrayUtils.isReadonlyArray(structure)) {
        for (const item of structure) {
            const result = callback(item);
            if (result)
                return result;
        }
        return undefined;
    }
    switch (structure.kind) {
        case exports.StructureKind.Class:
            return forClassDeclaration(structure, callback);
        case exports.StructureKind.ClassStaticBlock:
            return forClassStaticBlockDeclaration(structure, callback);
        case exports.StructureKind.Constructor:
            return forConstructorDeclaration(structure, callback);
        case exports.StructureKind.ConstructorOverload:
            return forConstructorDeclarationOverload(structure, callback);
        case exports.StructureKind.GetAccessor:
            return forGetAccessorDeclaration(structure, callback);
        case exports.StructureKind.Method:
            return forMethodDeclaration(structure, callback);
        case exports.StructureKind.MethodOverload:
            return forMethodDeclarationOverload(structure, callback);
        case exports.StructureKind.Property:
            return forPropertyDeclaration(structure, callback);
        case exports.StructureKind.SetAccessor:
            return forSetAccessorDeclaration(structure, callback);
        case exports.StructureKind.JSDoc:
            return forJSDoc(structure, callback);
        case exports.StructureKind.Enum:
            return forEnumDeclaration(structure, callback);
        case exports.StructureKind.EnumMember:
            return forEnumMember(structure, callback);
        case exports.StructureKind.Function:
            return forFunctionDeclaration(structure, callback);
        case exports.StructureKind.FunctionOverload:
            return forFunctionDeclarationOverload(structure, callback);
        case exports.StructureKind.Parameter:
            return forParameterDeclaration(structure, callback);
        case exports.StructureKind.CallSignature:
            return forCallSignatureDeclaration(structure, callback);
        case exports.StructureKind.ConstructSignature:
            return forConstructSignatureDeclaration(structure, callback);
        case exports.StructureKind.IndexSignature:
            return forIndexSignatureDeclaration(structure, callback);
        case exports.StructureKind.Interface:
            return forInterfaceDeclaration(structure, callback);
        case exports.StructureKind.MethodSignature:
            return forMethodSignature(structure, callback);
        case exports.StructureKind.PropertySignature:
            return forPropertySignature(structure, callback);
        case exports.StructureKind.JsxElement:
            return forJsxElement(structure, callback);
        case exports.StructureKind.JsxSelfClosingElement:
            return forJsxSelfClosingElement(structure, callback);
        case exports.StructureKind.ExportDeclaration:
            return forExportDeclaration(structure, callback);
        case exports.StructureKind.ImportDeclaration:
            return forImportDeclaration(structure, callback);
        case exports.StructureKind.Module:
            return forModuleDeclaration(structure, callback);
        case exports.StructureKind.SourceFile:
            return forSourceFile(structure, callback);
        case exports.StructureKind.VariableStatement:
            return forVariableStatement(structure, callback);
        case exports.StructureKind.TypeAlias:
            return forTypeAliasDeclaration(structure, callback);
        default:
            return undefined;
    }
}
function forClassDeclaration(structure, callback) {
    return forClassLikeDeclarationBase(structure, callback);
}
function forClassLikeDeclarationBase(structure, callback) {
    return forDecoratableNode(structure, callback)
        || forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback)
        || forAll(structure.ctors, callback, exports.StructureKind.Constructor)
        || forAll(structure.properties, callback, exports.StructureKind.Property)
        || forAll(structure.getAccessors, callback, exports.StructureKind.GetAccessor)
        || forAll(structure.setAccessors, callback, exports.StructureKind.SetAccessor)
        || forAll(structure.methods, callback, exports.StructureKind.Method);
}
function forDecoratableNode(structure, callback) {
    return forAll(structure.decorators, callback, exports.StructureKind.Decorator);
}
function forTypeParameteredNode(structure, callback) {
    return forAllIfStructure(structure.typeParameters, callback, exports.StructureKind.TypeParameter);
}
function forJSDocableNode(structure, callback) {
    return forAllIfStructure(structure.docs, callback, exports.StructureKind.JSDoc);
}
function forClassStaticBlockDeclaration(structure, callback) {
    return forFunctionLikeDeclaration(structure, callback);
}
function forFunctionLikeDeclaration(structure, callback) {
    return forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback)
        || forStatementedNode(structure, callback);
}
function forSignaturedDeclaration(structure, callback) {
    return forParameteredNode(structure, callback);
}
function forParameteredNode(structure, callback) {
    return forAll(structure.parameters, callback, exports.StructureKind.Parameter);
}
function forStatementedNode(structure, callback) {
    return forAllUnknownKindIfStructure(structure.statements, callback);
}
function forConstructorDeclaration(structure, callback) {
    return forFunctionLikeDeclaration(structure, callback)
        || forAll(structure.overloads, callback, exports.StructureKind.ConstructorOverload);
}
function forConstructorDeclarationOverload(structure, callback) {
    return forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback);
}
function forGetAccessorDeclaration(structure, callback) {
    return forDecoratableNode(structure, callback)
        || forFunctionLikeDeclaration(structure, callback);
}
function forMethodDeclaration(structure, callback) {
    return forDecoratableNode(structure, callback)
        || forFunctionLikeDeclaration(structure, callback)
        || forAll(structure.overloads, callback, exports.StructureKind.MethodOverload);
}
function forMethodDeclarationOverload(structure, callback) {
    return forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback);
}
function forPropertyDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forDecoratableNode(structure, callback);
}
function forSetAccessorDeclaration(structure, callback) {
    return forDecoratableNode(structure, callback)
        || forFunctionLikeDeclaration(structure, callback);
}
function forJSDoc(structure, callback) {
    return forAll(structure.tags, callback, exports.StructureKind.JSDocTag);
}
function forEnumDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forAll(structure.members, callback, exports.StructureKind.EnumMember);
}
function forEnumMember(structure, callback) {
    return forJSDocableNode(structure, callback);
}
function forFunctionDeclaration(structure, callback) {
    return forFunctionLikeDeclaration(structure, callback)
        || forAll(structure.overloads, callback, exports.StructureKind.FunctionOverload);
}
function forFunctionDeclarationOverload(structure, callback) {
    return forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback);
}
function forParameterDeclaration(structure, callback) {
    return forDecoratableNode(structure, callback);
}
function forCallSignatureDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback);
}
function forConstructSignatureDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback);
}
function forIndexSignatureDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback);
}
function forInterfaceDeclaration(structure, callback) {
    return forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback)
        || forTypeElementMemberedNode(structure, callback);
}
function forTypeElementMemberedNode(structure, callback) {
    return forAll(structure.callSignatures, callback, exports.StructureKind.CallSignature)
        || forAll(structure.constructSignatures, callback, exports.StructureKind.ConstructSignature)
        || forAll(structure.indexSignatures, callback, exports.StructureKind.IndexSignature)
        || forAll(structure.methods, callback, exports.StructureKind.MethodSignature)
        || forAll(structure.properties, callback, exports.StructureKind.PropertySignature);
}
function forMethodSignature(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forSignaturedDeclaration(structure, callback)
        || forTypeParameteredNode(structure, callback);
}
function forPropertySignature(structure, callback) {
    return forJSDocableNode(structure, callback);
}
function forJsxElement(structure, callback) {
    return forAllUnknownKindIfStructure(structure.attributes, callback)
        || forAllUnknownKindIfStructure(structure.children, callback);
}
function forJsxSelfClosingElement(structure, callback) {
    return forJsxAttributedNode(structure, callback);
}
function forJsxAttributedNode(structure, callback) {
    return forAllUnknownKindIfStructure(structure.attributes, callback);
}
function forExportDeclaration(structure, callback) {
    return forAllIfStructure(structure.namedExports, callback, exports.StructureKind.ExportSpecifier);
}
function forImportDeclaration(structure, callback) {
    return forAllIfStructure(structure.namedImports, callback, exports.StructureKind.ImportSpecifier);
}
function forModuleDeclaration(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forStatementedNode(structure, callback);
}
function forSourceFile(structure, callback) {
    return forStatementedNode(structure, callback);
}
function forVariableStatement(structure, callback) {
    return forJSDocableNode(structure, callback)
        || forAll(structure.declarations, callback, exports.StructureKind.VariableDeclaration);
}
function forTypeAliasDeclaration(structure, callback) {
    return forTypeParameteredNode(structure, callback)
        || forJSDocableNode(structure, callback);
}
function forAll(structures, callback, kind) {
    if (structures == null)
        return;
    for (const structure of structures) {
        const result = callback(ensureKind(structure, kind));
        if (result)
            return result;
    }
    return undefined;
}
function forAllIfStructure(values, callback, kind) {
    if (values == null || !(values instanceof Array))
        return;
    for (const value of values) {
        if (isStructure(value)) {
            const result = callback(ensureKind(value, kind));
            if (result)
                return result;
        }
    }
    return undefined;
}
function forAllUnknownKindIfStructure(values, callback) {
    if (values == null || !(values instanceof Array))
        return;
    for (const value of values) {
        if (isStructure(value)) {
            const result = callback(value);
            if (result)
                return result;
        }
    }
    return undefined;
}
function ensureKind(structure, kind) {
    if (structure.kind == null)
        structure.kind = kind;
    return structure;
}
function isStructure(value) {
    return value != null && typeof value.kind === "number";
}

function isLastNonWhitespaceCharCloseBrace(writer) {
    return writer.iterateLastCharCodes(charCode => {
        if (charCode === CharCodes.CLOSE_BRACE)
            return true;
        else if (common.StringUtils.isWhitespaceCharCode(charCode))
            return undefined;
        else
            return false;
    }) || false;
}

class ClassMemberStructurePrinter extends Printer {
    constructor(factory, options) {
        super();
        this.factory = factory;
        this.options = options;
    }
    printTexts(writer, members) {
        if (members == null)
            return;
        if (typeof members === "string" || members instanceof Function)
            this.printText(writer, members);
        else {
            for (const member of members) {
                if (isLastNonWhitespaceCharCloseBrace(writer))
                    writer.blankLineIfLastNot();
                else if (!writer.isAtStartOfFirstLineOfBlock())
                    writer.newLineIfLastNot();
                this.printText(writer, member);
            }
        }
    }
    printText(writer, member) {
        if (typeof member === "string" || member instanceof Function || member == null) {
            this.printTextOrWriterFunc(writer, member);
            return;
        }
        switch (member.kind) {
            case exports.StructureKind.Method:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forMethodDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.Property:
                this.factory.forPropertyDeclaration().printText(writer, member);
                break;
            case exports.StructureKind.GetAccessor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forGetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.SetAccessor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forSetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.Constructor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forConstructorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.ClassStaticBlock:
                ensureBlankLine();
                this.factory.forClassStaticBlockDeclaration().printText(writer, member);
                break;
            default:
                common.errors.throwNotImplementedForNeverValueError(member);
        }
        function ensureBlankLine() {
            if (!writer.isAtStartOfFirstLineOfBlock())
                writer.blankLineIfLastNot();
        }
    }
}

class ClassStaticBlockDeclarationStructurePrinter extends NodePrinter {
    constructor(factory) {
        super(factory);
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0)
                writer.blankLine();
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        writer.write("static");
        writer.space().inlineBlock(() => {
            this.factory.forStatementedNode({ isAmbient: false }).printText(writer, structure);
        });
    }
}

class ConstructorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                if (this.options.isAmbient)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, getOverloadStructures());
        this.printHeader(writer, structure);
        if (this.options.isAmbient)
            writer.write(";");
        else {
            writer.space().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads)
                setValueIfUndefined(overload, "scope", structure.scope);
            return overloads;
        }
    }
    printOverloads(writer, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, structure);
            writer.newLine();
        }
    }
    printOverload(writer, structure) {
        this.printHeader(writer, structure);
        writer.write(";");
    }
    printHeader(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write("constructor");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
    }
}

class GetAccessorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.blankLineWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.blankLineWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`get ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
    }
}

class MethodDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                if (this.options.isAmbient)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, structure.name, getOverloadStructures());
        this.printHeader(writer, structure.name, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads) {
                setValueIfUndefined(overload, "scope", structure.scope);
                setValueIfUndefined(overload, "isStatic", structure.isStatic);
                setValueIfUndefined(overload, "isAbstract", structure.isAbstract);
                setValueIfUndefined(overload, "hasQuestionToken", structure.hasQuestionToken);
            }
            return overloads;
        }
    }
    printOverloads(writer, name, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, name, structure);
            writer.newLine();
        }
    }
    printOverload(writer, name, structure) {
        this.printHeader(writer, name, structure);
        writer.write(";");
    }
    printHeader(writer, name, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        if (structure.decorators != null)
            this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
    }
}

class PropertyDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        writer.conditionalWrite(structure.hasExclamationToken && !structure.hasQuestionToken, "!");
        this.factory.forTypedNode(":").printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
        writer.write(";");
    }
}

class SetAccessorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`set ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
    }
}

class StringStructurePrinter extends Printer {
    printText(writer, textOrWriterFunc) {
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else
            textOrWriterFunc(writer);
    }
}

class DecoratorStructurePrinter extends NodePrinter {
    printTexts(writer, structures) {
        this.printMultiple(writer, structures, () => writer.newLine());
    }
    printTextsInline(writer, structures) {
        this.printMultiple(writer, structures, () => writer.space());
    }
    printTextInternal(writer, structure) {
        writer.write(`@${structure.name}`);
        this.printArguments(writer, structure);
    }
    printArguments(writer, structure) {
        if (structure.arguments == null)
            return;
        writer.write("(");
        const args = structure.arguments instanceof Array ? structure.arguments : [structure.arguments];
        for (let i = 0; i < args.length; i++) {
            writer.conditionalWrite(i > 0, ", ");
            writer.write(this.getTextWithQueuedChildIndentation(writer, args[i]));
        }
        writer.write(")");
    }
    printMultiple(writer, structures, separator) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printText(writer, structure);
            separator();
        }
    }
}

class JSDocStructurePrinter extends NodePrinter {
    printDocs(writer, structures) {
        if (structures == null)
            return;
        for (const structure of structures) {
            this.printText(writer, structure);
            writer.newLine();
        }
    }
    printTextInternal(writer, structure) {
        const text = getText(this);
        const lines = text.split(/\r?\n/);
        const startsWithNewLine = lines[0].length === 0;
        const isSingleLine = lines.length <= 1;
        const startIndex = startsWithNewLine ? 1 : 0;
        writer.write("/**");
        if (isSingleLine)
            writer.space();
        else
            writer.newLine();
        if (isSingleLine)
            writer.write(lines[startIndex]);
        else {
            for (let i = startIndex; i < lines.length; i++) {
                writer.write(` *`);
                if (lines[i].length > 0)
                    writer.write(` ${lines[i]}`);
                writer.newLine();
            }
        }
        writer.spaceIfLastNot();
        writer.write("*/");
        function getText(jsdocPrinter) {
            if (typeof structure === "string")
                return structure;
            const tempWriter = jsdocPrinter.getNewWriter(writer);
            if (typeof structure === "function")
                structure(tempWriter);
            else {
                if (structure.description)
                    printTextFromStringOrWriter(tempWriter, structure.description);
                if (structure.tags && structure.tags.length > 0) {
                    if (tempWriter.getLength() > 0)
                        tempWriter.newLine();
                    jsdocPrinter.factory.forJSDocTag({ printStarsOnNewLine: false }).printTexts(tempWriter, structure.tags);
                }
            }
            return tempWriter.toString();
        }
    }
}

class JSDocTagStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                writer.newLine();
                writer.conditionalWrite(this.options.printStarsOnNewLine, " * ");
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        const text = getText(this);
        const lines = text.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
            if (i > 0) {
                writer.newLine();
                if (this.options.printStarsOnNewLine)
                    writer.write(` *`);
            }
            if (lines[i].length > 0) {
                if (this.options.printStarsOnNewLine && i > 0)
                    writer.space();
                writer.write(lines[i]);
            }
        }
        function getText(tagPrinter) {
            if (typeof structure === "string")
                return structure;
            const tempWriter = tagPrinter.getNewWriter(writer);
            if (typeof structure === "function")
                structure(tempWriter);
            else {
                if (structure.text)
                    printTextFromStringOrWriter(tempWriter, structure.text);
                const currentText = tempWriter.toString();
                tempWriter.unsafeInsert(0, `@${structure.tagName}` + (currentText.length > 0 && !common.StringUtils.startsWithNewLine(currentText) ? " " : ""));
            }
            return tempWriter.toString();
        }
    }
}

class EnumDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.conditionalWrite(structure.isConst, "const ");
        writer.write(`enum ${structure.name} `).inlineBlock(() => {
            this.factory.forEnumMember().printTexts(writer, structure.members);
        });
    }
}

class EnumMemberStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaNewLineSeparatedStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        if (structure instanceof Function) {
            structure(writer);
            return;
        }
        else if (typeof structure === "string") {
            writer.write(structure);
            return;
        }
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        if (isValidVariableName(structure.name) || common.StringUtils.isQuoted(structure.name))
            writer.write(structure.name);
        else
            writer.quote(structure.name);
        if (typeof structure.value === "string") {
            const { value } = structure;
            writer.hangingIndent(() => writer.write(` = `).quote(value));
        }
        else if (typeof structure.value === "number")
            writer.write(` = ${structure.value}`);
        else
            this.factory.forInitializerExpressionableNode().printText(writer, structure);
    }
}

class ObjectLiteralExpressionPropertyStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
        this.multipleWriter = new CommaNewLineSeparatedStructuresPrinter(this);
        this.options = { isAmbient: false };
    }
    printTexts(writer, members) {
        this.multipleWriter.printText(writer, members);
    }
    printText(writer, member) {
        if (typeof member === "string" || member instanceof Function || member == null) {
            this.printTextOrWriterFunc(writer, member);
            return;
        }
        switch (member.kind) {
            case exports.StructureKind.PropertyAssignment:
                this.factory.forPropertyAssignment().printText(writer, member);
                break;
            case exports.StructureKind.ShorthandPropertyAssignment:
                this.factory.forShorthandPropertyAssignment().printText(writer, member);
                break;
            case exports.StructureKind.SpreadAssignment:
                this.factory.forSpreadAssignment().printText(writer, member);
                break;
            case exports.StructureKind.Method:
                this.factory.forMethodDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.GetAccessor:
                this.factory.forGetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.SetAccessor:
                this.factory.forSetAccessorDeclaration(this.options).printText(writer, member);
                break;
            default:
                common.errors.throwNotImplementedForNeverValueError(member);
        }
    }
}

class PropertyAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`${structure.name}: `);
            printTextFromStringOrWriter(writer, structure.initializer);
        });
    }
}

class ShorthandPropertyAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.write(`${structure.name}`);
    }
}

class SpreadAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write("...");
            printTextFromStringOrWriter(writer, structure.expression);
        });
    }
}

class FunctionDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            const currentStructure = structures[i];
            if (i > 0) {
                const previousStructure = structures[i - 1];
                if (this.options.isAmbient || previousStructure.hasDeclareKeyword && currentStructure.hasDeclareKeyword)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, currentStructure);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, structure.name, getOverloadStructures());
        this.printHeader(writer, structure.name, structure);
        if (this.options.isAmbient || structure.hasDeclareKeyword)
            writer.write(";");
        else {
            writer.space().inlineBlock(() => {
                this.factory.forStatementedNode({ isAmbient: false }).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads) {
                setValueIfUndefined(overload, "hasDeclareKeyword", structure.hasDeclareKeyword);
                setValueIfUndefined(overload, "isExported", structure.isExported);
                setValueIfUndefined(overload, "isDefaultExport", structure.isDefaultExport);
            }
            return overloads;
        }
    }
    printOverloads(writer, name, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, name, structure);
            writer.newLine();
        }
    }
    printOverload(writer, name, structure) {
        this.printHeader(writer, name, structure);
        writer.write(";");
    }
    printHeader(writer, name, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`function`);
        writer.conditionalWrite(structure.isGenerator, "*");
        if (!common.StringUtils.isNullOrWhitespace(name))
            writer.write(` ${name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
    }
}

class ParameterDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaSeparatedStructuresPrinter(this);
    }
    printTextsWithParenthesis(writer, structures) {
        writer.write("(");
        if (structures != null)
            this.factory.forParameterDeclaration().printTexts(writer, structures);
        writer.write(`)`);
    }
    printTexts(writer, structures) {
        if (structures == null || structures.length === 0)
            return;
        writer.hangingIndent(() => {
            this.multipleWriter.printText(writer, structures);
        });
    }
    printTextInternal(writer, structure) {
        if (structure.name == null) {
            throw new common.errors
                .NotImplementedError("Not implemented scenario where parameter declaration structure doesn't have a name. Please open an issue if you need this.");
        }
        this.factory.forDecorator().printTextsInline(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.conditionalWrite(structure.isRestParameter, "...");
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypedNode(":", structure.hasQuestionToken).printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
    }
}

class CallSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode(true).printText(writer, structure);
        writer.write(";");
    }
}

class ConstructSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        writer.write("new");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class IndexSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`[${structure.keyName || "key"}: ${structure.keyType || "string"}]`);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class InterfaceDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`interface ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        writer.space();
        if (structure.extends != null) {
            const extendsText = structure.extends instanceof Array
                ? structure.extends.map(i => this.getText(writer, i)).join(", ")
                : this.getText(writer, structure.extends);
            if (!common.StringUtils.isNullOrWhitespace(extendsText))
                writer.hangingIndent(() => writer.write(`extends ${extendsText} `));
        }
        writer.inlineBlock(() => {
            this.factory.forTypeElementMemberedNode().printText(writer, structure);
        });
    }
}

class MethodSignatureStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class PropertySignatureStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypedNode(":").printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
        writer.write(";");
    }
}

class TypeElementMemberedNodeStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printText(writer, structure) {
        this.factory.forCallSignatureDeclaration().printTexts(writer, structure.callSignatures);
        this.conditionalSeparator(writer, structure.constructSignatures);
        this.factory.forConstructSignatureDeclaration().printTexts(writer, structure.constructSignatures);
        this.conditionalSeparator(writer, structure.indexSignatures);
        this.factory.forIndexSignatureDeclaration().printTexts(writer, structure.indexSignatures);
        this.conditionalSeparator(writer, structure.properties);
        this.factory.forPropertySignature().printTexts(writer, structure.properties);
        this.conditionalSeparator(writer, structure.methods);
        this.factory.forMethodSignature().printTexts(writer, structure.methods);
    }
    conditionalSeparator(writer, structures) {
        if (!common.ArrayUtils.isNullOrEmpty(structures) && !writer.isAtStartOfFirstLineOfBlock())
            writer.newLine();
    }
}

class TypeElementMemberStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printTexts(writer, members) {
        if (members == null)
            return;
        if (typeof members === "string" || members instanceof Function)
            this.printText(writer, members);
        else {
            for (const member of members) {
                if (isLastNonWhitespaceCharCloseBrace(writer))
                    writer.blankLineIfLastNot();
                else if (!writer.isAtStartOfFirstLineOfBlock())
                    writer.newLineIfLastNot();
                this.printText(writer, member);
            }
        }
    }
    printText(writer, members) {
        if (typeof members === "string" || members instanceof Function || members == null) {
            this.printTextOrWriterFunc(writer, members);
            return;
        }
        switch (members.kind) {
            case exports.StructureKind.PropertySignature:
                this.factory.forPropertySignature().printText(writer, members);
                break;
            case exports.StructureKind.MethodSignature:
                this.factory.forMethodSignature().printText(writer, members);
                break;
            case exports.StructureKind.CallSignature:
                this.factory.forCallSignatureDeclaration().printText(writer, members);
                break;
            case exports.StructureKind.IndexSignature:
                this.factory.forIndexSignatureDeclaration().printText(writer, members);
                break;
            case exports.StructureKind.ConstructSignature:
                this.factory.forConstructSignatureDeclaration().printText(writer, members);
                break;
            default:
                common.errors.throwNotImplementedForNeverValueError(members);
        }
    }
}

class JsxAttributeDeciderStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        if (isJsxAttribute())
            this.factory.forJsxAttribute().printText(writer, structure);
        else if (structure.kind === exports.StructureKind.JsxSpreadAttribute)
            this.factory.forJsxSpreadAttribute().printText(writer, structure);
        else
            throw common.errors.throwNotImplementedForNeverValueError(structure);
        function isJsxAttribute(struct) {
            return structure.kind == null || structure.kind === exports.StructureKind.JsxAttribute;
        }
    }
}

class JsxAttributeStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.write(structure.name);
        if (structure.initializer != null)
            writer.write("=").write(structure.initializer);
    }
}

class JsxChildDeciderStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        if (isJsxElement(structure))
            this.factory.forJsxElement().printText(writer, structure);
        else if (structure.kind === exports.StructureKind.JsxSelfClosingElement)
            this.factory.forJsxSelfClosingElement().printText(writer, structure);
        else
            common.errors.throwNotImplementedForNeverValueError(structure);
        function isJsxElement(struct) {
            return struct.kind == null || struct.kind === exports.StructureKind.JsxElement;
        }
    }
}

class JsxElementStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`<${structure.name}`);
            if (structure.attributes)
                this.printAttributes(writer, structure.attributes);
            writer.write(">");
        });
        this.printChildren(writer, structure.children);
        writer.write(`</${structure.name}>`);
    }
    printAttributes(writer, attributes) {
        const attributePrinter = this.factory.forJsxAttributeDecider();
        for (const attrib of attributes) {
            writer.space();
            attributePrinter.printText(writer, attrib);
        }
    }
    printChildren(writer, children) {
        if (children == null)
            return;
        writer.newLine();
        writer.indent(() => {
            for (const child of children) {
                this.factory.forJsxChildDecider().printText(writer, child);
                writer.newLine();
            }
        });
    }
}

class JsxSelfClosingElementStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`<${structure.name}`);
            if (structure.attributes)
                this.printAttributes(writer, structure.attributes);
            writer.write(" />");
        });
    }
    printAttributes(writer, attributes) {
        const attributePrinter = this.factory.forJsxAttributeDecider();
        for (const attrib of attributes) {
            writer.space();
            attributePrinter.printText(writer, attrib);
        }
    }
}

class JsxSpreadAttributeStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write("...");
            writer.write(structure.expression);
        });
    }
}

class ExportAssignmentStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        writer.write("export");
        if (structure.isExportEquals !== false)
            writer.write(" = ");
        else
            writer.write(" default ");
        writer.write(this.getTextWithQueuedChildIndentation(writer, structure.expression)).write(";");
    }
}

class ExportDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }